<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Create a List of Stan Arguments — create_stan_args • EpiNow2</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/lumen/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><!-- docsearch --><script src="../docsearch.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.3/docsearch.min.css" integrity="sha256-QOSRU/ra9ActyXkIBbiIB144aDBdtvXBcNc3OTNuX/Q=" crossorigin="anonymous"><link href="../docsearch.css" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script><meta property="og:title" content="Create a List of Stan Arguments — create_stan_args"><meta property="og:description" content="
Generates a list of arguments as required by rstan::sampling or rstan::vb by combining the required options,
with data, and type of initialisation. Initialisation defaults to random but it is expected that create_initial_conditions
will be used."><meta property="og:image" content="epiforecasts.io/EpiNow2/reference/figures/unnamed-chunk-13-1.png"><meta property="og:image:alt" content="Example estimates produced by EpiNow2 of the reproduction number, cases by date of infection and cases by date of report"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@seabbs"><meta name="twitter:site" content="@cmmid_lshtm"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">EpiNow2</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.3.3.10</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li>
  <a href="../reference/index.html">
    <span class="fa fa-file-code-o"></span>
     
    Functions
  </a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/epiforecasts/EpiNow2" class="external-link">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul><form class="navbar-form navbar-right hidden-xs hidden-sm" role="search">
        <div class="form-group">
          <input type="search" class="form-control" name="search-input" id="search-input" placeholder="Search..." aria-label="Search for..." autocomplete="off"></div>
      </form>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Create a List of Stan Arguments</h1>
    <small class="dont-index">Source: <a href="https://github.com/epiforecasts/EpiNow2/blob/HEAD/R/create.R" class="external-link"><code>R/create.R</code></a></small>
    <div class="hidden name"><code>create_stan_args.Rd</code></div>
    </div>

    <div class="ref-description">
    <p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable" class="external-link"><img src="figures/lifecycle-stable.svg" alt="[Stable]"></a>
Generates a list of arguments as required by <code><a href="https://mc-stan.org/rstan/reference/stanmodel-method-sampling.html" class="external-link">rstan::sampling</a></code> or <code><a href="https://mc-stan.org/rstan/reference/stanmodel-method-vb.html" class="external-link">rstan::vb</a></code> by combining the required options,
with data, and type of initialisation. Initialisation defaults to random but it is expected that <code>create_initial_conditions</code>
will be used.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="fu">create_stan_args</span><span class="op">(</span>
  stan <span class="op">=</span> <span class="fu"><a href="stan_opts.html">stan_opts</a></span><span class="op">(</span><span class="op">)</span>,
  data <span class="op">=</span> <span class="cn">NULL</span>,
  init <span class="op">=</span> <span class="st">"random"</span>,
  verbose <span class="op">=</span> <span class="cn">FALSE</span>
<span class="op">)</span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>stan</dt>
<dd><p>A list of stan options as generated by <code><a href="stan_opts.html">stan_opts()</a></code>. Defaults to <code><a href="stan_opts.html">stan_opts()</a></code>. Can be used to override
<code>data</code>, <code>init</code>, and <code>verbose</code> settings if desired.</p></dd>
<dt>data</dt>
<dd><p>A list of stan data as created by <code>create_stan_data</code></p></dd>
<dt>init</dt>
<dd><p>Initial conditions passed to <code>rstan</code>. Defaults to "random" but can also be a function (
as supplied by <code>create_intitial_conditions</code>).</p></dd>
<dt>verbose</dt>
<dd><p>Logical, defaults to <code>FALSE</code>. Should verbose progress messages be returned.</p></dd>
</dl></div>
    <div id="value">
    <h2>Value</h2>
    <p>A list of stan arguments</p>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span class="co"># default settings</span></span>
<span class="r-in"><span class="fu">create_stan_args</span><span class="op">(</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $init</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "random"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $refresh</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $object</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> S4 class stanmodel 'estimate_infections' coded as follows:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated gamma pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_gamma_pmf(int[] y, real mu, real sigma, int max_val) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = num_elements(y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate alpha and beta for gamma distribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real small = 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real large = 1e8;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_sigma = fmax(small, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_mu = fmax(small, mu);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real alpha = ((c_mu) / c_sigma)^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real beta = (c_mu) / (c_sigma^2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // account for numerical issues</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha = fmax(small, alpha);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha = fmin(large, alpha);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   beta = fmax(small, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   beta = fmin(large, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trunc_pmf = gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[i] = (gamma_cdf(y[i] + 1, alpha, beta) - gamma_cdf(y[i], alpha, beta)) /</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated lognormal pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_lognormal_pmf(int[] y, real mu, real sigma, int max_val) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = num_elements(y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real small = 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_sigma = fmax(small, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_mu = fmax(small, mu);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] adj_y = to_vector(y) + small;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] upper_y = (log(adj_y + 1) - c_mu) / c_sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] lower_y = (log(adj_y) - c_mu) / c_sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real max_cdf = normal_cdf((log(max_val + small) - c_mu) / c_sigma, 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real min_cdf = normal_cdf((log(small) - c_mu) / c_sigma, 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_cdf = max_cdf - min_cdf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[i] = (normal_cdf(upper_y[i], 0.0, 1.0) - normal_cdf(lower_y[i], 0.0, 1.0)) /</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_cdf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // reverse a mf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector reverse_mf(vector pmf, int max_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_pmf] rev_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (d in 1:max_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rev_pmf[d] = pmf[max_pmf - d + 1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return rev_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated gamma pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_delta_pmf(int[] y) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = num_elements(y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pmf[y[1]] = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (n &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 2:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       pmf[y[i]] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // convolve a pdf and case vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector convolve(vector cases, vector rev_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int t = num_elements(cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int max_pmf = num_elements(rev_pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[t] conv_cases = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      tail(rev_pmf, min(max_pmf, s)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    return(conv_cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // convolve latent infections to reported (but still unobserved) cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector convolve_to_report(vector infections,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           real[] delay_mean,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           real[] delay_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           int[] max_delay,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           int seeding_time) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t - seeding_time] reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] unobs_reports = infections;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int delays = num_elements(delay_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       vector[max_delay[s]] pmf = rep_vector(1e-5, max_delay[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       int delay_indexes[max_delay[s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 1:max_delay[s]) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         delay_indexes[i] = max_delay[s] - i;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       pmf = pmf + discretised_lognormal_pmf(delay_indexes, delay_mean[s],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                             delay_sd[s], max_delay[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       unobs_reports = convolve(unobs_reports, pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports = unobs_reports[(seeding_time + 1):t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports = infections[(seeding_time + 1):t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int delays = num_elements(delay_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (s in 1:delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // eigenvalues for approximate hilbert space gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // see here for details: https://arxiv.org/pdf/2004.11408.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real lambda(real L, int m) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lam;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lam = ((m*pi())/(2*L))^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return lam;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // eigenfunction for approximate hilbert space gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // see here for details: https://arxiv.org/pdf/2004.11408.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector phi(real L, int m, vector x) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[rows(x)] fi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return fi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // spectral density of the exponential quadratic kernal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real spd_se(real alpha, real rho, real w) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // spectral density of the Matern 3/2 kernel</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real spd_matern(real alpha, real rho, real w) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // setup gaussian process noise dimensions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> int setup_noise(int ot_h, int t, int horizon, int estimate_r,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 int stationary, int future_fixed, int fixed_from) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(noise_terms);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // setup approximate gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> matrix setup_gp(int M, real L, int dimension) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[dimension] time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[dimension, M] PHI;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real half_dim = dimension / 2.0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:dimension) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     time[s] = (s - half_dim) / half_dim;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     PHI[,m] = phi(L, m, time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(PHI);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update gaussian process using spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector update_gp(matrix PHI, int M, real L, real alpha,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                  real rho, vector eta, int type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] diagSPD;    // spectral density</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] SPD_eta;    // spectral density * noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms = rows(PHI);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real unit_rho = rho / noise_terms;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // GP in noise - spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (type == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for(m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m))));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else if (type == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for(m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m))));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   SPD_eta = diagSPD .* eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   noise = noise + PHI[,] * SPD_eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // priors for gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void gaussian_process_lp(real rho, real alpha, vector eta,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          real ls_meanlog, real ls_sdlog,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          real ls_min, real ls_max, real alpha_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (ls_sdlog &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha ~ normal(0, alpha_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update a vector of Rts</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector update_Rt(vector input_R, real log_R, vector noise, int[] bps,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                  real[] bp_effects, int stationary) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // define control parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(input_R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_n = num_elements(bp_effects);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_c = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gp_n = num_elements(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // define result vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] bp = rep_vector(0, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] gp = rep_vector(0, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // initialise breakpoints</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (bp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (bps[s]) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bp_c += bps[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bp[s] = bp_effects[bp_c];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp = cumulative_sum(bp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //initialise gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (stationary) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp[1:gp_n] = noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // fix future gp based on last estimated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (t &gt; gp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp[2:(gp_n + 1)] = noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp = cumulative_sum(gp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Calculate Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   R = rep_vector(log_R, t) + bp + gp;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   R = exp(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Rt priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real r_logmean, real r_logsd, real prior_infections,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real prior_growth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior on R</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   log_R ~ normal(r_logmean, r_logsd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //breakpoint effects on Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (bp_n &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp_sd[1] ~ normal(0, 0.1) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp_effects ~ normal(0, bp_sd[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // initial infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   initial_infections ~ normal(prior_infections, 0.2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (seeding_time &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     initial_growth ~ normal(prior_growth, 0.2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // calculate infectiousness (weighted sum of the generation time and infections)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // for a single time point</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real update_infectiousness(vector infections, vector gt_pmf,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            int seeding_time, int max_gt, int index){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // work out where to start the convolution of past infections with the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // generation time distribution: (current_time - maximal generation time) if</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // that is &gt;= 1, otherwise 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int inf_start = max(1, (index + seeding_time - max_gt));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // work out where to end the convolution: (current_time - 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int inf_end = (index + seeding_time - 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // number of indices of the generation time to sum over (inf_end - inf_start + 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int pmf_accessed = min(max_gt, index + seeding_time - 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate the elements of the convolution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(new_inf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector generate_infections(vector oR, int uot,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            real gt_mean, real gt_sd, int max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            real[] initial_infections, real[] initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            int pop, int ht) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // time indices and storage</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = num_elements(oR);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int nht = ot - ht;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = ot + uot;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] R = oR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real exp_adj_Rt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] cum_infections = rep_vector(0, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] infectiousness = rep_vector(1e-5, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // generation time pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_gt] gt_pmf = rep_vector(1e-5, max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // revert indices (this is for later doing the convolution with recent cases)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gt_indexes[max_gt];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:(max_gt)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_indexes[i] = max_gt - i + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // SD &gt; 0: use discretised gamma</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = gt_pmf + discretised_gamma_pmf(gt_indexes, gt_mean, gt_sd, max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // SD == 0: use discretised delta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = gt_pmf + discretised_delta_pmf(gt_indexes);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Initialise infections using daily growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   infections[1] = exp(initial_infections[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (uot &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 2:uot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate cumulative infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (pop) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cum_infections[1] = sum(infections[1:uot]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // iteratively update infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (pop &amp;&amp; s &gt; nht) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht]));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       exp_adj_Rt = exp_adj_Rt &gt; 1 ? 1 : exp_adj_Rt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s + uot] += R[s] * infectiousness[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (pop &amp;&amp; s &lt; ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // backcalculate infections using mean shifted cases and non-parametric noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              int prior) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(shifted_cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if(!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[t] exp_noise = exp(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (prior == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections = infections + shifted_cases .* exp_noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else if (prior == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      infections = infections + exp_noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else if (prior == 2) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 2:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         infections[i] = infections[i - 1] * exp_noise[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = infections + shifted_cases;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Update the log density for the generation time distribution mean and sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_mean_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // apply day of the week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int wl = num_elements(effect);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // scale day of week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[wl] scaled_effect = wl * effect;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] scaled_reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // add reporting effects (adjust for simplex scale)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(scaled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Scale observations by fraction reported and update log density of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // fraction reported</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector scale_obs(vector reports, real frac_obs) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] scaled_reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   scaled_reports = reports * frac_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(scaled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Calculate a truncation CMF</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int  trunc_indexes[trunc_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[trunc_max] cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:(trunc_max)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       trunc_indexes[i] = i - 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = discretised_lognormal_pmf(trunc_indexes, trunc_mean, trunc_sd, trunc_max);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf[1] = cmf[1] + 1e-8;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = cumulative_sum(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = reverse_mf(cmf, trunc_max);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Truncate observed data by some truncation distribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector truncate(vector reports, real[] truncation_mean, real[] truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 int[] truncation_max, int reconstruct) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation = num_elements(truncation_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] trunc_reports = reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (truncation) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Calculate cmf of truncation delay</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int trunc_max = truncation_max[1] &gt; t ? t : truncation_max[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int  trunc_indexes[trunc_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[trunc_max] cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int first_t = t - trunc_max + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = truncation_cmf(truncation_mean[1], truncation_sd[1], trunc_max);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Apply cdf of truncation delay to truncation max last entries in reports</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (reconstruct) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(trunc_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Truncation distribution priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void truncation_lp(real[] truncation_mean, real[] truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    real[] trunc_mean_mean, real[] trunc_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    real[] trunc_sd_mean, real[] trunc_sd_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation = num_elements(truncation_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (truncation) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update log density for reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void report_lp(int[] cases, vector reports,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                real[] rep_phi, real phi_mean, real phi_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                int model_type, real weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // the reciprocal overdispersion parameter (phi)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // defer to poisson if phi is large, to avoid overflow or</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // if poisson specified</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (weight == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases ~ poisson(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += poisson_lpmf(cases | reports) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (weight == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases ~ neg_binomial_2(reports, sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update log likelihood (as above but not vectorised and returning log likelihood)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector report_log_lik(int[] cases, vector reports,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       real[] rep_phi, int model_type, real weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // the reciprocal overdispersion parameter (phi)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // defer to poisson if phi is large, to avoid overflow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(log_lik);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // sample reported cases from the observation model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> int[] report_rng(vector reports, real[] rep_phi, int model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int sampled_reports[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // defer to poisson if phi is large, to avoid overflow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(sampled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // calculate Rt directly from inferred infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector calculate_Rt(vector infections, int seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     real gt_mean, real gt_sd, int max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     int smooth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_gt] gt_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gt_indexes[max_gt];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = t - seeding_time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] sR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] infectiousness = rep_vector(1e-5, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate PMF of the generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:(max_gt)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_indexes[i] = max_gt - i + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_gamma_pmf(gt_indexes, gt_mean, gt_sd, max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_delta_pmf(gt_indexes);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate Rt using Cori et al. approach</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     R[s] = infections[s + seeding_time] / infectiousness[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (smooth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       real window = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sR[s] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in max(1, s - smooth):min(ot, s + smooth)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         sR[s] += R[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         window += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sR[s] = sR[s] / window;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sR = R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(sR);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Convert an estimate of Rt to growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real[] R_to_growth(vector R, real gt_mean, real gt_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real k = pow(gt_sd / gt_mean, 2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // limit as gt_sd -&gt; 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       r[s] = log(R[s]) / gt_mean;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(r);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t;                                            // unobserved time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int seeding_time;                                 // time period used for seeding and not observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int horizon;                                      // forecast horizon</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int future_time;                                  // time in future for Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower = 0&gt;[t] shifted_cases;               // prior infections (for backcalculation)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int delays;                  // no. of delay distributions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean_sd[delays];  // prior sd of mean incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean_mean[delays];// prior mean of mean incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_sd_mean[delays];  // prior sd of sd of incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_sd_sd[delays];    // prior sd of sd of incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_delay[delays];       // maximum incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real L;				                     // boundary value for infections gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; M;			               // basis functions for infections gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real ls_meanlog;                   // meanlog for gp lengthscale prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real ls_sdlog;                     // sdlog for gp lengthscale prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; ls_min;              // Lower bound for the lengthscale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; ls_max;              // Upper bound for the lengthscale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int stationary;                    // is underlying gaussian process first or second order</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int fixed;                         //  should a gaussian process be used</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_mean_sd;                   // prior sd of mean generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_mean_mean;                 // prior mean of mean generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_sd_mean;                   // prior mean of sd of generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_sd_sd;                     // prior sd of sd of generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_gt;                        // maximum generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int estimate_r;                    // should the reproduction no be estimated (1 = yes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real prior_infections;             // prior for initial infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real prior_growth;                 // prior on initial growth rate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_n;                          // no of breakpoints (0 = no breakpoints)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int breakpoints[t - seeding_time]; // when do breakpoints occur</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int future_fixed;                  // is underlying future Rt assumed to be fixed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int fixed_from;                    // Reference date for when Rt estimation should be fixed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int pop;                           // Initial susceptible population</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int backcalc_prior;                // Prior type to use for backcalculation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int rt_half_window;                // Half the moving average window used when calculating Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real phi_mean;                      // Mean and sd of the normal prior for the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real phi_sd;                        // reporting process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int week_effect;                   // length of week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation;                    // 1/0 indicating if truncation should be adjusted for</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_mean_mean[truncation];  // truncation mean of mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_mean_sd[truncation];    // truncation sd of mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_sd_mean[truncation];    // truncation mean of sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_sd_sd[truncation];      // truncation sd of sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_truncation[truncation];    // maximum truncation supported</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int obs_scale;                     // logical controlling scaling of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_scale_mean;               // mean scaling factor for observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_scale_sd;                 // standard deviation of observation scaling</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_weight;                   // weight given to observation in log density</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int likelihood;                    // Should the likelihood be included in the model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int return_likelihood; // Should the likehood be returned by the model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = t - seeding_time - horizon;  // observed time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot_h = ot + horizon;  // observed time + forecast horizon</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = ls_min,upper=ls_max&gt; rho[fixed ? 0 : 1];  // length scale of noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];    // scale of of noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[fixed ? 0 : M] eta;               // unconstrained noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real initial_infections[estimate_r] ;    // seed infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real initial_growth[estimate_r &amp;&amp; seeding_time &gt; 1 ? 1 : 0]; // seed growth rate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0, upper = max_gt&gt; gt_mean[estimate_r &amp;&amp; gt_mean_sd &gt; 0]; // mean of generation time (if uncertain)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; gt_sd[estimate_r &amp;&amp; gt_sd_sd &gt; 0];       // sd of generation time (if uncertain)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; bp_sd[bp_n &gt; 0 ? 1 : 0]; // standard deviation of breakpoint effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real bp_effects[bp_n];                   // Rt breakpoint effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observation model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean[delays];                 // mean of delays</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; delay_sd[delays];        // sd of delays</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; frac_obs[obs_scale];     // fraction of cases that are ultimately observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real truncation_mean[truncation];        // mean of truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; truncation_sd[truncation]; // sd of truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; rep_phi[model_type];     // overdispersion of the reporting process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower = 0, upper = 10 * r_mean&gt;[estimate_r &gt; 0 ? ot_h : 0] R; // reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections;                                     // latent infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot_h] reports;                                     // estimated reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] obs_reports;                                   // observed estimated reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // GP in noise - spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Estimate latent infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // via Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_mean = (gt_mean_sd &gt; 0 ? gt_mean[1] : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_sd = (gt_sd_sd &gt; 0 ? gt_sd[1] : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     R = update_Rt(R, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      initial_infections, initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      pop, future_time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // via deconvolution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // convolve from latent infections to mean of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  // weekly reporting effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (week_effect &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // scaling of reported cases by fraction observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (obs_scale) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reports = scale_obs(reports, frac_obs[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  // truncate near time cases to observed reports</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  obs_reports = truncate(reports[1:ot], truncation_mean, truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                         max_truncation, 0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gaussian_process_lp(rho[1], alpha[1], eta, ls_meanlog,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                         ls_sdlog, ls_min, ls_max, alpha_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // penalised priors for delay distributions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   delays_lp(delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, delay_sd_sd, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   truncation_lp(truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 trunc_sd_mean, trunc_sd_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // priors on Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rt_lp(log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           r_logmean, r_logsd, prior_infections, prior_growth);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // penalised_prior on generation interval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     generation_time_lp(gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior observation scaling</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (obs_scale) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observed reports from mean of reports (update likelihood)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (likelihood) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     report_lp(cases, obs_reports, rep_phi, phi_mean, phi_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>               model_type, obs_weight);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int imputed_reports[ot_h];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r[ot_h];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[return_likelihood &gt; 1 ? ot : 0] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // estimate growth from estimated Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_mean = (gt_mean_sd &gt; 0 ? gt_mean[1] : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_sd = (gt_sd_sd &gt; 0 ? gt_sd[1] : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     r = R_to_growth(R, set_gt_mean, set_gt_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // sample generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real gt_mean_sample = (gt_mean_sd &gt; 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real gt_sd_sample = (gt_sd_sd &gt; 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // calculate Rt using infections and generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gen_R = calculate_Rt(infections, seeding_time, gt_mean_sample, gt_sd_sample,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          max_gt, rt_half_window);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // estimate growth from calculated Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // simulate reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   imputed_reports = report_rng(reports, rep_phi, model_type);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // log likelihood of model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (return_likelihood) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     log_lik = report_log_lik(cases, obs_reports, rep_phi, model_type,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              obs_weight);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> } </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $method</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "sampling"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cores</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $warmup</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 250</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $chains</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $save_warmup</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $seed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 71416835</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $future</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $max_execution_time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] Inf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control$adapt_delta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 0.95</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control$max_treedepth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 15</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $iter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 750</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># increasing warmup</span></span>
<span class="r-in"><span class="fu">create_stan_args</span><span class="op">(</span>stan <span class="op">=</span> <span class="fu"><a href="stan_opts.html">stan_opts</a></span><span class="op">(</span>warmup <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $init</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "random"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $refresh</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $object</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> S4 class stanmodel 'estimate_infections' coded as follows:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated gamma pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_gamma_pmf(int[] y, real mu, real sigma, int max_val) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = num_elements(y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate alpha and beta for gamma distribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real small = 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real large = 1e8;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_sigma = fmax(small, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_mu = fmax(small, mu);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real alpha = ((c_mu) / c_sigma)^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real beta = (c_mu) / (c_sigma^2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // account for numerical issues</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha = fmax(small, alpha);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha = fmin(large, alpha);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   beta = fmax(small, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   beta = fmin(large, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trunc_pmf = gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[i] = (gamma_cdf(y[i] + 1, alpha, beta) - gamma_cdf(y[i], alpha, beta)) /</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated lognormal pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_lognormal_pmf(int[] y, real mu, real sigma, int max_val) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = num_elements(y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real small = 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_sigma = fmax(small, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_mu = fmax(small, mu);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] adj_y = to_vector(y) + small;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] upper_y = (log(adj_y + 1) - c_mu) / c_sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] lower_y = (log(adj_y) - c_mu) / c_sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real max_cdf = normal_cdf((log(max_val + small) - c_mu) / c_sigma, 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real min_cdf = normal_cdf((log(small) - c_mu) / c_sigma, 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_cdf = max_cdf - min_cdf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[i] = (normal_cdf(upper_y[i], 0.0, 1.0) - normal_cdf(lower_y[i], 0.0, 1.0)) /</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_cdf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // reverse a mf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector reverse_mf(vector pmf, int max_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_pmf] rev_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (d in 1:max_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rev_pmf[d] = pmf[max_pmf - d + 1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return rev_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated gamma pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_delta_pmf(int[] y) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = num_elements(y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pmf[y[1]] = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (n &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 2:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       pmf[y[i]] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // convolve a pdf and case vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector convolve(vector cases, vector rev_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int t = num_elements(cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int max_pmf = num_elements(rev_pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[t] conv_cases = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      tail(rev_pmf, min(max_pmf, s)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    return(conv_cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // convolve latent infections to reported (but still unobserved) cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector convolve_to_report(vector infections,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           real[] delay_mean,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           real[] delay_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           int[] max_delay,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           int seeding_time) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t - seeding_time] reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] unobs_reports = infections;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int delays = num_elements(delay_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       vector[max_delay[s]] pmf = rep_vector(1e-5, max_delay[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       int delay_indexes[max_delay[s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 1:max_delay[s]) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         delay_indexes[i] = max_delay[s] - i;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       pmf = pmf + discretised_lognormal_pmf(delay_indexes, delay_mean[s],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                             delay_sd[s], max_delay[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       unobs_reports = convolve(unobs_reports, pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports = unobs_reports[(seeding_time + 1):t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports = infections[(seeding_time + 1):t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int delays = num_elements(delay_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (s in 1:delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // eigenvalues for approximate hilbert space gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // see here for details: https://arxiv.org/pdf/2004.11408.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real lambda(real L, int m) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lam;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lam = ((m*pi())/(2*L))^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return lam;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // eigenfunction for approximate hilbert space gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // see here for details: https://arxiv.org/pdf/2004.11408.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector phi(real L, int m, vector x) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[rows(x)] fi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return fi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // spectral density of the exponential quadratic kernal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real spd_se(real alpha, real rho, real w) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // spectral density of the Matern 3/2 kernel</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real spd_matern(real alpha, real rho, real w) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // setup gaussian process noise dimensions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> int setup_noise(int ot_h, int t, int horizon, int estimate_r,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 int stationary, int future_fixed, int fixed_from) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(noise_terms);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // setup approximate gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> matrix setup_gp(int M, real L, int dimension) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[dimension] time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[dimension, M] PHI;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real half_dim = dimension / 2.0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:dimension) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     time[s] = (s - half_dim) / half_dim;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     PHI[,m] = phi(L, m, time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(PHI);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update gaussian process using spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector update_gp(matrix PHI, int M, real L, real alpha,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                  real rho, vector eta, int type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] diagSPD;    // spectral density</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] SPD_eta;    // spectral density * noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms = rows(PHI);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real unit_rho = rho / noise_terms;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // GP in noise - spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (type == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for(m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m))));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else if (type == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for(m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m))));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   SPD_eta = diagSPD .* eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   noise = noise + PHI[,] * SPD_eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // priors for gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void gaussian_process_lp(real rho, real alpha, vector eta,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          real ls_meanlog, real ls_sdlog,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          real ls_min, real ls_max, real alpha_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (ls_sdlog &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha ~ normal(0, alpha_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update a vector of Rts</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector update_Rt(vector input_R, real log_R, vector noise, int[] bps,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                  real[] bp_effects, int stationary) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // define control parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(input_R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_n = num_elements(bp_effects);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_c = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gp_n = num_elements(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // define result vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] bp = rep_vector(0, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] gp = rep_vector(0, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // initialise breakpoints</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (bp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (bps[s]) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bp_c += bps[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bp[s] = bp_effects[bp_c];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp = cumulative_sum(bp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //initialise gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (stationary) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp[1:gp_n] = noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // fix future gp based on last estimated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (t &gt; gp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp[2:(gp_n + 1)] = noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp = cumulative_sum(gp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Calculate Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   R = rep_vector(log_R, t) + bp + gp;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   R = exp(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Rt priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real r_logmean, real r_logsd, real prior_infections,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real prior_growth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior on R</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   log_R ~ normal(r_logmean, r_logsd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //breakpoint effects on Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (bp_n &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp_sd[1] ~ normal(0, 0.1) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp_effects ~ normal(0, bp_sd[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // initial infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   initial_infections ~ normal(prior_infections, 0.2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (seeding_time &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     initial_growth ~ normal(prior_growth, 0.2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // calculate infectiousness (weighted sum of the generation time and infections)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // for a single time point</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real update_infectiousness(vector infections, vector gt_pmf,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            int seeding_time, int max_gt, int index){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // work out where to start the convolution of past infections with the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // generation time distribution: (current_time - maximal generation time) if</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // that is &gt;= 1, otherwise 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int inf_start = max(1, (index + seeding_time - max_gt));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // work out where to end the convolution: (current_time - 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int inf_end = (index + seeding_time - 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // number of indices of the generation time to sum over (inf_end - inf_start + 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int pmf_accessed = min(max_gt, index + seeding_time - 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate the elements of the convolution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(new_inf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector generate_infections(vector oR, int uot,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            real gt_mean, real gt_sd, int max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            real[] initial_infections, real[] initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            int pop, int ht) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // time indices and storage</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = num_elements(oR);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int nht = ot - ht;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = ot + uot;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] R = oR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real exp_adj_Rt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] cum_infections = rep_vector(0, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] infectiousness = rep_vector(1e-5, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // generation time pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_gt] gt_pmf = rep_vector(1e-5, max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // revert indices (this is for later doing the convolution with recent cases)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gt_indexes[max_gt];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:(max_gt)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_indexes[i] = max_gt - i + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // SD &gt; 0: use discretised gamma</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = gt_pmf + discretised_gamma_pmf(gt_indexes, gt_mean, gt_sd, max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // SD == 0: use discretised delta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = gt_pmf + discretised_delta_pmf(gt_indexes);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Initialise infections using daily growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   infections[1] = exp(initial_infections[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (uot &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 2:uot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate cumulative infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (pop) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cum_infections[1] = sum(infections[1:uot]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // iteratively update infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (pop &amp;&amp; s &gt; nht) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht]));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       exp_adj_Rt = exp_adj_Rt &gt; 1 ? 1 : exp_adj_Rt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s + uot] += R[s] * infectiousness[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (pop &amp;&amp; s &lt; ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // backcalculate infections using mean shifted cases and non-parametric noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              int prior) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(shifted_cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if(!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[t] exp_noise = exp(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (prior == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections = infections + shifted_cases .* exp_noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else if (prior == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      infections = infections + exp_noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else if (prior == 2) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 2:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         infections[i] = infections[i - 1] * exp_noise[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = infections + shifted_cases;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Update the log density for the generation time distribution mean and sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_mean_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // apply day of the week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int wl = num_elements(effect);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // scale day of week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[wl] scaled_effect = wl * effect;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] scaled_reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // add reporting effects (adjust for simplex scale)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(scaled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Scale observations by fraction reported and update log density of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // fraction reported</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector scale_obs(vector reports, real frac_obs) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] scaled_reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   scaled_reports = reports * frac_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(scaled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Calculate a truncation CMF</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int  trunc_indexes[trunc_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[trunc_max] cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:(trunc_max)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       trunc_indexes[i] = i - 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = discretised_lognormal_pmf(trunc_indexes, trunc_mean, trunc_sd, trunc_max);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf[1] = cmf[1] + 1e-8;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = cumulative_sum(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = reverse_mf(cmf, trunc_max);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Truncate observed data by some truncation distribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector truncate(vector reports, real[] truncation_mean, real[] truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 int[] truncation_max, int reconstruct) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation = num_elements(truncation_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] trunc_reports = reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (truncation) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Calculate cmf of truncation delay</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int trunc_max = truncation_max[1] &gt; t ? t : truncation_max[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int  trunc_indexes[trunc_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[trunc_max] cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int first_t = t - trunc_max + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = truncation_cmf(truncation_mean[1], truncation_sd[1], trunc_max);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Apply cdf of truncation delay to truncation max last entries in reports</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (reconstruct) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(trunc_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Truncation distribution priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void truncation_lp(real[] truncation_mean, real[] truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    real[] trunc_mean_mean, real[] trunc_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    real[] trunc_sd_mean, real[] trunc_sd_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation = num_elements(truncation_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (truncation) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update log density for reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void report_lp(int[] cases, vector reports,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                real[] rep_phi, real phi_mean, real phi_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                int model_type, real weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // the reciprocal overdispersion parameter (phi)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // defer to poisson if phi is large, to avoid overflow or</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // if poisson specified</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (weight == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases ~ poisson(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += poisson_lpmf(cases | reports) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (weight == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases ~ neg_binomial_2(reports, sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update log likelihood (as above but not vectorised and returning log likelihood)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector report_log_lik(int[] cases, vector reports,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       real[] rep_phi, int model_type, real weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // the reciprocal overdispersion parameter (phi)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // defer to poisson if phi is large, to avoid overflow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(log_lik);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // sample reported cases from the observation model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> int[] report_rng(vector reports, real[] rep_phi, int model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int sampled_reports[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // defer to poisson if phi is large, to avoid overflow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(sampled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // calculate Rt directly from inferred infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector calculate_Rt(vector infections, int seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     real gt_mean, real gt_sd, int max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     int smooth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_gt] gt_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gt_indexes[max_gt];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = t - seeding_time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] sR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] infectiousness = rep_vector(1e-5, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate PMF of the generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:(max_gt)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_indexes[i] = max_gt - i + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_gamma_pmf(gt_indexes, gt_mean, gt_sd, max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_delta_pmf(gt_indexes);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate Rt using Cori et al. approach</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     R[s] = infections[s + seeding_time] / infectiousness[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (smooth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       real window = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sR[s] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in max(1, s - smooth):min(ot, s + smooth)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         sR[s] += R[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         window += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sR[s] = sR[s] / window;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sR = R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(sR);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Convert an estimate of Rt to growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real[] R_to_growth(vector R, real gt_mean, real gt_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real k = pow(gt_sd / gt_mean, 2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // limit as gt_sd -&gt; 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       r[s] = log(R[s]) / gt_mean;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(r);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t;                                            // unobserved time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int seeding_time;                                 // time period used for seeding and not observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int horizon;                                      // forecast horizon</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int future_time;                                  // time in future for Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower = 0&gt;[t] shifted_cases;               // prior infections (for backcalculation)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int delays;                  // no. of delay distributions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean_sd[delays];  // prior sd of mean incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean_mean[delays];// prior mean of mean incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_sd_mean[delays];  // prior sd of sd of incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_sd_sd[delays];    // prior sd of sd of incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_delay[delays];       // maximum incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real L;				                     // boundary value for infections gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; M;			               // basis functions for infections gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real ls_meanlog;                   // meanlog for gp lengthscale prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real ls_sdlog;                     // sdlog for gp lengthscale prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; ls_min;              // Lower bound for the lengthscale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; ls_max;              // Upper bound for the lengthscale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int stationary;                    // is underlying gaussian process first or second order</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int fixed;                         //  should a gaussian process be used</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_mean_sd;                   // prior sd of mean generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_mean_mean;                 // prior mean of mean generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_sd_mean;                   // prior mean of sd of generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_sd_sd;                     // prior sd of sd of generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_gt;                        // maximum generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int estimate_r;                    // should the reproduction no be estimated (1 = yes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real prior_infections;             // prior for initial infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real prior_growth;                 // prior on initial growth rate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_n;                          // no of breakpoints (0 = no breakpoints)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int breakpoints[t - seeding_time]; // when do breakpoints occur</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int future_fixed;                  // is underlying future Rt assumed to be fixed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int fixed_from;                    // Reference date for when Rt estimation should be fixed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int pop;                           // Initial susceptible population</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int backcalc_prior;                // Prior type to use for backcalculation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int rt_half_window;                // Half the moving average window used when calculating Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real phi_mean;                      // Mean and sd of the normal prior for the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real phi_sd;                        // reporting process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int week_effect;                   // length of week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation;                    // 1/0 indicating if truncation should be adjusted for</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_mean_mean[truncation];  // truncation mean of mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_mean_sd[truncation];    // truncation sd of mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_sd_mean[truncation];    // truncation mean of sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_sd_sd[truncation];      // truncation sd of sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_truncation[truncation];    // maximum truncation supported</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int obs_scale;                     // logical controlling scaling of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_scale_mean;               // mean scaling factor for observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_scale_sd;                 // standard deviation of observation scaling</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_weight;                   // weight given to observation in log density</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int likelihood;                    // Should the likelihood be included in the model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int return_likelihood; // Should the likehood be returned by the model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = t - seeding_time - horizon;  // observed time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot_h = ot + horizon;  // observed time + forecast horizon</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = ls_min,upper=ls_max&gt; rho[fixed ? 0 : 1];  // length scale of noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];    // scale of of noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[fixed ? 0 : M] eta;               // unconstrained noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real initial_infections[estimate_r] ;    // seed infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real initial_growth[estimate_r &amp;&amp; seeding_time &gt; 1 ? 1 : 0]; // seed growth rate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0, upper = max_gt&gt; gt_mean[estimate_r &amp;&amp; gt_mean_sd &gt; 0]; // mean of generation time (if uncertain)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; gt_sd[estimate_r &amp;&amp; gt_sd_sd &gt; 0];       // sd of generation time (if uncertain)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; bp_sd[bp_n &gt; 0 ? 1 : 0]; // standard deviation of breakpoint effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real bp_effects[bp_n];                   // Rt breakpoint effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observation model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean[delays];                 // mean of delays</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; delay_sd[delays];        // sd of delays</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; frac_obs[obs_scale];     // fraction of cases that are ultimately observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real truncation_mean[truncation];        // mean of truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; truncation_sd[truncation]; // sd of truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; rep_phi[model_type];     // overdispersion of the reporting process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower = 0, upper = 10 * r_mean&gt;[estimate_r &gt; 0 ? ot_h : 0] R; // reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections;                                     // latent infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot_h] reports;                                     // estimated reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] obs_reports;                                   // observed estimated reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // GP in noise - spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Estimate latent infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // via Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_mean = (gt_mean_sd &gt; 0 ? gt_mean[1] : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_sd = (gt_sd_sd &gt; 0 ? gt_sd[1] : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     R = update_Rt(R, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      initial_infections, initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      pop, future_time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // via deconvolution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // convolve from latent infections to mean of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  // weekly reporting effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (week_effect &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // scaling of reported cases by fraction observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (obs_scale) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reports = scale_obs(reports, frac_obs[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  // truncate near time cases to observed reports</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  obs_reports = truncate(reports[1:ot], truncation_mean, truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                         max_truncation, 0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gaussian_process_lp(rho[1], alpha[1], eta, ls_meanlog,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                         ls_sdlog, ls_min, ls_max, alpha_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // penalised priors for delay distributions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   delays_lp(delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, delay_sd_sd, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   truncation_lp(truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 trunc_sd_mean, trunc_sd_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // priors on Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rt_lp(log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           r_logmean, r_logsd, prior_infections, prior_growth);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // penalised_prior on generation interval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     generation_time_lp(gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior observation scaling</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (obs_scale) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observed reports from mean of reports (update likelihood)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (likelihood) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     report_lp(cases, obs_reports, rep_phi, phi_mean, phi_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>               model_type, obs_weight);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int imputed_reports[ot_h];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r[ot_h];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[return_likelihood &gt; 1 ? ot : 0] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // estimate growth from estimated Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_mean = (gt_mean_sd &gt; 0 ? gt_mean[1] : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_sd = (gt_sd_sd &gt; 0 ? gt_sd[1] : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     r = R_to_growth(R, set_gt_mean, set_gt_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // sample generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real gt_mean_sample = (gt_mean_sd &gt; 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real gt_sd_sample = (gt_sd_sd &gt; 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // calculate Rt using infections and generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gen_R = calculate_Rt(infections, seeding_time, gt_mean_sample, gt_sd_sample,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          max_gt, rt_half_window);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // estimate growth from calculated Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // simulate reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   imputed_reports = report_rng(reports, rep_phi, model_type);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // log likelihood of model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (return_likelihood) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     log_lik = report_log_lik(cases, obs_reports, rep_phi, model_type,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              obs_weight);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> } </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $method</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "sampling"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cores</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $warmup</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $chains</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $save_warmup</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $seed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 61035910</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $future</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $max_execution_time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] Inf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control$adapt_delta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 0.95</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control$max_treedepth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 15</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $iter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1500</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by <a href="https://www.samabbott.co.uk/" class="external-link">Sam Abbott</a>, Joel Hellewell, Katharine Sherratt, Katelyn Gostic, Joe Hickson, Hamada S. Badr, Michael DeWitt, EpiForecasts, <a href="https://www.lshtm.ac.uk/aboutus/people/funk.sebastian" class="external-link">Sebastian Funk</a>.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.1.9000.</p>
</div>

      </footer></div>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.1/docsearch.min.js" integrity="sha256-GKvGqXDznoRYHCwKXGnuchvKSwmx9SRMrZOTh2g4Sb0=" crossorigin="anonymous"></script><script>
  docsearch({
    
    
    apiKey: '43da981922253a06c4dfab7b53f2410e',
    indexName: 'epinow2',
    inputSelector: 'input#search-input.form-control',
    transformData: function(hits) {
      return hits.map(function (hit) {
        hit.url = updateHitURL(hit);
        return hit;
      });
    }
  });
</script></body></html>

