<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="
Defines a list specifying the arguments passed to underlying stan
backend functions via rstan_sampling_opts() and rstan_vb_opts(). Custom settings
can be supplied which override the defaults."><title>Stan Options — stan_opts • EpiNow2</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.3/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.3/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Stan Options — stan_opts"><meta property="og:description" content="
Defines a list specifying the arguments passed to underlying stan
backend functions via rstan_sampling_opts() and rstan_vb_opts(). Custom settings
can be supplied which override the defaults."><meta property="og:image" content="epiforecasts.io/EpiNow2/reference/figures/unnamed-chunk-14-1.png"><meta property="og:image:alt" content="Example estimates produced by EpiNow2 of the reproduction number, cases by date of infection and cases by date of report"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@seabbs"><meta name="twitter:site" content="@cmmid_lshtm"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">EpiNow2</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Released version">1.3.3</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-model-definitions">Model definitions</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-model-definitions">
    <a class="dropdown-item" href="../articles/estimate_infections.html">estimate_infections()</a>
    <a class="dropdown-item" href="../articles/estimate_secondary.html">estimate_secondary()</a>
    <a class="dropdown-item" href="../articles/estimate_truncation.html">estimate_truncation()</a>
  </div>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-case-studies">Case studies</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-case-studies">
    <a class="dropdown-item" href="../articles/case-studies.html">External case studies and use in the literature</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/epiforecasts/EpiNow2/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Stan Options</h1>
      <small class="dont-index">Source: <a href="https://github.com/epiforecasts/EpiNow2/blob/HEAD/R/opts.R" class="external-link"><code>R/opts.R</code></a></small>
      <div class="d-none name"><code>stan_opts.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable" class="external-link"><img src="figures/lifecycle-stable.svg" alt="[Stable]"></a>
Defines a list specifying the arguments passed to underlying stan
backend functions via <code><a href="rstan_sampling_opts.html">rstan_sampling_opts()</a></code> and <code><a href="rstan_vb_opts.html">rstan_vb_opts()</a></code>. Custom settings
can be supplied which override the defaults.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">stan_opts</span><span class="op">(</span></span>
<span>  samples <span class="op">=</span> <span class="fl">2000</span>,</span>
<span>  backend <span class="op">=</span> <span class="st">"rstan"</span>,</span>
<span>  init_fit <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  return_fit <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>samples</dt>
<dd><p>Numeric, default 2000. Overall number of posterior samples.
When using multiple chains iterations per chain is samples / chains.</p></dd>


<dt>backend</dt>
<dd><p>Character string indicating the backend to use for fitting stan models.
Currently only "rstan" is supported.</p></dd>


<dt>init_fit</dt>
<dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental" class="external-link"><img src="figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
Character string or <code>stanfit</code> object, defaults to NULL. Should an initial fit be used to
initialise the full fit. An example scenario would be using a national level fit to parametrise
regional level fits. Optionally a character string can be passed with the currently supported
option being "cumulative". This fits the model to cumulative cases and may be useful for certain
data sets where the sampler gets stuck or struggles to initialise. See <code><a href="init_cumulative_fit.html">init_cumulative_fit()</a></code> for details.
This implementation is based on the approach taken in <a href="https://github.com/ImperialCollegeLondon/epidemia/" class="external-link">epidemia</a>
authored by James Scott.</p></dd>


<dt>return_fit</dt>
<dd><p>Logical, defaults to TRUE. Should the fit stan model be returned.</p></dd>


<dt>...</dt>
<dd><p>Additional parameters to pass  underlying option functions.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>A list of arguments to pass to the appropriate rstan functions.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p>rstan_opts</p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># using default of rstan::sampling</span></span></span>
<span class="r-in"><span><span class="fu">stan_opts</span><span class="op">(</span>samples <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $object</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> S4 class stanmodel 'estimate_infections' coded as follows:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated gamma pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_gamma_pmf(real mu, real sigma, int max_val) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = max_val;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n+1] upper_cdf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate alpha and beta for gamma distribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real small = 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real large = 1e8;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_sigma = fmax(small, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_mu = fmax(small, mu);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real alpha = ((c_mu) / c_sigma)^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real beta = (c_mu) / (c_sigma^2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // account for numerical issues</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha = fmax(small, alpha);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha = fmin(large, alpha);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   beta = fmax(small, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   beta = fmin(large, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:(n+1)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     upper_cdf[i] = gamma_cdf(i,  alpha, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // discretise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[n+1-i] = upper_cdf[i+1] - upper_cdf[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pmf = pmf / (upper_cdf[n+1] - upper_cdf[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated lognormal pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_lognormal_pmf(real mu, real sigma, int max_val, int rev) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = max_val;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] upper_cdf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     upper_cdf[i] = lognormal_cdf(i,  mu, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // discretise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (rev) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[n] = upper_cdf[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 2:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       pmf[n+1-i] = upper_cdf[i] - upper_cdf[i-1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[1] = upper_cdf[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[2:n] = upper_cdf[2:n] - upper_cdf[1:(n-1)];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // normalize</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pmf = pmf / upper_cdf[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // reverse a mf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector reverse_mf(vector pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_pmf = num_elements(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_pmf] rev_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (d in 1:max_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rev_pmf[d] = pmf[max_pmf - d + 1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return rev_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated gamma pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_delta_pmf(int n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf = rep_vector(0, n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pmf[n] = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // convolve a pdf and case vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector convolve(vector cases, vector rev_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int t = num_elements(cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int max_pmf = num_elements(rev_pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[t] conv_cases = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      tail(rev_pmf, min(max_pmf, s)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    return(conv_cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // convolve latent infections to reported (but still unobserved) cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector convolve_to_report(vector infections,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           real[] delay_mean,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           real[] delay_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           int[] max_delay,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           int seeding_time) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t - seeding_time] reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] unobs_reports = infections;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int delays = num_elements(delay_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       vector[max_delay[s]] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       pmf = discretised_lognormal_pmf(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         delay_mean[s], delay_sd[s], max_delay[s], 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       unobs_reports = convolve(unobs_reports, pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports = unobs_reports[(seeding_time + 1):t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports = infections[(seeding_time + 1):t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int delays = num_elements(delay_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (s in 1:delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // eigenvalues for approximate hilbert space gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // see here for details: https://arxiv.org/pdf/2004.11408.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real lambda(real L, int m) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lam;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lam = ((m*pi())/(2*L))^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return lam;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // eigenfunction for approximate hilbert space gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // see here for details: https://arxiv.org/pdf/2004.11408.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector phi(real L, int m, vector x) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[rows(x)] fi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return fi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // spectral density of the exponential quadratic kernal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real spd_se(real alpha, real rho, real w) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // spectral density of the Matern 3/2 kernel</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real spd_matern(real alpha, real rho, real w) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // setup gaussian process noise dimensions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> int setup_noise(int ot_h, int t, int horizon, int estimate_r,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 int stationary, int future_fixed, int fixed_from) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(noise_terms);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // setup approximate gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> matrix setup_gp(int M, real L, int dimension) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[dimension] time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[dimension, M] PHI;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real half_dim = dimension / 2.0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:dimension) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     time[s] = (s - half_dim) / half_dim;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     PHI[,m] = phi(L, m, time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(PHI);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update gaussian process using spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector update_gp(matrix PHI, int M, real L, real alpha,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                  real rho, vector eta, int type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] diagSPD;    // spectral density</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] SPD_eta;    // spectral density * noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms = rows(PHI);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real unit_rho = rho / noise_terms;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // GP in noise - spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (type == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for(m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m))));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else if (type == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for(m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m))));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   SPD_eta = diagSPD .* eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   noise = noise + PHI[,] * SPD_eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // priors for gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void gaussian_process_lp(real rho, real alpha, vector eta,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          real ls_meanlog, real ls_sdlog,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          real ls_min, real ls_max, real alpha_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (ls_sdlog &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha ~ normal(0, alpha_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update a vector of Rts</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector update_Rt(int t, real log_R, vector noise, int[] bps,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                  real[] bp_effects, int stationary) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // define control parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_n = num_elements(bp_effects);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_c = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gp_n = num_elements(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // define result vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] bp = rep_vector(0, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] gp = rep_vector(0, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // initialise breakpoints</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (bp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (bps[s]) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bp_c += bps[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bp[s] = bp_effects[bp_c];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp = cumulative_sum(bp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //initialise gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (stationary) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp[1:gp_n] = noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // fix future gp based on last estimated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (t &gt; gp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp[2:(gp_n + 1)] = noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp = cumulative_sum(gp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Calculate Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   R = rep_vector(log_R, t) + bp + gp;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   R = exp(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Rt priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real r_logmean, real r_logsd, real prior_infections,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real prior_growth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior on R</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   log_R ~ normal(r_logmean, r_logsd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //breakpoint effects on Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (bp_n &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp_sd[1] ~ normal(0, 0.1) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp_effects ~ normal(0, bp_sd[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // initial infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   initial_infections ~ normal(prior_infections, 0.2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (seeding_time &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     initial_growth ~ normal(prior_growth, 0.2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // calculate infectiousness (weighted sum of the generation time and infections)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // for a single time point</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real update_infectiousness(vector infections, vector gt_pmf,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            int seeding_time, int max_gt, int index){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // work out where to start the convolution of past infections with the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // generation time distribution: (current_time - maximal generation time) if</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // that is &gt;= 1, otherwise 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int inf_start = max(1, (index + seeding_time - max_gt));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // work out where to end the convolution: (current_time - 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int inf_end = (index + seeding_time - 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // number of indices of the generation time to sum over (inf_end - inf_start + 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int pmf_accessed = min(max_gt, index + seeding_time - 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate the elements of the convolution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(new_inf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector generate_infections(vector oR, int uot,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            real gt_mean, real gt_sd, int max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            real[] initial_infections, real[] initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            int pop, int ht) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // time indices and storage</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = num_elements(oR);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int nht = ot - ht;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = ot + uot;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] R = oR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real exp_adj_Rt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] cum_infections = rep_vector(0, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] infectiousness = rep_vector(1e-5, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // generation time pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_gt] gt_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // SD &gt; 0: use discretised gamma</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // SD == 0: use discretised delta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_delta_pmf(max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Initialise infections using daily growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   infections[1] = exp(initial_infections[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (uot &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 2:uot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate cumulative infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (pop) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cum_infections[1] = sum(infections[1:uot]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // iteratively update infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (pop &amp;&amp; s &gt; nht) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht]));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       exp_adj_Rt = exp_adj_Rt &gt; 1 ? 1 : exp_adj_Rt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s + uot] += R[s] * infectiousness[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (pop &amp;&amp; s &lt; ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // backcalculate infections using mean shifted cases and non-parametric noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              int prior) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(shifted_cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if(!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[t] exp_noise = exp(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (prior == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections = infections + shifted_cases .* exp_noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else if (prior == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      infections = infections + exp_noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else if (prior == 2) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 2:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         infections[i] = infections[i - 1] * exp_noise[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = infections + shifted_cases;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Update the log density for the generation time distribution mean and sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_mean_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // apply day of the week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int wl = num_elements(effect);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // scale day of week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[wl] scaled_effect = wl * effect;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] scaled_reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // add reporting effects (adjust for simplex scale)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(scaled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Scale observations by fraction reported and update log density of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // fraction reported</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector scale_obs(vector reports, real frac_obs) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] scaled_reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   scaled_reports = reports * frac_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(scaled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Calculate a truncation CMF</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int  trunc_indexes[trunc_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[trunc_max] cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = discretised_lognormal_pmf(trunc_mean, trunc_sd, trunc_max, 0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf[1] = cmf[1] + 1e-8;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = cumulative_sum(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = reverse_mf(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Truncate observed data by some truncation distribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector truncate(vector reports, real truncation_mean, real truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 int truncation_max, int reconstruct) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] trunc_reports = reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Calculate cmf of truncation delay</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int trunc_max = truncation_max &gt; t ? t : truncation_max;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[trunc_max] cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int first_t = t - trunc_max + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   cmf = truncation_cmf(truncation_mean, truncation_sd, trunc_max);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Apply cdf of truncation delay to truncation max last entries in reports</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (reconstruct) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(trunc_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Truncation distribution priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void truncation_lp(real[] truncation_mean, real[] truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    real[] trunc_mean_mean, real[] trunc_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    real[] trunc_sd_mean, real[] trunc_sd_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation = num_elements(truncation_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (truncation) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update log density for reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void report_lp(int[] cases, vector reports,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                real[] rep_phi, real phi_mean, real phi_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                int model_type, real weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // the reciprocal overdispersion parameter (phi)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // defer to poisson if phi is large, to avoid overflow or</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // if poisson specified</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (weight == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases ~ poisson(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += poisson_lpmf(cases | reports) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (weight == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases ~ neg_binomial_2(reports, sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update log likelihood (as above but not vectorised and returning log likelihood)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector report_log_lik(int[] cases, vector reports,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       real[] rep_phi, int model_type, real weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // the reciprocal overdispersion parameter (phi)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // defer to poisson if phi is large, to avoid overflow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(log_lik);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // sample reported cases from the observation model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> int[] report_rng(vector reports, real[] rep_phi, int model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int sampled_reports[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // defer to poisson if phi is large, to avoid overflow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(sampled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // calculate Rt directly from inferred infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector calculate_Rt(vector infections, int seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     real gt_mean, real gt_sd, int max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     int smooth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_gt] gt_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = t - seeding_time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] sR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] infectiousness = rep_vector(1e-5, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate PMF of the generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_delta_pmf(max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   gt_pmf = reverse_mf(gt_pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate Rt using Cori et al. approach</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infectiousness[s] += update_infectiousness(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections, gt_pmf, seeding_time, max_gt, s</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     R[s] = infections[s + seeding_time] / infectiousness[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (smooth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       real window = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sR[s] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in max(1, s - smooth):min(ot, s + smooth)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         sR[s] += R[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         window += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sR[s] = sR[s] / window;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sR = R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(sR);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Convert an estimate of Rt to growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real[] R_to_growth(vector R, real gt_mean, real gt_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real k = pow(gt_sd / gt_mean, 2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // limit as gt_sd -&gt; 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       r[s] = log(R[s]) / gt_mean;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(r);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t;                                            // unobserved time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int seeding_time;                                 // time period used for seeding and not observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int horizon;                                      // forecast horizon</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int future_time;                                  // time in future for Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower = 0&gt;[t] shifted_cases;               // prior infections (for backcalculation)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int delays;                  // no. of delay distributions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean_sd[delays];  // prior sd of mean incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean_mean[delays];// prior mean of mean incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_sd_mean[delays];  // prior sd of sd of incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_sd_sd[delays];    // prior sd of sd of incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_delay[delays];       // maximum incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real L;				                     // boundary value for infections gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; M;			               // basis functions for infections gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real ls_meanlog;                   // meanlog for gp lengthscale prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real ls_sdlog;                     // sdlog for gp lengthscale prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; ls_min;              // Lower bound for the lengthscale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; ls_max;              // Upper bound for the lengthscale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int stationary;                    // is underlying gaussian process first or second order</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int fixed;                         //  should a gaussian process be used</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_mean_sd;                   // prior sd of mean generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_mean_mean;                 // prior mean of mean generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_sd_mean;                   // prior mean of sd of generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_sd_sd;                     // prior sd of sd of generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_gt;                        // maximum generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int estimate_r;                    // should the reproduction no be estimated (1 = yes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real prior_infections;             // prior for initial infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real prior_growth;                 // prior on initial growth rate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_n;                          // no of breakpoints (0 = no breakpoints)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int breakpoints[t - seeding_time]; // when do breakpoints occur</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int future_fixed;                  // is underlying future Rt assumed to be fixed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int fixed_from;                    // Reference date for when Rt estimation should be fixed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int pop;                           // Initial susceptible population</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int backcalc_prior;                // Prior type to use for backcalculation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int rt_half_window;                // Half the moving average window used when calculating Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real phi_mean;                      // Mean and sd of the normal prior for the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real phi_sd;                        // reporting process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int week_effect;                   // length of week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation;                    // 1/0 indicating if truncation should be adjusted for</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_mean_mean[truncation];  // truncation mean of mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_mean_sd[truncation];    // truncation sd of mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_sd_mean[truncation];    // truncation mean of sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_sd_sd[truncation];      // truncation sd of sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_truncation[truncation];    // maximum truncation supported</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int obs_scale;                     // logical controlling scaling of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_scale_mean;               // mean scaling factor for observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_scale_sd;                 // standard deviation of observation scaling</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_weight;                   // weight given to observation in log density</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int likelihood;                    // Should the likelihood be included in the model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int return_likelihood; // Should the likehood be returned by the model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = t - seeding_time - horizon;  // observed time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot_h = ot + horizon;  // observed time + forecast horizon</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = ls_min,upper=ls_max&gt; rho[fixed ? 0 : 1];  // length scale of noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];    // scale of of noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[fixed ? 0 : M] eta;               // unconstrained noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real initial_infections[estimate_r] ;    // seed infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real initial_growth[estimate_r &amp;&amp; seeding_time &gt; 1 ? 1 : 0]; // seed growth rate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0, upper = max_gt&gt; gt_mean[estimate_r &amp;&amp; gt_mean_sd &gt; 0]; // mean of generation time (if uncertain)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; gt_sd[estimate_r &amp;&amp; gt_sd_sd &gt; 0];       // sd of generation time (if uncertain)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; bp_sd[bp_n &gt; 0 ? 1 : 0]; // standard deviation of breakpoint effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real bp_effects[bp_n];                   // Rt breakpoint effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observation model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean[delays];                 // mean of delays</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; delay_sd[delays];        // sd of delays</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; frac_obs[obs_scale];     // fraction of cases that are ultimately observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real truncation_mean[truncation];        // mean of truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; truncation_sd[truncation]; // sd of truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; rep_phi[model_type];     // overdispersion of the reporting process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower = 0, upper = 10 * r_mean&gt;[estimate_r &gt; 0 ? ot_h : 0] R; // reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections;                                     // latent infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot_h] reports;                                     // estimated reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] obs_reports;                                   // observed estimated reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // GP in noise - spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Estimate latent infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // via Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_mean = (gt_mean_sd &gt; 0 ? gt_mean[1] : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_sd = (gt_sd_sd &gt; 0 ? gt_sd[1] : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     R = update_Rt(ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      initial_infections, initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      pop, future_time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // via deconvolution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // convolve from latent infections to mean of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  // weekly reporting effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (week_effect &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // scaling of reported cases by fraction observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (obs_scale) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reports = scale_obs(reports, frac_obs[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  // truncate near time cases to observed reports</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (truncation) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    obs_reports = truncate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports[1:ot], truncation_mean[1], truncation_sd[1], max_truncation[1], 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    obs_reports = reports[1:ot];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gaussian_process_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // penalised priors for delay distributions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   delays_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     delay_sd_sd, t</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   truncation_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_sd_mean, trunc_sd_sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // priors on Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rt_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // penalised_prior on generation interval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     generation_time_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior observation scaling</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (obs_scale) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observed reports from mean of reports (update likelihood)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (likelihood) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     report_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int imputed_reports[ot_h];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r[ot_h];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[return_likelihood ? ot : 0] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // estimate growth from estimated Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_mean = (gt_mean_sd &gt; 0 ? gt_mean[1] : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_sd = (gt_sd_sd &gt; 0 ? gt_sd[1] : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     r = R_to_growth(R, set_gt_mean, set_gt_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // sample generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real gt_mean_sample = (gt_mean_sd &gt; 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real gt_sd_sample = (gt_sd_sd &gt; 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // calculate Rt using infections and generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gen_R = calculate_Rt(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections, seeding_time, gt_mean_sample, gt_sd_sample, max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       rt_half_window</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // estimate growth from calculated Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // simulate reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   imputed_reports = report_rng(reports, rep_phi, model_type);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // log likelihood of model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (return_likelihood) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     log_lik = report_log_lik(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases, obs_reports, rep_phi, model_type, obs_weight</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> } </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $method</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "sampling"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $cores</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $warmup</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 250</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $chains</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $save_warmup</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $seed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 58321445</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $future</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $max_execution_time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] Inf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control$adapt_delta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 0.95</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $control$max_treedepth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 15</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $iter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 500</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $return_fit</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># using vb</span></span></span>
<span class="r-in"><span><span class="fu">stan_opts</span><span class="op">(</span>method <span class="op">=</span> <span class="st">"vb"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $object</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> S4 class stanmodel 'estimate_infections' coded as follows:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated gamma pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_gamma_pmf(real mu, real sigma, int max_val) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = max_val;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n+1] upper_cdf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate alpha and beta for gamma distribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real small = 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real large = 1e8;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_sigma = fmax(small, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real c_mu = fmax(small, mu);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real alpha = ((c_mu) / c_sigma)^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real beta = (c_mu) / (c_sigma^2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // account for numerical issues</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha = fmax(small, alpha);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha = fmin(large, alpha);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   beta = fmax(small, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   beta = fmin(large, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:(n+1)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     upper_cdf[i] = gamma_cdf(i,  alpha, beta);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // discretise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[n+1-i] = upper_cdf[i+1] - upper_cdf[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pmf = pmf / (upper_cdf[n+1] - upper_cdf[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated lognormal pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_lognormal_pmf(real mu, real sigma, int max_val, int rev) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int n = max_val;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] upper_cdf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     upper_cdf[i] = lognormal_cdf(i,  mu, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // discretise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (rev) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[n] = upper_cdf[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 2:n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       pmf[n+1-i] = upper_cdf[i] - upper_cdf[i-1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[1] = upper_cdf[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pmf[2:n] = upper_cdf[2:n] - upper_cdf[1:(n-1)];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // normalize</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pmf = pmf / upper_cdf[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // reverse a mf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector reverse_mf(vector pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_pmf = num_elements(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_pmf] rev_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (d in 1:max_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rev_pmf[d] = pmf[max_pmf - d + 1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return rev_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // discretised truncated gamma pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector discretised_delta_pmf(int n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] pmf = rep_vector(0, n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pmf[n] = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // convolve a pdf and case vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector convolve(vector cases, vector rev_pmf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int t = num_elements(cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int max_pmf = num_elements(rev_pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[t] conv_cases = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      tail(rev_pmf, min(max_pmf, s)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    return(conv_cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // convolve latent infections to reported (but still unobserved) cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector convolve_to_report(vector infections,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           real[] delay_mean,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           real[] delay_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           int[] max_delay,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                           int seeding_time) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t - seeding_time] reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] unobs_reports = infections;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int delays = num_elements(delay_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       vector[max_delay[s]] pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       pmf = discretised_lognormal_pmf(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         delay_mean[s], delay_sd[s], max_delay[s], 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       unobs_reports = convolve(unobs_reports, pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports = unobs_reports[(seeding_time + 1):t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports = infections[(seeding_time + 1):t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int delays = num_elements(delay_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (s in 1:delays) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // eigenvalues for approximate hilbert space gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // see here for details: https://arxiv.org/pdf/2004.11408.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real lambda(real L, int m) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lam;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lam = ((m*pi())/(2*L))^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return lam;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // eigenfunction for approximate hilbert space gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // see here for details: https://arxiv.org/pdf/2004.11408.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector phi(real L, int m, vector x) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[rows(x)] fi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return fi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // spectral density of the exponential quadratic kernal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real spd_se(real alpha, real rho, real w) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // spectral density of the Matern 3/2 kernel</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real spd_matern(real alpha, real rho, real w) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return S;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // setup gaussian process noise dimensions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> int setup_noise(int ot_h, int t, int horizon, int estimate_r,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 int stationary, int future_fixed, int fixed_from) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(noise_terms);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // setup approximate gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> matrix setup_gp(int M, real L, int dimension) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[dimension] time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[dimension, M] PHI;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real half_dim = dimension / 2.0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:dimension) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     time[s] = (s - half_dim) / half_dim;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     PHI[,m] = phi(L, m, time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(PHI);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update gaussian process using spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector update_gp(matrix PHI, int M, real L, real alpha,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                  real rho, vector eta, int type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] diagSPD;    // spectral density</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] SPD_eta;    // spectral density * noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms = rows(PHI);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real unit_rho = rho / noise_terms;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // GP in noise - spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (type == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for(m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m))));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else if (type == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for(m in 1:M){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m))));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   SPD_eta = diagSPD .* eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   noise = noise + PHI[,] * SPD_eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // priors for gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void gaussian_process_lp(real rho, real alpha, vector eta,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          real ls_meanlog, real ls_sdlog,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          real ls_min, real ls_max, real alpha_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (ls_sdlog &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   alpha ~ normal(0, alpha_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update a vector of Rts</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector update_Rt(int t, real log_R, vector noise, int[] bps,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                  real[] bp_effects, int stationary) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // define control parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_n = num_elements(bp_effects);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_c = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gp_n = num_elements(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // define result vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] bp = rep_vector(0, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] gp = rep_vector(0, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // initialise breakpoints</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (bp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (bps[s]) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bp_c += bps[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bp[s] = bp_effects[bp_c];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp = cumulative_sum(bp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //initialise gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (stationary) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp[1:gp_n] = noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // fix future gp based on last estimated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (t &gt; gp_n) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp[2:(gp_n + 1)] = noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gp = cumulative_sum(gp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Calculate Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   R = rep_vector(log_R, t) + bp + gp;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   R = exp(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Rt priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real r_logmean, real r_logsd, real prior_infections,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            real prior_growth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior on R</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   log_R ~ normal(r_logmean, r_logsd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //breakpoint effects on Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (bp_n &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp_sd[1] ~ normal(0, 0.1) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     bp_effects ~ normal(0, bp_sd[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // initial infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   initial_infections ~ normal(prior_infections, 0.2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (seeding_time &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     initial_growth ~ normal(prior_growth, 0.2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // calculate infectiousness (weighted sum of the generation time and infections)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // for a single time point</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real update_infectiousness(vector infections, vector gt_pmf,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            int seeding_time, int max_gt, int index){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // work out where to start the convolution of past infections with the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // generation time distribution: (current_time - maximal generation time) if</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // that is &gt;= 1, otherwise 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int inf_start = max(1, (index + seeding_time - max_gt));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // work out where to end the convolution: (current_time - 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int inf_end = (index + seeding_time - 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // number of indices of the generation time to sum over (inf_end - inf_start + 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int pmf_accessed = min(max_gt, index + seeding_time - 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate the elements of the convolution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(new_inf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector generate_infections(vector oR, int uot,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            real gt_mean, real gt_sd, int max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            real[] initial_infections, real[] initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                            int pop, int ht) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // time indices and storage</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = num_elements(oR);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int nht = ot - ht;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = ot + uot;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] R = oR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real exp_adj_Rt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] cum_infections = rep_vector(0, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] infectiousness = rep_vector(1e-5, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // generation time pmf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_gt] gt_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // SD &gt; 0: use discretised gamma</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // SD == 0: use discretised delta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_delta_pmf(max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Initialise infections using daily growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   infections[1] = exp(initial_infections[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (uot &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 2:uot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate cumulative infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (pop) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cum_infections[1] = sum(infections[1:uot]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // iteratively update infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (pop &amp;&amp; s &gt; nht) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht]));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       exp_adj_Rt = exp_adj_Rt &gt; 1 ? 1 : exp_adj_Rt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[s + uot] += R[s] * infectiousness[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (pop &amp;&amp; s &lt; ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // backcalculate infections using mean shifted cases and non-parametric noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              int prior) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(shifted_cases);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections = rep_vector(1e-5, t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if(!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[t] exp_noise = exp(noise);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (prior == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections = infections + shifted_cases .* exp_noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else if (prior == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      infections = infections + exp_noise;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else if (prior == 2) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 2:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         infections[i] = infections[i - 1] * exp_noise[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = infections + shifted_cases;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Update the log density for the generation time distribution mean and sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_mean_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // apply day of the week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int wl = num_elements(effect);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // scale day of week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[wl] scaled_effect = wl * effect;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] scaled_reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // add reporting effects (adjust for simplex scale)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(scaled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Scale observations by fraction reported and update log density of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // fraction reported</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector scale_obs(vector reports, real frac_obs) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] scaled_reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   scaled_reports = reports * frac_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(scaled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Calculate a truncation CMF</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int  trunc_indexes[trunc_max];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[trunc_max] cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = discretised_lognormal_pmf(trunc_mean, trunc_sd, trunc_max, 0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf[1] = cmf[1] + 1e-8;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = cumulative_sum(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cmf = reverse_mf(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return(cmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Truncate observed data by some truncation distribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector truncate(vector reports, real truncation_mean, real truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 int truncation_max, int reconstruct) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] trunc_reports = reports;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Calculate cmf of truncation delay</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int trunc_max = truncation_max &gt; t ? t : truncation_max;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[trunc_max] cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int first_t = t - trunc_max + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   cmf = truncation_cmf(truncation_mean, truncation_sd, trunc_max);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Apply cdf of truncation delay to truncation max last entries in reports</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (reconstruct) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(trunc_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Truncation distribution priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void truncation_lp(real[] truncation_mean, real[] truncation_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    real[] trunc_mean_mean, real[] trunc_mean_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    real[] trunc_sd_mean, real[] trunc_sd_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation = num_elements(truncation_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (truncation) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update log density for reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void report_lp(int[] cases, vector reports,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                real[] rep_phi, real phi_mean, real phi_sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                int model_type, real weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // the reciprocal overdispersion parameter (phi)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // defer to poisson if phi is large, to avoid overflow or</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // if poisson specified</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (weight == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases ~ poisson(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += poisson_lpmf(cases | reports) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (weight == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases ~ neg_binomial_2(reports, sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // update log likelihood (as above but not vectorised and returning log likelihood)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector report_log_lik(int[] cases, vector reports,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       real[] rep_phi, int model_type, real weight) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // the reciprocal overdispersion parameter (phi)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // defer to poisson if phi is large, to avoid overflow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(log_lik);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // sample reported cases from the observation model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> int[] report_rng(vector reports, real[] rep_phi, int model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int sampled_reports[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real sqrt_phi = 1e5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (model_type) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sqrt_phi = 1 / sqrt(rep_phi[model_type]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // defer to poisson if phi is large, to avoid overflow</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (sqrt_phi &gt; 1e4) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], sqrt_phi);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(sampled_reports);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // calculate Rt directly from inferred infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vector calculate_Rt(vector infections, int seeding_time,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     real gt_mean, real gt_sd, int max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     int smooth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[max_gt] gt_pmf;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(infections);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = t - seeding_time;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] sR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] infectiousness = rep_vector(1e-5, ot);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate PMF of the generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gt_pmf = discretised_delta_pmf(max_gt);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   gt_pmf = reverse_mf(gt_pmf);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate Rt using Cori et al. approach</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infectiousness[s] += update_infectiousness(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections, gt_pmf, seeding_time, max_gt, s</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     R[s] = infections[s + seeding_time] / infectiousness[s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (smooth) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:ot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       real window = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sR[s] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in max(1, s - smooth):min(ot, s + smooth)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         sR[s] += R[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         window += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       sR[s] = sR[s] / window;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sR = R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(sR);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Convert an estimate of Rt to growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> real[] R_to_growth(vector R, real gt_mean, real gt_sd) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t = num_elements(R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (gt_sd &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real k = pow(gt_sd / gt_mean, 2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // limit as gt_sd -&gt; 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (s in 1:t) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       r[s] = log(R[s]) / gt_mean;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   return(r);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int t;                                            // unobserved time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int seeding_time;                                 // time period used for seeding and not observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int horizon;                                      // forecast horizon</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int future_time;                                  // time in future for Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower = 0&gt;[t] shifted_cases;               // prior infections (for backcalculation)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int delays;                  // no. of delay distributions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean_sd[delays];  // prior sd of mean incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean_mean[delays];// prior mean of mean incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_sd_mean[delays];  // prior sd of sd of incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_sd_sd[delays];    // prior sd of sd of incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_delay[delays];       // maximum incubation period</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real L;				                     // boundary value for infections gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; M;			               // basis functions for infections gp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real ls_meanlog;                   // meanlog for gp lengthscale prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real ls_sdlog;                     // sdlog for gp lengthscale prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; ls_min;              // Lower bound for the lengthscale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; ls_max;              // Upper bound for the lengthscale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int stationary;                    // is underlying gaussian process first or second order</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int fixed;                         //  should a gaussian process be used</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_mean_sd;                   // prior sd of mean generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_mean_mean;                 // prior mean of mean generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_sd_mean;                   // prior mean of sd of generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real gt_sd_sd;                     // prior sd of sd of generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_gt;                        // maximum generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int estimate_r;                    // should the reproduction no be estimated (1 = yes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real prior_infections;             // prior for initial infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real prior_growth;                 // prior on initial growth rate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int bp_n;                          // no of breakpoints (0 = no breakpoints)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int breakpoints[t - seeding_time]; // when do breakpoints occur</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int future_fixed;                  // is underlying future Rt assumed to be fixed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int fixed_from;                    // Reference date for when Rt estimation should be fixed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int pop;                           // Initial susceptible population</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int backcalc_prior;                // Prior type to use for backcalculation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int rt_half_window;                // Half the moving average window used when calculating Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real phi_mean;                      // Mean and sd of the normal prior for the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real phi_sd;                        // reporting process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int week_effect;                   // length of week effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int truncation;                    // 1/0 indicating if truncation should be adjusted for</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_mean_mean[truncation];  // truncation mean of mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_mean_sd[truncation];    // truncation sd of mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_sd_mean[truncation];    // truncation mean of sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real trunc_sd_sd[truncation];      // truncation sd of sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int max_truncation[truncation];    // maximum truncation supported</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int obs_scale;                     // logical controlling scaling of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_scale_mean;               // mean scaling factor for observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_scale_sd;                 // standard deviation of observation scaling</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real obs_weight;                   // weight given to observation in log density</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int likelihood;                    // Should the likelihood be included in the model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int return_likelihood; // Should the likehood be returned by the model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot = t - seeding_time - horizon;  // observed time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int ot_h = ot + horizon;  // observed time + forecast horizon</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = ls_min,upper=ls_max&gt; rho[fixed ? 0 : 1];  // length scale of noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];    // scale of of noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[fixed ? 0 : M] eta;               // unconstrained noise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real initial_infections[estimate_r] ;    // seed infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real initial_growth[estimate_r &amp;&amp; seeding_time &gt; 1 ? 1 : 0]; // seed growth rate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0, upper = max_gt&gt; gt_mean[estimate_r &amp;&amp; gt_mean_sd &gt; 0]; // mean of generation time (if uncertain)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; gt_sd[estimate_r &amp;&amp; gt_sd_sd &gt; 0];       // sd of generation time (if uncertain)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; bp_sd[bp_n &gt; 0 ? 1 : 0]; // standard deviation of breakpoint effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real bp_effects[bp_n];                   // Rt breakpoint effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observation model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real delay_mean[delays];                 // mean of delays</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; delay_sd[delays];        // sd of delays</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; frac_obs[obs_scale];     // fraction of cases that are ultimately observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real truncation_mean[truncation];        // mean of truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; truncation_sd[truncation]; // sd of truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower = 0&gt; rep_phi[model_type];     // overdispersion of the reporting process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower = 0, upper = 10 * r_mean&gt;[estimate_r &gt; 0 ? ot_h : 0] R; // reproduction number</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[t] infections;                                     // latent infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot_h] reports;                                     // estimated reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[ot] obs_reports;                                   // observed estimated reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // GP in noise - spectral densities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Estimate latent infections</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // via Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_mean = (gt_mean_sd &gt; 0 ? gt_mean[1] : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_sd = (gt_sd_sd &gt; 0 ? gt_sd[1] : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     R = update_Rt(ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      initial_infections, initial_growth,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      pop, future_time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // via deconvolution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // convolve from latent infections to mean of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  // weekly reporting effect</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (week_effect &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // scaling of reported cases by fraction observed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (obs_scale) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reports = scale_obs(reports, frac_obs[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  // truncate near time cases to observed reports</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  if (truncation) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    obs_reports = truncate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     reports[1:ot], truncation_mean[1], truncation_sd[1], max_truncation[1], 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    obs_reports = reports[1:ot];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for noise GP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!fixed) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gaussian_process_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // penalised priors for delay distributions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   delays_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     delay_sd_sd, t</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for truncation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   truncation_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trunc_sd_mean, trunc_sd_sd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // priors on Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rt_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // penalised_prior on generation interval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     generation_time_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior observation scaling</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (obs_scale) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // observed reports from mean of reports (update likelihood)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (likelihood) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     report_lp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int imputed_reports[ot_h];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real r[ot_h];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[return_likelihood ? ot : 0] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (estimate_r){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // estimate growth from estimated Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_mean = (gt_mean_sd &gt; 0 ? gt_mean[1] : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real set_gt_sd = (gt_sd_sd &gt; 0 ? gt_sd[1] : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     r = R_to_growth(R, set_gt_mean, set_gt_sd);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }else{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // sample generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real gt_mean_sample = (gt_mean_sd &gt; 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     real gt_sd_sample = (gt_sd_sd &gt; 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // calculate Rt using infections and generation time</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gen_R = calculate_Rt(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       infections, seeding_time, gt_mean_sample, gt_sd_sample, max_gt,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       rt_half_window</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // estimate growth from calculated Rt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // simulate reported cases</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   imputed_reports = report_rng(reports, rep_phi, model_type);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // log likelihood of model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (return_likelihood) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     log_lik = report_log_lik(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       cases, obs_reports, rep_phi, model_type, obs_weight</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> } </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $method</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "vb"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $trials</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 10</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $iter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 10000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $output_samples</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 2000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $return_fit</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by <a href="https://www.samabbott.co.uk/" class="external-link">Sam Abbott</a>, Joel Hellewell, Katharine Sherratt, Katelyn Gostic, Joe Hickson, Hamada S. Badr, Michael DeWitt, EpiForecasts, <a href="https://www.lshtm.ac.uk/aboutus/people/funk.sebastian" class="external-link">Sebastian Funk</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.6.9000.</p>
</div>

    </footer></div>

  

  

  </body></html>

