[{"path":[]},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement [INSERT CONTACT METHOD]. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https:// www.contributor-covenant.org/translations.","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to EpiNow2","title":"Contributing to EpiNow2","text":"outlines propose change EpiNow2.","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to EpiNow2","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to EpiNow2","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to EpiNow2","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"epiforecasts/EpiNow2\", fork = TRUE). Install development dependences devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). use pre-commit check changes match package standards. optional can enabled using following steps. Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":"# if python is not installed on your system install.packages(\"reticulate\") reticulate::install_miniconda() # install precommit if not already installed precommit::install_precommit() # set up precommit for use precommit::use_precommit()"},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to EpiNow2","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to EpiNow2","text":"Please note EpiNow2 project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"epiforecasts.io/EpiNow2/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 EpiForecasts Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/case-studies.html","id":"case-studies","dir":"Articles","previous_headings":"","what":"Case studies","title":"External case studies and use in the literature","text":"Estimating reporting delays nowcasting/forecasting infections EpiNow2 Sebastian Funk Sam Abbott. Forecast Covid-19 reported deaths Covid-19 reported cases (observed forecast) country ECDC Sam Abbott. Explore Covid-19 data truncation England Sam Abbott. Estimate effective reproduction number Covid-19 last 3 months country Sam Abbott.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/case-studies.html","id":"public-health-surveillance","dir":"Articles","previous_headings":"","what":"Public health surveillance","title":"External case studies and use in the literature","text":"CDC. 2022. “Technical Report 3: Multi-National Monkeypox Outbreak, United States, 2022.” Centers Disease Control Prevention. October 3, 2022. https://www.cdc.gov/poxvirus/monkeypox/cases-data/technical-report/report-3.html.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/articles/case-studies.html","id":"by-package-authors","dir":"Articles","previous_headings":"Literature","what":"By package authors","title":"External case studies and use in the literature","text":"Abbott, Sam, Joel Hellewell, Robin N. Thompson, Katharine Sherratt, Hamish P. Gibbs, Nikos . Bosse, James D. Munday, et al. 2020. “Estimating Time-Varying Reproduction Number SARS-CoV-2 Using National Subnational Case Counts.” Wellcome Open Research 5 (December): 112. http://dx.doi.org/10.12688/wellcomeopenres.16006.2 Sherratt, Katharine, Sam Abbott, Sophie R. Meakin, Joel Hellewell, James D. Munday, Nikos Bosse, Null Null, Mark Jit, Sebastian Funk. 2021. “Exploring Surveillance Data Biases Estimating Reproduction Number: Insights Subpopulation Transmission COVID-19 England.” Philosophical Transactions Royal Society London. Series B, Biological Sciences 376 (1829): 20200283. http://dx.doi.org/10.1098/rstb.2020.0283 Bosse, Nikos ., Sam Abbott, Johannes Bracher, Habakuk Hain, Billy J. Quilty, Mark Jit, Centre Mathematical Modelling Infectious Diseases COVID-19 Working Group, Edwin van Leeuwen, Anne Cori, Sebastian Funk. 2022. “Comparing Human Model-Based Forecasts COVID-19 Germany Poland.” PLoS Computational Biology 18 (9): e1010405. http://dx.doi.org/10.1371/journal.pcbi.1010405 Davies, Nicholas G., Sam Abbott, Rosanna C. Barnard, Christopher . Jarvis, Adam J. Kucharski, James D. Munday, Carl . B. Pearson, et al. 2021. “Estimated Transmissibility Impact SARS-CoV-2 Lineage B.1.1.7 England.” Science 372 (6538). https://doi.org/10.1126/science.abg3055. Meakin, Sophie, Sam Abbott, Nikos Bosse, James Munday, Hugo Gruson, Joel Hellewell, Katharine Sherratt, CMMID COVID-19 Working Group, Sebastian Funk. 2022. “Comparative Assessment Methods Short-Term Forecasts COVID-19 Hospital Admissions England Local Level.” BMC Medicine 20 (1): 86. http://dx.doi.org/10.1186/s12916-022-02271-x","code":""},{"path":"epiforecasts.io/EpiNow2/articles/case-studies.html","id":"by-others","dir":"Articles","previous_headings":"Literature","what":"By others","title":"External case studies and use in the literature","text":"Hay, James ., Lee Kennedy-Shaffer, Sanjat Kanjilal, Niall J. Lennon, Stacey B. Gabriel, Marc Lipsitch, Michael J. Mina. 2021. “Estimating Epidemiologic Dynamics Cross-Sectional Viral Load Distributions.” Science 373 (6552). https://doi.org/10.1126/science.abh0635.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/estimate_infections.html","id":"renewal-equation-model","dir":"Articles","previous_headings":"","what":"Renewal equation model","title":"Model definition: estimate_infections()","text":"default model used rt != NULL.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/estimate_infections.html","id":"initialisation","dir":"Articles","previous_headings":"Renewal equation model","what":"Initialisation","title":"Model definition: estimate_infections()","text":"model initialised prior first observed data point assuming constant exponential growth mean assumed delays infection case report. \\[\\begin{align}   I_{t} &= I_0 \\exp  \\left(r t \\right)  \\\\   I_0 &\\sim \\mathcal{LN}(\\log I_{obs}, 0.2) \\\\   r &\\sim \\mathcal{LN}(r_{obs}, 0.2) \\end{align}\\]","code":""},{"path":"epiforecasts.io/EpiNow2/articles/estimate_infections.html","id":"within-the-range-of-observations","dir":"Articles","previous_headings":"Renewal equation model","what":"Within the range of observations","title":"Model definition: estimate_infections()","text":"\\(I_{obs}\\) \\(r_{obs}\\) estimated first week observed data. time window observed data infections modelled weighting previous infections generation time scaling instantaneous reproduction number. infections convolved cases onset date (\\(O_t\\)) cases date report (\\(D_t\\)) using log-normal delay distributions (though arbitrary delay distributions can used common formulation). model can defined mathematically follows, \\[\\begin{align}   \\log R_{t} &= \\log R_{t-1} + \\mathrm{GP}_t \\\\   I_t &= R_t \\sum_{\\tau = 1}^{T_I} w(\\tau | \\mu_{w}, \\sigma_{w}) I_{t - \\tau} \\\\   O_t &= \\sum_{\\tau = 0}^{T_O} \\xi_{O}(\\tau | \\mu_{\\xi_{O}}, \\sigma_{\\xi_{O}}) I_{t-\\tau} \\\\   D_t &= \\alpha \\sum_{\\tau = 0}^{T_D} \\xi_{D}(\\tau | \\mu_{\\xi_{D}}, \\sigma_{\\xi_{D}}) O_{t-\\tau} \\\\   C_t &\\sim \\mathrm{NB}\\left(\\omega_{(t \\mod 7)}D_t, \\phi\\right) \\end{align}\\] \\(T_I\\) maximum generation time, \\(T_O\\) maximum delay infection case onset, \\(T_D\\) maximum delay case onset report, \\(\\alpha\\) proportion cases ultimately reported (note optional arbitrary). delay distributions defined follows, \\[\\begin{align}      w &\\sim \\mathcal{Gamma}(\\mu_{w}, \\sigma_{w}) \\\\     \\xi_{O} &\\sim \\mathcal{LogNormal}(\\mu_{\\xi_{O}}, \\sigma_{\\xi_{O}}) \\\\     \\xi_{D} &\\sim \\mathcal{LogNormal}(\\mu_{\\xi_{D}}, \\sigma_{\\xi_{D}}) \\end{align}\\] model used following priors observation model \\[\\begin{align}     \\frac{\\omega}{7} &\\sim \\mathrm{Dirichlet}(1, 1, 1, 1, 1, 1, 1) \\\\     \\phi &\\sim \\frac{1}{\\sqrt{\\mathcal{N}(0, 1)}} \\end{align}\\] \\(\\phi\\) truncated greater 0 \\(\\xi\\), \\(w\\) normalised sum 1. priors set user. \\(GP_t\\) approximate Hilbert space Gaussian process defined [1] using Matern 3/2 kernel default boundary factor 1.5 basis functions scaled 20% number days fitted. length scale Gaussian process given log-normal prior mean 21 days, standard deviation 7 days truncated greater 3 days less length time-series. standard deviation magnitude Gaussian process assumed 0.1. settings changeable user. addition user can opt make use different generative process instead remove dependency previous value \\(R_t\\) options impacts run-time may alter best use-case model.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/estimate_infections.html","id":"beyond-the-forecast-horizon","dir":"Articles","previous_headings":"Renewal equation model","what":"Beyond the forecast horizon","title":"Model definition: estimate_infections()","text":"Beyond forecast horizon (\\(T\\)), default, Gaussian process assumed continue. However, range options. included fixing transmission dynamics, scaling \\(R_t\\) based proportion population remain susceptible. defined followed, \\[\\begin{equation}     I_t = (N - ^c_{t-1}) \\left(1 - \\exp \\left(\\frac{-'_t}{N - ^c_{T}}\\right)\\right), \\end{equation}\\] \\(^c_t = \\sum_{s< t} I_s\\) cumulative infections \\(t-1\\) \\('_t\\) unadjusted infections defined . adjustment based one implemented epidemia R package[2].","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sam Abbott. Author, maintainer. Joel Hellewell. Author. Katharine Sherratt. Author. Katelyn Gostic. Author. Joe Hickson. Author. Hamada S. Badr. Author. Michael DeWitt. Author. Robin Thompson. Contributor. Sophie Meakin. Contributor. James Munday. Contributor. Nikos Bosse. Contributor. Paul Mee. Contributor. Peter Ellis. Contributor. Pietro Monticone. Contributor. Lloyd Chapman. Contributor. EpiForecasts. Author. Sebastian Funk. Author.","code":""},{"path":"epiforecasts.io/EpiNow2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sam Abbott, Joel Hellewell, Katharine Sherratt, Katelyn Gostic,           Joe Hickson, Hamada S. Badr, Michael DeWitt, Robin Thompson, EpiForecasts,          Sebastian Funk (2020). EpiNow2: Estimate Real-Time Case Counts Time-Varying Epidemiological Parameters,  DOI: 10.5281/zenodo.3957489","code":"@Manual{,   title = {EpiNow2: Estimate Real-Time Case Counts and Time-Varying Epidemiological Parameters},   author = {Sam Abbott and Joel Hellewell and Katharine Sherratt and Katelyn Gostic and Joe Hickson and Hamada S. Badr and Michael DeWitt and Robin Thompson and {EpiForecasts} and Sebastian Funk},   year = {2020},   doi = {10.5281/zenodo.3957489}, }"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"epinow2-estimate-real-time-case-counts-and-time-varying-epidemiological-parameters","dir":"","previous_headings":"","what":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"package estimates time-varying reproduction number, growth rate, doubling time using range open-source tools (Abbott et al.), current best practices (Gostic et al.). aims help users avoid limitations naive implementations framework informed community feedback actively supported. estimates time-varying reproduction number cases date infection (using similar approach implemented {EpiEstim}). Imputed infections mapped observed data (example cases date report) via series uncertain delay distributions (examples package documentation incubation period reporting delay) reporting model can include weekly periodicity. Uncertainty propagated inputs final parameter estimates, helping mitigate spurious findings. handled internally. time-varying reproduction estimates uncertain generation time also give time-varying estimates rate growth. default model uses non-stationary Gaussian process estimate time-varying reproduction number infer infections. options include: stationary Gaussian process (faster estimate currently gives reduced performance real time estimates). User specified breakpoints. fixed reproduction number. piecewise constant combining fixed reproduction number breakpoints. random walk (combining fixed reproduction number regularly spaced breakpoints (.e weekly)). Inferring infections using deconvolution/back-calculation calculating time-varying reproduction number. Adjustment remaining susceptible population beyond forecast horizon. options generally reduce runtimes cost granularity estimates cost real-time performance. documentation estimate_infections provides examples implementation different options available. Forecasting also supported time-varying reproduction number, infections reported cases using generative process approach used estimation. simple example using package estimate national Rt Covid-19 can found . EpiNow2 also supports adjustment truncated data via estimate_truncation() (though users may interested flexibility check epinowcast package), estimating dependent observations (.e deaths based hospital admissions) using estimate_secondary().","code":""},{"path":"epiforecasts.io/EpiNow2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"Install stable version package: Install stable development version package : Install unstable development version package (users need ): Windows users need working installation Rtools order build package source. See guide installing Rtools use Stan (statistical modelling platform used underlying model). simple deployment/development prebuilt docker image also available (see documentation ).","code":"install.packages(\"EpiNow2\") install.packages(\"EpiNow2\", repos = \"https://epiforecasts.r-universe.dev\") remotes::install_github(\"epiforecasts/EpiNow2\")"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"EpiNow2 designed used single function call used ad-hoc fashion via individual function calls. core functions EpiNow2 two single-call functions epinow(), regional_epinow(), plus functions estimate_infections(), estimate_secondary() estimate_truncation(). following section give overview simple use case epinow regional_epinow. estimate_infections() can used infer underlying infection case curve reported cases estimate Rt. Estimating underlying infection case curve via back-calculation (calculating Rt) substantially less computationally demanding generating using default settings may result less reliable estimates Rt. details using function see function documentation. first step using package load follows.","code":"library(EpiNow2)"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"reporting-delays-incubation-period-and-generation-time","dir":"","previous_headings":"Quick start","what":"Reporting delays, incubation period and generation time","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"Distributions can either fitted using package functionality determined elsewhere defined uncertainty use EpiNow2. data supplied subsampled bootstrapped lognormal fit (account uncertainty observed data without biased changes incidence). arbitrary number delay distributions supported common use case likely incubation period followed reporting delay. example data delay onset infection available fit distribution appropriate uncertainty follows (note synthetic example), data available instead make informed estimate likely delay (synthetic example applicable real world use cases included uncertainty decreased runtimes), define incubation period generation time based literature estimates Covid-19 (see code generates estimates). Note distributions may applicable use case included uncertainty reduce runtime example settings recommended.","code":"reporting_delay <- estimate_delay(   rlnorm(1000, log(2), 1),   max_value = 15, bootstraps = 1 ) reporting_delay <- list(   mean = convert_to_logmean(2, 1), sd = convert_to_logsd(2, 1), max = 10,   dist = \"lognormal\" ) generation_time <- get_generation_time(   disease = \"SARS-CoV-2\", source = \"ganyani\", max = 10, fixed = TRUE ) incubation_period <- get_incubation_period(   disease = \"SARS-CoV-2\", source = \"lauer\", max = 10, fixed = TRUE )"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"epinow","dir":"","previous_headings":"Quick start","what":"epinow()","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"function represents core functionality package includes results reporting, plotting optional saving. requires data frame cases date report distributions defined . Load example case data EpiNow2. Estimate cases date infection, time-varying reproduction number, rate growth forecast estimates future 7 days. Summarise posterior return summary table plots reporting purposes. target_folder supplied results can internally saved (option also turn explicit returning results). use default model parameterisation prioritises real-time performance run-time considerations. formulations see documentation estimate_infections(). summary measures posterior samples returned parameters easily explored format can accessed using summary. default return summary table estimates key parameters latest date partially supported data. Summarised parameter estimates can also easily returned, either filtered single parameter parameters. Reported cases returned separate data frame order streamline reporting forecasts model evaluation. range plots returned (single summary plot shown ). plots can also generated using following plot method.","code":"reported_cases <- example_confirmed[1:60] head(reported_cases) #>          date confirm #>        <Date>   <num> #> 1: 2020-02-22      14 #> 2: 2020-02-23      62 #> 3: 2020-02-24      53 #> 4: 2020-02-25      97 #> 5: 2020-02-26      93 #> 6: 2020-02-27      78 estimates <- epinow(   reported_cases = reported_cases,   generation_time = generation_time_opts(generation_time),   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.2)),   stan = stan_opts(cores = 4, control = list(adapt_delta = 0.99)),   verbose = interactive() ) #> DEBUG [2023-01-24 20:19:35] epinow: Running in exact mode for 2000 samples (across 4 chains each with a warm up of 250 iterations each) and 74 time steps of which 7 are a forecast names(estimates) #> [1] \"estimates\"                \"estimated_reported_cases\" \"summary\"                  #> [4] \"plots\"                    \"timing\" knitr::kable(summary(estimates)) head(summary(estimates, type = \"parameters\", params = \"R\")) #>          date variable strat     type   median     mean         sd lower_90 lower_50 #>        <Date>   <char> <int>   <char>    <num>    <num>      <num>    <num>    <num> #> 1: 2020-02-22        R    NA estimate 2.148647 2.154214 0.14450153 1.929487 2.051622 #> 2: 2020-02-23        R    NA estimate 2.121512 2.125653 0.12003979 1.931839 2.042736 #> 3: 2020-02-24        R    NA estimate 2.093420 2.095419 0.09974015 1.936182 2.027337 #> 4: 2020-02-25        R    NA estimate 2.061786 2.063610 0.08349157 1.930889 2.007475 #> 5: 2020-02-26        R    NA estimate 2.030095 2.030369 0.07109622 1.915872 1.983404 #> 6: 2020-02-27        R    NA estimate 1.996345 1.995861 0.06219250 1.893969 1.956212 #>    lower_20 upper_20 upper_50 upper_90 #>       <num>    <num>    <num>    <num> #> 1: 2.111131 2.185022 2.253146 2.398995 #> 2: 2.091795 2.154419 2.208429 2.328889 #> 3: 2.067632 2.120660 2.161471 2.260970 #> 4: 2.041539 2.084712 2.119120 2.199715 #> 5: 2.011280 2.048115 2.077987 2.146658 #> 6: 1.980218 2.012074 2.036623 2.097979 head(summary(estimates, output = \"estimated_reported_cases\")) #>          date   type median     mean       sd lower_90 lower_50 lower_20 upper_20 #>        <Date> <char>  <num>    <num>    <num>    <num>    <num>    <num>    <num> #> 1: 2020-02-22  gp_rt     50  51.6335 14.08188       32       41     47.0       54 #> 2: 2020-02-23  gp_rt     69  70.4195 18.02745       44       58     64.0       73 #> 3: 2020-02-24  gp_rt     76  78.0840 19.29451       49       64     72.0       81 #> 4: 2020-02-25  gp_rt     79  79.7110 19.49842       51       66     73.0       83 #> 5: 2020-02-26  gp_rt     84  85.7190 21.08341       54       71     79.0       90 #> 6: 2020-02-27  gp_rt    119 121.6290 29.19472       77      101    112.6      127 #>    upper_50 upper_90 #>       <num>    <num> #> 1:       60    77.00 #> 2:       81   103.00 #> 3:       89   112.00 #> 4:       92   114.00 #> 5:       98   123.05 #> 6:      140   173.00 plot(estimates)"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"regional_epinow","dir":"","previous_headings":"Quick start","what":"regional_epinow()","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"regional_epinow() function runs epinow() function across multiple regions efficient manner. Define cases multiple regions delineated region variable. Calling regional_epinow() runs epinow() region turn (parallel depending settings used). switch using weekly random walk rather full Gaussian process model giving us piecewise constant estimates week. Results region stored regional list across region summary measures plots stored summary list. results can set internally saved setting target_folder summary_dir arguments. region can estimated parallel using future package (scenarios cores set 1). routine use MCMC chain can also run parallel (future = TRUE) time (max_execution_time) allowing partial results returned subset chains running longer expected. See documentation future package details nested futures. Summary measures returned include table formatted reporting (along raw results processing). Futures updated extend S3 methods used smooth access output. range plots returned (single summary plot shown ).","code":"reported_cases <- data.table::rbindlist(list(   data.table::copy(reported_cases)[, region := \"testland\"],   reported_cases[, region := \"realland\"] )) head(reported_cases) #>          date confirm   region #>        <Date>   <num>   <char> #> 1: 2020-02-22      14 testland #> 2: 2020-02-23      62 testland #> 3: 2020-02-24      53 testland #> 4: 2020-02-25      97 testland #> 5: 2020-02-26      93 testland #> 6: 2020-02-27      78 testland estimates <- regional_epinow(   reported_cases = reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.2), rw = 7),   gp = NULL,   stan = stan_opts(cores = 4, warmup = 250, samples = 1000) ) #> INFO [2023-01-24 20:22:12] Producing following optional outputs: regions, summary, samples, plots, latest #> INFO [2023-01-24 20:22:12] Reporting estimates using data up to: 2020-04-21 #> INFO [2023-01-24 20:22:12] No target directory specified so returning output #> INFO [2023-01-24 20:22:12] Producing estimates for: testland, realland #> INFO [2023-01-24 20:22:12] Regions excluded: none #> DEBUG [2023-01-24 20:22:12] testland: Running in exact mode for 1000 samples (across 4 chains each with a warm up of 250 iterations each) and 74 time steps of which 7 are a forecast #> WARN [2023-01-24 20:22:30] testland (chain: 1): Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess -  #> WARN [2023-01-24 20:22:30] testland (chain: 1): Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess -  #> INFO [2023-01-24 20:22:31] Completed estimates for: testland #> DEBUG [2023-01-24 20:22:31] realland: Running in exact mode for 1000 samples (across 4 chains each with a warm up of 250 iterations each) and 74 time steps of which 7 are a forecast #> WARN [2023-01-24 20:22:48] realland (chain: 1): Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess -  #> INFO [2023-01-24 20:22:49] Completed estimates for: realland #> INFO [2023-01-24 20:22:49] Completed regional estimates #> INFO [2023-01-24 20:22:49] Regions with estimates: 2 #> INFO [2023-01-24 20:22:49] Regions with runtime errors: 0 #> INFO [2023-01-24 20:22:49] Producing summary #> INFO [2023-01-24 20:22:49] No summary directory specified so returning summary output #> INFO [2023-01-24 20:22:50] No target directory specified so returning timings knitr::kable(estimates$summary$summarised_results$table) estimates$summary$summary_plot"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"reporting-templates","dir":"","previous_headings":"Quick start","what":"Reporting templates","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"Rmarkdown templates provided package (templates) semi-automated reporting estimates. using templates report results please highlight limitations key understanding results EpiNow2 .","code":""},{"path":"epiforecasts.io/EpiNow2/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"File issue identified issue package. Please note due operational constraints priority given users informing government policy offering methodological insights. welcome contributions, particular improve approach robustness code base. also welcome additions extensions underlying model either form options improvements.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/EpiNow2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"EpiNow2: Estimate Real-Time Case Counts and Time-Varying Epidemiological Parameters — EpiNow2-package","title":"EpiNow2: Estimate Real-Time Case Counts and Time-Varying Epidemiological Parameters — EpiNow2-package","text":"Estimates time-varying reproduction number, rate spread, doubling time using range open-source tools (Abbott et al. (2020) doi:10.12688/wellcomeopenres.16006.1 ), current best practices (Gostic et al. (2020) doi:10.1101/2020.06.18.20134858 ). aims help users avoid limitations naive implementations framework informed community feedback actively supported.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/EpiNow2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"EpiNow2: Estimate Real-Time Case Counts and Time-Varying Epidemiological Parameters — EpiNow2-package","text":"Maintainer: Sam Abbott sam.abbott@lshtm.ac.uk (ORCID) Authors: Joel Hellewell joel.hellewell@lshtm.ac.uk (ORCID) Katharine Sherratt katharine.sherratt@lshtm.ac.uk Katelyn Gostic kgostic@uchicago.edu Joe Hickson joseph.hickson@metoffice.gov.uk Hamada S. Badr badr@jhu.edu (ORCID) Michael DeWitt .dewitt.jr@gmail.com (ORCID) EpiForecasts Sebastian Funk sebastian.funk@lshtm.ac.uk contributors: Robin Thompson robin.thompson@lshtm.ac.uk [contributor] Sophie Meakin sophie.meaking@lshtm.ac.uk [contributor] James Munday james.munday@lshtm.ac.uk [contributor] Nikos Bosse [contributor] Paul Mee paul.mee@lshtm.ac.uk [contributor] Peter Ellis peter.ellis2013nz@gmail.com [contributor] Pietro Monticone pietro.monticone@edu.unito.[contributor] Lloyd Chapman lloyd.chapman1@lshtm.ac.uk  [contributor]","code":""},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Reproduction Numbers to Growth Rates — R_to_growth","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"See justification. Now handled internally stan may removed future updates user demand.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"","code":"R_to_growth(R, gamma_mean, gamma_sd)"},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"R Numeric, Reproduction number estimates gamma_mean Numeric, mean gamma distribution gamma_sd Numeric, standard deviation gamma distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"Numeric vector reproduction number estimates","code":""},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"","code":"R_to_growth(2.18, 4, 1) #> [1] 0.1996541"},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":null,"dir":"Reference","previous_headings":"","what":"Adds a day of the week vector — add_day_of_week","title":"Adds a day of the week vector — add_day_of_week","text":"Adds day week vector","code":""},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adds a day of the week vector — add_day_of_week","text":"","code":"add_day_of_week(dates, week_effect = 7)"},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adds a day of the week vector — add_day_of_week","text":"dates Vector dates week_effect Numeric 1 7 defaults 7","code":""},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adds a day of the week vector — add_day_of_week","text":"numeric vector containing period day week index","code":""},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adds a day of the week vector — add_day_of_week","text":"","code":"dates <- seq(as.Date(\"2020-03-15\"), by = \"days\", length.out = 15) # Add date based day of week add_day_of_week(dates, 7) #>  [1] 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7  # Add shorter week add_day_of_week(dates, 4) #>  [1] 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2"},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"Maps cases date infection date report via date onset.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"","code":"adjust_infection_to_report(   infections,   delay_defs,   reporting_model,   reporting_effect,   type = \"sample\",   truncate_future = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"infections data.table containing date variable numeric cases variable. delay_defs list single row data.tables  defines delay distribution (model, parameters maximum delay model). See lognorm_dist_def example structure. reporting_model function takes single numeric vector argument returns single numeric vector. Can used apply stochastic reporting effects. See examples details. reporting_effect numeric vector length 7 allows scaling reported cases day report (1 = Monday, 7 = Sunday). default scaling occurs. type Character string indicating method use transform counts. Supports either \"sample\" approximates sampling \"median\" shift median distribution. truncate_future Logical, cases truncated occur first date reported data. Defaults TRUE.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"data.table containing date variable (date report) cases variable. return_onset = TRUE third variable reference indicates date variable refers .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"","code":"# \\donttest{ # define example cases cases <- data.table::copy(example_confirmed)[, cases := as.integer(confirm)]  # define a single report delay distribution delay_def <- lognorm_dist_def(   mean = 5, mean_sd = 1, sd = 3, sd_sd = 1,   max_value = 30, samples = 1, to_log = TRUE )  # define a single incubation period incubation_def <- lognorm_dist_def(   mean = incubation_periods[1, ]$mean,   mean_sd = incubation_periods[1, ]$mean_sd,   sd = incubation_periods[1, ]$sd,   sd_sd = incubation_periods[1, ]$sd_sd,   max_value = 30, samples = 1 )  # simple mapping report <- adjust_infection_to_report(cases, delay_defs = list(incubation_def, delay_def)) print(report) #>            date cases #>   1: 2020-02-24     1 #>   2: 2020-02-25     8 #>   3: 2020-02-26    12 #>   4: 2020-02-27    11 #>   5: 2020-02-28    28 #>  ---                  #> 124: 2020-06-26   259 #> 125: 2020-06-27   238 #> 126: 2020-06-28   243 #> 127: 2020-06-29   270 #> 128: 2020-06-30   296  # mapping with a weekly reporting effect report_weekly <- adjust_infection_to_report(   cases,   delay_defs = list(incubation_def, delay_def),   reporting_effect = c(1.1, rep(1, 4), 0.95, 0.95) ) print(report_weekly) #>            date cases #>   1: 2020-02-23     0 #>   2: 2020-02-24     3 #>   3: 2020-02-25     5 #>   4: 2020-02-26    14 #>   5: 2020-02-27    17 #>  ---                  #> 125: 2020-06-26   233 #> 126: 2020-06-27   231 #> 127: 2020-06-28   219 #> 128: 2020-06-29   272 #> 129: 2020-06-30   248  # map using a deterministic median shift for both delays report_median <- adjust_infection_to_report(cases,   delay_defs = list(incubation_def, delay_def),   type = \"median\" ) print(report_median) #>            date confirm cases #>   1: 2020-03-01      14    14 #>   2: 2020-03-02      62    62 #>   3: 2020-03-03      53    53 #>   4: 2020-03-04      97    97 #>   5: 2020-03-05      93    93 #>  ---                          #> 126: 2020-07-04     296   296 #> 127: 2020-07-05     255   255 #> 128: 2020-07-06     175   175 #> 129: 2020-07-07     174   174 #> 130: 2020-07-08     126   126  # map with a weekly reporting effect and stochastic reporting model report_stochastic <- adjust_infection_to_report(   cases,   delay_defs = list(incubation_def, delay_def),   reporting_effect = c(1.1, rep(1, 4), 0.95, 0.95),   reporting_model = function(n) {     out <- suppressWarnings(rnbinom(length(n), as.integer(n), 0.5))     out <- ifelse(is.na(out), 0, out)   } ) print(report_stochastic) #>            date cases #>   1: 2020-02-24     7 #>   2: 2020-02-25     5 #>   3: 2020-02-26    12 #>   4: 2020-02-27    31 #>   5: 2020-02-28    39 #>  ---                  #> 124: 2020-06-26   225 #> 125: 2020-06-27   209 #> 126: 2020-06-28   221 #> 127: 2020-06-29   291 #> 128: 2020-06-30   280 # }"},{"path":"epiforecasts.io/EpiNow2/reference/allocate_delays.html","id":null,"dir":"Reference","previous_headings":"","what":"Allocate Delays into Required Stan Format — allocate_delays","title":"Allocate Delays into Required Stan Format — allocate_delays","text":"Allocate delays stan. Used delay_opts().","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_delays.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allocate Delays into Required Stan Format — allocate_delays","text":"","code":"allocate_delays(delay_var, no_delays)"},{"path":"epiforecasts.io/EpiNow2/reference/allocate_delays.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Allocate Delays into Required Stan Format — allocate_delays","text":"delay_var List numeric delays no_delays Numeric, number delays","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_delays.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Allocate Delays into Required Stan Format — allocate_delays","text":"numeric array","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Allocate Empty Parameters to a List — allocate_empty","title":"Allocate Empty Parameters to a List — allocate_empty","text":"Allocate missing parameters empty two dimensional arrays. Used internally simulate_infections.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allocate Empty Parameters to a List — allocate_empty","text":"","code":"allocate_empty(data, params, n = 0)"},{"path":"epiforecasts.io/EpiNow2/reference/allocate_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Allocate Empty Parameters to a List — allocate_empty","text":"data list parameters params character vector parameters allocate empty missing. n Numeric, number samples assign empty array","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_empty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Allocate Empty Parameters to a List — allocate_empty","text":"list parameters allocated empty","code":""},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Back Calculation Options — backcalc_opts","title":"Back Calculation Options — backcalc_opts","text":"Defines list specifying optional arguments back calculation cases. used rt = NULL.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Back Calculation Options — backcalc_opts","text":"","code":"backcalc_opts(prior = \"reports\", prior_window = 14, rt_window = 1)"},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Back Calculation Options — backcalc_opts","text":"prior character string defaulting \"reports\". Defines prior use deconvolving. Currently implemented options use smoothed mean delay shifted reported cases (\"reports\"), use estimated infections previous time step seeded first time step using mean shifted reported cases (\"infections\"), prior (\"none\"). Using prior result poor real time performance. prior using infections supported Gaussian process present. observed data reliable sensible first step explore increasing prior_window sensible second step longer use reported cases prior (.e set prior = \"none\"). prior_window Integer, defaults 14 days. mean centred smoothing window apply mean shifted reports (used prior back calculation). 7 days minimum recommended settings smooths day week effects depending quality data amount information users wish use prior (higher values equalling less informative prior). rt_window Integer, defaults 1. size centred rolling average use estimating Rt. must odd central estimate included.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Back Calculation Options — backcalc_opts","text":"list back calculation settings","code":""},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Back Calculation Options — backcalc_opts","text":"","code":"# default settings backcalc_opts() #> $prior #> [1] \"reports\" #>  #> $prior_window #> [1] 14 #>  #> $rt_window #> [1] 1 #>"},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"Fits integer adjusted distribution subsampled bootstrap data integrates posterior samples single set summary statistics. Can used generate robust reporting delay accounts fact underlying delay likely varies time size available reporting delay sample may representative current case load.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"","code":"bootstrapped_dist_fit(   values,   dist = \"lognormal\",   samples = 2000,   bootstraps = 10,   bootstrap_samples = 250,   max_value,   verbose = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"values Integer vector values. dist Character string, distribution fit. Defaults lognormal (\"lognormal\") gamma (\"gamma\") also supported. samples Numeric, number samples take overall bootstrapped posteriors. bootstraps Numeric, defaults 1. number bootstrap samples (replacement) delay distribution take. bootstrap_samples Numeric, defaults 100. number samples take bootstrap. sample size supplied delay distribution less 100 used instead. max_value Numeric, defaults  maximum value observed data. Maximum delay  allow (added output impact fitting). verbose Logical, defaults FALSE. progress messages printed.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"list summarising bootstrapped distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"","code":"# \\donttest{ # lognormal delays <- rlnorm(500, log(5), 1) out <- bootstrapped_dist_fit(delays,   samples = 1000, bootstraps = 10,   dist = \"lognormal\" ) out #> $mean #> [1] 1.517015 #>  #> $mean_sd #> [1] 0.09739827 #>  #> $sd #> [1] 1.100568 #>  #> $sd_sd #> [1] 0.07056355 #>  #> $max #> [1] 112 #>  # }"},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Credible Interval — calc_CrI","title":"Calculate Credible Interval — calc_CrI","text":"Adds symmetric credible interval based quantiles.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Credible Interval — calc_CrI","text":"","code":"calc_CrI(samples, summarise_by = c(), CrI = 0.9)"},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Credible Interval — calc_CrI","text":"samples data.table containing least value variable summarise_by character vector variables group . CrI Numeric 0 1. credible interval return values. Defaults 0.9.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Credible Interval — calc_CrI","text":"data.table containing upper lower bounds specified credible interval","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Credible Interval — calc_CrI","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") # add 90% credible interval calc_CrI(samples) #>    value      CrI #> 1:  1.45 lower_90 #> 2:  9.55 upper_90 # add 90% credible interval grouped by type calc_CrI(samples, summarise_by = \"type\") #>    type value      CrI #> 1:  car  1.45 lower_90 #> 2:  car  9.55 upper_90"},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Credible Intervals — calc_CrIs","title":"Calculate Credible Intervals — calc_CrIs","text":"Adds symmetric credible intervals based quantiles.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Credible Intervals — calc_CrIs","text":"","code":"calc_CrIs(samples, summarise_by = c(), CrIs = c(0.2, 0.5, 0.9))"},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Credible Intervals — calc_CrIs","text":"samples data.table containing least value variable summarise_by character vector variables group . CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Credible Intervals — calc_CrIs","text":"data.table containing summarise_by variables specified lower upper credible intervals","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Credible Intervals — calc_CrIs","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") # add credible intervals calc_CrIs(samples) #>    . lower_90 lower_50 lower_20 upper_20 upper_50 upper_90 #> 1: .     1.45     3.25      4.6      6.4     7.75     9.55 # add 90% credible interval grouped by type calc_CrIs(samples, summarise_by = \"type\") #>    type lower_90 lower_50 lower_20 upper_20 upper_50 upper_90 #> 1:  car     1.45     3.25      4.6      6.4     7.75     9.55"},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate All Summary Measures — calc_summary_measures","title":"Calculate All Summary Measures — calc_summary_measures","text":"Calculate summary statistics credible intervals data frame group.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate All Summary Measures — calc_summary_measures","text":"","code":"calc_summary_measures(   samples,   summarise_by = NULL,   order_by = NULL,   CrIs = c(0.2, 0.5, 0.9) )"},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate All Summary Measures — calc_summary_measures","text":"samples data.table containing least value variable summarise_by character vector variables group . order_by character vector parameters order , defaults summarise_by variables. CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate All Summary Measures — calc_summary_measures","text":"data.table containing summary statistics group.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate All Summary Measures — calc_summary_measures","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") # default calc_summary_measures(samples) #>    type median mean      sd lower_90 lower_50 lower_20 upper_20 upper_50 #> 1:  car    5.5  5.5 3.02765     1.45     3.25      4.6      6.4     7.75 #>    upper_90 #> 1:     9.55 #  by type calc_summary_measures(samples, summarise_by = \"type\") #>    type median mean      sd lower_90 lower_50 lower_20 upper_20 upper_50 #> 1:  car    5.5  5.5 3.02765     1.45     3.25      4.6      6.4     7.75 #>    upper_90 #> 1:     9.55"},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Summary Statistics — calc_summary_stats","title":"Calculate Summary Statistics — calc_summary_stats","text":"Calculate summary statistics data frame group. Currently supports mean, median standard deviation.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Summary Statistics — calc_summary_stats","text":"","code":"calc_summary_stats(samples, summarise_by = c())"},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Summary Statistics — calc_summary_stats","text":"samples data.table containing least value variable summarise_by character vector variables group .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Summary Statistics — calc_summary_stats","text":"data.table containing upper lower bounds specified credible interval","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Summary Statistics — calc_summary_stats","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") # default calc_summary_stats(samples) #>    median mean      sd #> 1:    5.5  5.5 3.02765 #  by type calc_summary_stats(samples, summarise_by = \"type\") #>    type median mean      sd #> 1:  car    5.5  5.5 3.02765"},{"path":"epiforecasts.io/EpiNow2/reference/clean_nowcasts.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean Nowcasts for a Supplied Date — clean_nowcasts","title":"Clean Nowcasts for a Supplied Date — clean_nowcasts","text":"function removes nowcasts format produced EpiNow2 target directory date supplied.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_nowcasts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean Nowcasts for a Supplied Date — clean_nowcasts","text":"","code":"clean_nowcasts(date = NULL, nowcast_dir = \".\")"},{"path":"epiforecasts.io/EpiNow2/reference/clean_nowcasts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean Nowcasts for a Supplied Date — clean_nowcasts","text":"date Date object. Defaults today's date nowcast_dir Character string giving filepath nowcast results directory. Defaults current directory.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_nowcasts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean Nowcasts for a Supplied Date — clean_nowcasts","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean Regions — clean_regions","title":"Clean Regions — clean_regions","text":"Removes regions insufficient time points, provides logging information input.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean Regions — clean_regions","text":"","code":"clean_regions(reported_cases, non_zero_points)"},{"path":"epiforecasts.io/EpiNow2/reference/clean_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean Regions — clean_regions","text":"reported_cases data frame confirmed cases (confirm) date (date), region (region). non_zero_points Numeric, minimum number time points non-zero cases region required region evaluated. Defaults 7.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean Regions — clean_regions","text":"dataframe cleaned regional data","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Output — construct_output","title":"Construct Output — construct_output","text":"Combines output produced internally epinow single list.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Output — construct_output","text":"","code":"construct_output(   estimates,   estimated_reported_cases,   plots = NULL,   summary = NULL,   samples = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Output — construct_output","text":"estimates List data frames output estimate_infections estimated_reported_cases list dataframes produced estimates_by_report_date. plots list plots produced report_plots. summary list summary output produced report_summary. samples Logical, defaults TRUE. samples saved","code":""},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Output — construct_output","text":"list output returned epinow","code":""},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Construct Output — construct_output","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"Convert mean standard deviation log mean lognormal distribution. Useful defining distributions supported estimate_infections, epinow, regional_epinow.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"","code":"convert_to_logmean(mean, sd)"},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"mean Numeric, mean distribution sd Numeric, standard deviation distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"log mean lognormal distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"","code":"convert_to_logmean(2, 1) #> [1] 0.5815754"},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"Convert mean standard deviation log standard deviation lognormal distribution. Useful defining distributions supported estimate_infections, epinow, regional_epinow.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"","code":"convert_to_logsd(mean, sd)"},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"mean Numeric, mean distribution sd Numeric, standard deviation distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"log standard deviation lognormal distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"","code":"convert_to_logsd(2, 1) #> [1] 0.4723807"},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":null,"dir":"Reference","previous_headings":"","what":"Copy Results From Dated Folder to Latest — copy_results_to_latest","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"Copies output dated folder latest folder. May undergo changes later releases.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"","code":"copy_results_to_latest(target_folder = NULL, latest_folder = NULL)"},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"target_folder Character string specifying save results (create present). latest_folder Character string containing path latest target folder. produced setup_target_folder.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Back Calculation Data — create_backcalc_data","title":"Create Back Calculation Data — create_backcalc_data","text":"Takes output backcalc_opts() converts list understood stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Back Calculation Data — create_backcalc_data","text":"","code":"create_backcalc_data(backcalc = backcalc_opts)"},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Back Calculation Data — create_backcalc_data","text":"backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts().","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Back Calculation Data — create_backcalc_data","text":"list settings defining Gaussian process","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Back Calculation Data — create_backcalc_data","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Back Calculation Data — create_backcalc_data","text":"","code":"# define input data required data <- list(   t = 30,   seeding_time = 7,   horizon = 7 )  # default gaussian process data create_gp_data(data = data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $fixed #> [1] 0 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.991842 #>  #> $ls_sdlog #> [1] 0.3245928 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>   # settings when no gaussian process is desired create_gp_data(NULL, data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $stationary #> [1] 1 #>  #> $fixed #> [1] 1 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.991842 #>  #> $ls_sdlog #> [1] 0.3245928 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>   # custom lengthscale create_gp_data(gp_opts(ls_mean = 14), data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $fixed #> [1] 0 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.527486 #>  #> $ls_sdlog #> [1] 0.4723807 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Clean Reported Cases — create_clean_reported_cases","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"Cleans data frame reported cases replacing missing dates 0 cases applies optional threshold point 0 cases replaced moving average observed cases. See zero_threshold details.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"","code":"create_clean_reported_cases(   reported_cases,   horizon,   filter_leading_zeros = TRUE,   zero_threshold = Inf )"},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. horizon Numeric, defaults 7. Number days future forecast. filter_leading_zeros Logical, defaults TRUE. zeros start time series filtered . zero_threshold Numeric defaults Inf. Indicates detected zero cases meaningful using threshold number cases based 7 day average. average threshold zero replaced backwards looking rolling average. set infinity changes made.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"cleaned data frame reported cases","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct the Required Future Rt assumption — create_future_rt","title":"Construct the Required Future Rt assumption — create_future_rt","text":"Converts future argument rt_opts() arguments can passed stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct the Required Future Rt assumption — create_future_rt","text":"","code":"create_future_rt(future = \"latest\", delay = 0)"},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct the Required Future Rt assumption — create_future_rt","text":"future character string integer. argument indicates set future Rt values. Supported options project using Rt model (\"project\"), use latest estimate based partial data (\"latest\"), use latest estimate based data 50% complete (\"estimate\"). integer supplied Rt estimate many days future (past negative) past used forwards time. delay Numeric mean delay","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct the Required Future Rt assumption — create_future_rt","text":"list containing logical called fixed integer called ","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Construct the Required Future Rt assumption — create_future_rt","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Gaussian Process Data — create_gp_data","title":"Create Gaussian Process Data — create_gp_data","text":"Takes output gp_opts() converts list understood stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Gaussian Process Data — create_gp_data","text":"","code":"create_gp_data(gp = gp_opts(), data)"},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Gaussian Process Data — create_gp_data","text":"gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. data list containing following numeric values: t, seeding_time, horizon.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Gaussian Process Data — create_gp_data","text":"list settings defining Gaussian process","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Gaussian Process Data — create_gp_data","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Gaussian Process Data — create_gp_data","text":"","code":"# define input data required data <- list(   t = 30,   seeding_time = 7,   horizon = 7 )  # default gaussian process data create_gp_data(data = data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $fixed #> [1] 0 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.991842 #>  #> $ls_sdlog #> [1] 0.3245928 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>   # settings when no gaussian process is desired create_gp_data(NULL, data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $stationary #> [1] 1 #>  #> $fixed #> [1] 1 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.991842 #>  #> $ls_sdlog #> [1] 0.3245928 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>   # custom lengthscale create_gp_data(gp_opts(ls_mean = 14), data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $fixed #> [1] 0 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.527486 #>  #> $ls_sdlog #> [1] 0.4723807 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_initial_conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Initial Conditions Generating Function — create_initial_conditions","title":"Create Initial Conditions Generating Function — create_initial_conditions","text":"Uses output create_stan_data create function can used sample prior distributions (close possible) parameters. Used order initialise stan chain within range plausible values.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_initial_conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Initial Conditions Generating Function — create_initial_conditions","text":"","code":"create_initial_conditions(data)"},{"path":"epiforecasts.io/EpiNow2/reference/create_initial_conditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Initial Conditions Generating Function — create_initial_conditions","text":"data list data produced create_stan_data.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_initial_conditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Initial Conditions Generating Function — create_initial_conditions","text":"initial condition generating function","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Observation Model Settings — create_obs_model","title":"Create Observation Model Settings — create_obs_model","text":"Takes output obs_opts() converts list understood stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Observation Model Settings — create_obs_model","text":"","code":"create_obs_model(obs = obs_opts(), dates)"},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Observation Model Settings — create_obs_model","text":"obs list options generated obs_opts() defining observation model. Defaults obs_opts(). dates vector dates used calculate day week.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Observation Model Settings — create_obs_model","text":"list settings ready passed stan defining Observation Model","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Observation Model Settings — create_obs_model","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Observation Model Settings — create_obs_model","text":"","code":"dates <- seq(as.Date(\"2020-03-15\"), by = \"days\", length.out = 15) # default observation model data create_obs_model(dates = dates) #> $model_type #> [1] 1 #>  #> $phi_mean #> [1] 0 #>  #> $phi_sd #> [1] 1 #>  #> $week_effect #> [1] 7 #>  #> $obs_weight #> [1] 1 #>  #> $obs_scale #> [1] 0 #>  #> $likelihood #> [1] 1 #>  #> $return_likelihood #> [1] 0 #>  #> $day_of_week #>  [1] 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 #>  #> $obs_scale_mean #> [1] 0 #>  #> $obs_scale_sd #> [1] 0 #>   # Poisson observation model create_obs_model(obs_opts(family = \"poisson\"), dates = dates) #> $model_type #> [1] 0 #>  #> $phi_mean #> [1] 0 #>  #> $phi_sd #> [1] 1 #>  #> $week_effect #> [1] 7 #>  #> $obs_weight #> [1] 1 #>  #> $obs_scale #> [1] 0 #>  #> $likelihood #> [1] 1 #>  #> $return_likelihood #> [1] 0 #>  #> $day_of_week #>  [1] 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 #>  #> $obs_scale_mean #> [1] 0 #>  #> $obs_scale_sd #> [1] 0 #>   # Applying a observation scaling to the data create_obs_model(obs_opts(scale = list(mean = 0.4, sd = 0.01)), dates = dates) #> $model_type #> [1] 1 #>  #> $phi_mean #> [1] 0 #>  #> $phi_sd #> [1] 1 #>  #> $week_effect #> [1] 7 #>  #> $obs_weight #> [1] 1 #>  #> $obs_scale #> [1] 1 #>  #> $likelihood #> [1] 1 #>  #> $return_likelihood #> [1] 0 #>  #> $day_of_week #>  [1] 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 #>  #> $obs_scale_mean #> [1] 0.4 #>  #> $obs_scale_sd #> [1] 0.01 #>   # Apply a custom week week length create_obs_model(obs_opts(week_length = 3), dates = dates) #> $model_type #> [1] 1 #>  #> $phi_mean #> [1] 0 #>  #> $phi_sd #> [1] 1 #>  #> $week_effect #> [1] 3 #>  #> $obs_weight #> [1] 1 #>  #> $obs_scale #> [1] 0 #>  #> $likelihood #> [1] 1 #>  #> $return_likelihood #> [1] 0 #>  #> $day_of_week #>  [1] 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 #>  #> $obs_scale_mean #> [1] 0 #>  #> $obs_scale_sd #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Time-varying Reproduction Number Data — create_rt_data","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"Takes output rt_opts() converts list understood stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"","code":"create_rt_data(rt = rt_opts(), breakpoints = NULL, delay = 0, horizon = 0)"},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. breakpoints integer vector (binary) indicating location breakpoints. delay Numeric mean delay horizon Numeric, forecast horizon.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"list settings defining time-varying reproduction number","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"","code":"# default Rt data create_rt_data() #> $r_mean #> [1] 1 #>  #> $r_sd #> [1] 1 #>  #> $estimate_r #> [1] 1 #>  #> $bp_n #> [1] 0 #>  #> $breakpoints #> NULL #>  #> $future_fixed #> [1] 1 #>  #> $fixed_from #> [1] 0 #>  #> $pop #> [1] 0 #>  #> $stationary #> [1] 0 #>  #> $future_time #> [1] 0 #>   # settings when no Rt is desired create_rt_data(rt = NULL) #> $r_mean #> [1] 1 #>  #> $r_sd #> [1] 1 #>  #> $estimate_r #> [1] 0 #>  #> $bp_n #> [1] 0 #>  #> $breakpoints #> NULL #>  #> $future_fixed #> [1] 0 #>  #> $fixed_from #> [1] 0 #>  #> $pop #> [1] 0 #>  #> $stationary #> [1] 1 #>  #> $future_time #> [1] 0 #>   # using breakpoints create_rt_data(rt_opts(use_breakpoints = TRUE), breakpoints = rep(1, 10)) #> $r_mean #> [1] 1 #>  #> $r_sd #> [1] 1 #>  #> $estimate_r #> [1] 1 #>  #> $bp_n #> [1] 10 #>  #> $breakpoints #>  [1] 1 1 1 1 1 1 1 1 1 1 #>  #> $future_fixed #> [1] 1 #>  #> $fixed_from #> [1] 0 #>  #> $pop #> [1] 0 #>  #> $stationary #> [1] 0 #>  #> $future_time #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Delay Shifted Cases — create_shifted_cases","title":"Create Delay Shifted Cases — create_shifted_cases","text":"functions creates data frame reported cases smoothed using centred partial rolling average (period set smoothing_window) shifted back time delay. used estimate_infections generate mean shifted prior back calculation method (see backcalc_opts()) based.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Delay Shifted Cases — create_shifted_cases","text":"","code":"create_shifted_cases(reported_cases, shift, smoothing_window, horizon)"},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Delay Shifted Cases — create_shifted_cases","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. shift Numeric, mean delay shift apply. smoothing_window Numeric, rolling average smoothing window apply. Must odd order defined centred average. horizon Numeric, defaults 7. Number days future forecast.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Delay Shifted Cases — create_shifted_cases","text":"data frame shifted reported cases","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Delay Shifted Cases — create_shifted_cases","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Delay Shifted Cases — create_shifted_cases","text":"","code":"create_shifted_cases(example_confirmed, 7, 14, 7) #>            date confirm #>   1: 2020-03-07    3028 #>   2: 2020-03-08    3407 #>   3: 2020-03-09    3698 #>   4: 2020-03-10    3912 #>   5: 2020-03-11    4217 #>  ---                    #> 112: 2020-06-26     224 #> 113: 2020-06-27     222 #> 114: 2020-06-28     219 #> 115: 2020-06-29     217 #> 116: 2020-06-30     215"},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a List of Stan Arguments — create_stan_args","title":"Create a List of Stan Arguments — create_stan_args","text":"Generates list arguments required rstan::sampling rstan::vb combining required options, data, type initialisation. Initialisation defaults random expected create_initial_conditions used.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a List of Stan Arguments — create_stan_args","text":"","code":"create_stan_args(   stan = stan_opts(),   data = NULL,   init = \"random\",   verbose = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a List of Stan Arguments — create_stan_args","text":"stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. data list stan data created create_stan_data init Initial conditions passed rstan. Defaults \"random\" can also function ( supplied create_intitial_conditions). verbose Logical, defaults FALSE. verbose progress messages returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a List of Stan Arguments — create_stan_args","text":"list stan arguments","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a List of Stan Arguments — create_stan_args","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a List of Stan Arguments — create_stan_args","text":"","code":"# default settings create_stan_args() #> $data #> NULL #>  #> $init #> [1] \"random\" #>  #> $refresh #> [1] 0 #>  #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // convolve two vectors #> // length of x #> // produces a convolution across the lenght specified #> vector convolve(vector x, vector y, int len) { #>   int xlen = num_elements(x); #>   int ylen = num_elements(y); #>   vector[len] convolution = rep_vector(0, len); #>   for (i in 1:xlen) { #>     for (j in 1:(min(len - i + 1, ylen))) { #>       convolution[i + j - 1] += x[i] * y[j]; #>     } #>   } #>   return(convolution); #> } #>  #> // convolve two vectors as a backwards dot product #> // y vector shoud be reversed #> // limited to the length of x and backwards looking for x indexes #> // designed for use convolve a case vector and a delay pmf #> vector convolve_dot_product(vector x, vector y, int len) { #>     int ylen = num_elements(y); #>     vector[len] z; #>     for (s in 1:len) { #>         z[s] = dot_product( #>             x[max(1, (s - ylen + 1)):s], tail(y, min(ylen, s)) #>           ); #>     } #>    return(z); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           vector delay_rev_pmf, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_rev_pmf); #>   if (delays) { #>     unobs_reports = convolve_dot_product(unobs_reports, delay_rev_pmf, t); #>     reports = unobs_reports[(seeding_time + 1):t]; #>   } else { #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> // Calculate the daily probability of reporting using parametric #> // distributions up to the maximum observed delay. #> // If sigma is 0 all the probability mass is put on n. #> // Adapted from https://github.com/epiforecasts/epinowcast #> // @author Sam Abbott #> // @author Adrian Lison #> vector discretised_pmf(real mu, real sigma, int n, int dist, #>                        int left_truncate) { #>   vector[n] pmf; #>   if (sigma > 0) { #>     vector[n + 1] upper_cdf; #>     if (dist == 0) { #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = lognormal_cdf(i - 1 + left_truncate, mu, sigma); #>       } #>     } else if (dist == 1) { #>       real alpha = mu^2 / sigma^2; #>       real beta = mu / sigma^2; #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = gamma_cdf(i - 1 + left_truncate, alpha, beta); #>       } #>     } else { #>       reject(\"Unknown distribution function provided.\"); #>     } #>     // discretise #>     pmf = upper_cdf[2:(n + 1)] - upper_cdf[1:n]; #>     // normalize #>     pmf = pmf / (upper_cdf[n + 1] - upper_cdf[1]); #>   } else { #>     // delta function #>     pmf = rep_vector(0, n); #>     pmf[n] = 1; #>   } #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // combined fixed/variable pmfs #> vector combine_pmfs(vector fixed_pmf, real[] pmf_mu, real[] pmf_sigma, int[] pmf_n, int[] dist, int len, int left_truncate, int reverse_pmf) { #>   int n_fixed = num_elements(fixed_pmf); #>   int n_variable = num_elements(pmf_mu); #>   vector[len] pmf = rep_vector(0, len); #>   if (n_fixed > 0) { #>     pmf[1:n_fixed] = fixed_pmf; #>   } else if (n_variable > 0) { #>     pmf[1] = 1; #>   } #>   for (s in 1:n_variable) { #>     vector[pmf_n[s]] variable_pmf; #>     variable_pmf = discretised_pmf(pmf_mu[s], pmf_sigma[s], pmf_n[s], dist[s], left_truncate); #>     pmf = convolve(pmf, variable_pmf, len); #>   } #>   if (reverse_pmf) { #>     pmf = reverse_mf(pmf); #>   } #>   return(pmf); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, #>                int[] delay_dist, int weight) { #>     int mean_delays = num_elements(delay_mean); #>     int sd_delays = num_elements(delay_sd); #>     if (mean_delays) { #>       for (s in 1:mean_delays) { #>         if (delay_mean_sd[s] > 0) { #>           // uncertain mean #>           target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           // if a distribution with postive support only truncate the prior #>           if (delay_dist[s]) { #>             target += -normal_lccdf(0 | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           } #>         } #>       } #>     } #>     if (sd_delays) { #>       for (s in 1:sd_delays) { #>         if (delay_sd_sd[s] > 0) { #>           // uncertain sd #>           target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>           target += -normal_lccdf(0 | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>         } #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_rev_pmf, #>                            int seeding_time, int index){ #>   int gt_max = num_elements(gt_rev_pmf); #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - gt_max)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(gt_max, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product( #>     infections[inf_start:inf_end], tail(gt_rev_pmf, pmf_accessed) #>   ); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, vector gt_rev_pmf, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_rev_pmf, uot, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, vector trunc_rev_cmf, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = num_elements(trunc_rev_cmf); #>   int first_t = t - trunc_max + 1; #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ trunc_rev_cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* trunc_rev_cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     if (trunc_mean_sd[1] > 0) { #>       // uncertain mean #>       truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     } #>     if (trunc_sd_sd[1] > 0) { #>       // uncertain sd #>       truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>     } #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     vector gt_rev_pmf, int smooth) { #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_rev_pmf, seeding_time, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   int n_uncertain_mean_delays;   // no. of delay distributions with uncertain mean #>   int n_uncertain_sd_delays;     // no. of delay distributions with uncertain sd #>   int n_fixed_delays;     // no. of delay distributions with uncertain sd #>   // indices of delay distributions with uncertainty #>   int<lower = 1, upper = delays> uncertain_mean_delays[n_uncertain_mean_delays]; #>   int<lower = 1, upper = delays> uncertain_sd_delays[n_uncertain_sd_delays]; #>   int<lower = 1, upper = delays> fixed_delays[n_fixed_delays]; #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int<lower = 1> delay_max[delays];       // maximum incubation period #>   int delay_dist[delays];       // 0 = lognormal; 1 = gamma #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd[1];                   // prior sd of mean generation time #>   real gt_mean_mean[1];                 // prior mean of mean generation time #>   real gt_sd_mean[1];                   // prior mean of sd of generation time #>   real gt_sd_sd[1];                     // prior sd of sd of generation time #>   int<lower = 1> gt_max[1];                        // maximum generation time #>   int gt_fixed[1];                      // 0 = variable gt; 1 = fixed gt #>   int gt_dist[1];                    // distribution (0 = lognormal, 1 = gamma) #>   int gt_weight;                    #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int<lower = 1> trunc_max[truncation];    // maximum truncation supported #>   int trunc_fixed[truncation];    // whether the truncation distribution is fixed #>   int trunc_dist[truncation];    // 0 = lognormal; 1 = gamma #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #>  #>   int delay_max_fixed = (n_fixed_delays == 0 ? 0 : #>     sum(delay_max[fixed_delays]) - num_elements(fixed_delays) + 1); #>   int delay_max_total = (delays == 0 ? 0 : #>     sum(delay_max) - num_elements(delay_max) + 1); #>   vector[gt_fixed[1] ? gt_max[1] : 0] gt_fixed_pmf; #>   vector[truncation && trunc_fixed[1] ? trunc_max[1] : 0] trunc_fixed_pmf; #>   vector[delay_max_fixed] delays_fixed_pmf; #>  #>   if (gt_fixed[1]) { #>     gt_fixed_pmf = discretised_pmf(gt_mean_mean[1], gt_sd_mean[1], gt_max[1], gt_dist[1], 1); #>   } #>   if (truncation && trunc_fixed[1]) { #>     trunc_fixed_pmf = discretised_pmf( #>       trunc_mean_mean[1], trunc_sd_mean[1], trunc_max[1], trunc_dist[1], 0 #>     ); #>   } #>   if (n_fixed_delays) { #>     delays_fixed_pmf = combine_pmfs( #>       to_vector([ 1 ]), delay_mean_mean[fixed_delays], #>       delay_sd_mean[fixed_delays], delay_max[fixed_delays],  #>       delay_dist[fixed_delays], delay_max_fixed, 0, 0 #>     ); #>   } #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<upper = gt_max[1]> gt_mean[estimate_r && gt_mean_sd[1] > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd[1] > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[n_uncertain_mean_delays];         // mean of delays #>   real<lower = 0> delay_sd[n_uncertain_sd_delays];  // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0, upper = 1> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real trunc_mean[truncation && !trunc_fixed[1]];        // mean of truncation #>   real<lower = 0> trunc_sd[truncation && !trunc_fixed[1]]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     vector[gt_max[1]] gt_rev_pmf; #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean, gt_sd, gt_max, gt_dist, gt_max[1], 1, 1 #>     ); #>     R = update_Rt( #>       ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary #>     ); #>     infections = generate_infections( #>       R, seeding_time, gt_rev_pmf, initial_infections, initial_growth, pop, #>       future_time #>     ); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections( #>       shifted_cases, noise, fixed, backcalc_prior #>     ); #>   } #>   // convolve from latent infections to mean of observations #>   { #>     vector[delay_max_total] delay_rev_pmf; #>     delay_rev_pmf = combine_pmfs( #>       delays_fixed_pmf, delay_mean, delay_sd, delay_max, delay_dist, delay_max_total, 0, 1 #>     ); #>     reports = convolve_to_report(infections, delay_rev_pmf, seeding_time); #>   } #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    vector[trunc_max[1]] trunc_rev_cmf; #>    trunc_rev_cmf = reverse_mf(cumulative_sum(combine_pmfs( #>      trunc_fixed_pmf, trunc_mean, trunc_sd, trunc_max, trunc_dist, trunc_max[1], 0, 0 #>    ))); #>    obs_reports = truncate(reports[1:ot], trunc_rev_cmf, 0); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean[uncertain_mean_delays], #>     delay_mean_sd[uncertain_mean_delays], #>     delay_sd, delay_sd_mean[uncertain_sd_delays], #>     delay_sd_sd[uncertain_sd_delays], delay_dist[uncertain_mean_delays], t #>   ); #>   // priors for truncation #>   delays_lp( #>     trunc_mean, trunc_sd, #>     trunc_mean_mean, trunc_mean_sd, #>     trunc_sd_mean, trunc_sd_sd, #>     trunc_dist, 1 #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     delays_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, gt_dist, gt_weight #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0, 1]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd[1] > 0 ? gt_mean[1] : gt_mean_mean[1]); #>     real set_gt_sd = (gt_sd_sd [1]> 0 ? gt_sd[1] : gt_sd_mean[1]); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   } else { #>     // sample generation time #>     real gt_mean_sample[1]; #>     real gt_sd_sample[1]; #>     vector[gt_max[1]] gt_rev_pmf; #>  #>     gt_mean_sample[1] = (gt_mean_sd[1] > 0 ? normal_rng(gt_mean_mean[1], gt_mean_sd[1]) : gt_mean_mean[1]); #>     gt_sd_sample[1] = (gt_sd_sd[1] > 0 ? normal_rng(gt_sd_mean[1], gt_sd_sd[1]) : gt_sd_mean[1]); #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean_sample, gt_sd_sample, gt_max, gt_dist, gt_max[1], #>       1, 1 #>     ); #>  #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_rev_pmf, rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample[1], gt_sd_sample[1]); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"sampling\" #>  #> $cores #> [1] 1 #>  #> $warmup #> [1] 250 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 87034298 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 750 #>   # increasing warmup create_stan_args(stan = stan_opts(warmup = 1000)) #> $data #> NULL #>  #> $init #> [1] \"random\" #>  #> $refresh #> [1] 0 #>  #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // convolve two vectors #> // length of x #> // produces a convolution across the lenght specified #> vector convolve(vector x, vector y, int len) { #>   int xlen = num_elements(x); #>   int ylen = num_elements(y); #>   vector[len] convolution = rep_vector(0, len); #>   for (i in 1:xlen) { #>     for (j in 1:(min(len - i + 1, ylen))) { #>       convolution[i + j - 1] += x[i] * y[j]; #>     } #>   } #>   return(convolution); #> } #>  #> // convolve two vectors as a backwards dot product #> // y vector shoud be reversed #> // limited to the length of x and backwards looking for x indexes #> // designed for use convolve a case vector and a delay pmf #> vector convolve_dot_product(vector x, vector y, int len) { #>     int ylen = num_elements(y); #>     vector[len] z; #>     for (s in 1:len) { #>         z[s] = dot_product( #>             x[max(1, (s - ylen + 1)):s], tail(y, min(ylen, s)) #>           ); #>     } #>    return(z); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           vector delay_rev_pmf, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_rev_pmf); #>   if (delays) { #>     unobs_reports = convolve_dot_product(unobs_reports, delay_rev_pmf, t); #>     reports = unobs_reports[(seeding_time + 1):t]; #>   } else { #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> // Calculate the daily probability of reporting using parametric #> // distributions up to the maximum observed delay. #> // If sigma is 0 all the probability mass is put on n. #> // Adapted from https://github.com/epiforecasts/epinowcast #> // @author Sam Abbott #> // @author Adrian Lison #> vector discretised_pmf(real mu, real sigma, int n, int dist, #>                        int left_truncate) { #>   vector[n] pmf; #>   if (sigma > 0) { #>     vector[n + 1] upper_cdf; #>     if (dist == 0) { #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = lognormal_cdf(i - 1 + left_truncate, mu, sigma); #>       } #>     } else if (dist == 1) { #>       real alpha = mu^2 / sigma^2; #>       real beta = mu / sigma^2; #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = gamma_cdf(i - 1 + left_truncate, alpha, beta); #>       } #>     } else { #>       reject(\"Unknown distribution function provided.\"); #>     } #>     // discretise #>     pmf = upper_cdf[2:(n + 1)] - upper_cdf[1:n]; #>     // normalize #>     pmf = pmf / (upper_cdf[n + 1] - upper_cdf[1]); #>   } else { #>     // delta function #>     pmf = rep_vector(0, n); #>     pmf[n] = 1; #>   } #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // combined fixed/variable pmfs #> vector combine_pmfs(vector fixed_pmf, real[] pmf_mu, real[] pmf_sigma, int[] pmf_n, int[] dist, int len, int left_truncate, int reverse_pmf) { #>   int n_fixed = num_elements(fixed_pmf); #>   int n_variable = num_elements(pmf_mu); #>   vector[len] pmf = rep_vector(0, len); #>   if (n_fixed > 0) { #>     pmf[1:n_fixed] = fixed_pmf; #>   } else if (n_variable > 0) { #>     pmf[1] = 1; #>   } #>   for (s in 1:n_variable) { #>     vector[pmf_n[s]] variable_pmf; #>     variable_pmf = discretised_pmf(pmf_mu[s], pmf_sigma[s], pmf_n[s], dist[s], left_truncate); #>     pmf = convolve(pmf, variable_pmf, len); #>   } #>   if (reverse_pmf) { #>     pmf = reverse_mf(pmf); #>   } #>   return(pmf); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, #>                int[] delay_dist, int weight) { #>     int mean_delays = num_elements(delay_mean); #>     int sd_delays = num_elements(delay_sd); #>     if (mean_delays) { #>       for (s in 1:mean_delays) { #>         if (delay_mean_sd[s] > 0) { #>           // uncertain mean #>           target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           // if a distribution with postive support only truncate the prior #>           if (delay_dist[s]) { #>             target += -normal_lccdf(0 | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           } #>         } #>       } #>     } #>     if (sd_delays) { #>       for (s in 1:sd_delays) { #>         if (delay_sd_sd[s] > 0) { #>           // uncertain sd #>           target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>           target += -normal_lccdf(0 | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>         } #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_rev_pmf, #>                            int seeding_time, int index){ #>   int gt_max = num_elements(gt_rev_pmf); #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - gt_max)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(gt_max, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product( #>     infections[inf_start:inf_end], tail(gt_rev_pmf, pmf_accessed) #>   ); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, vector gt_rev_pmf, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_rev_pmf, uot, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, vector trunc_rev_cmf, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = num_elements(trunc_rev_cmf); #>   int first_t = t - trunc_max + 1; #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ trunc_rev_cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* trunc_rev_cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     if (trunc_mean_sd[1] > 0) { #>       // uncertain mean #>       truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     } #>     if (trunc_sd_sd[1] > 0) { #>       // uncertain sd #>       truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>     } #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     vector gt_rev_pmf, int smooth) { #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_rev_pmf, seeding_time, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   int n_uncertain_mean_delays;   // no. of delay distributions with uncertain mean #>   int n_uncertain_sd_delays;     // no. of delay distributions with uncertain sd #>   int n_fixed_delays;     // no. of delay distributions with uncertain sd #>   // indices of delay distributions with uncertainty #>   int<lower = 1, upper = delays> uncertain_mean_delays[n_uncertain_mean_delays]; #>   int<lower = 1, upper = delays> uncertain_sd_delays[n_uncertain_sd_delays]; #>   int<lower = 1, upper = delays> fixed_delays[n_fixed_delays]; #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int<lower = 1> delay_max[delays];       // maximum incubation period #>   int delay_dist[delays];       // 0 = lognormal; 1 = gamma #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd[1];                   // prior sd of mean generation time #>   real gt_mean_mean[1];                 // prior mean of mean generation time #>   real gt_sd_mean[1];                   // prior mean of sd of generation time #>   real gt_sd_sd[1];                     // prior sd of sd of generation time #>   int<lower = 1> gt_max[1];                        // maximum generation time #>   int gt_fixed[1];                      // 0 = variable gt; 1 = fixed gt #>   int gt_dist[1];                    // distribution (0 = lognormal, 1 = gamma) #>   int gt_weight;                    #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int<lower = 1> trunc_max[truncation];    // maximum truncation supported #>   int trunc_fixed[truncation];    // whether the truncation distribution is fixed #>   int trunc_dist[truncation];    // 0 = lognormal; 1 = gamma #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #>  #>   int delay_max_fixed = (n_fixed_delays == 0 ? 0 : #>     sum(delay_max[fixed_delays]) - num_elements(fixed_delays) + 1); #>   int delay_max_total = (delays == 0 ? 0 : #>     sum(delay_max) - num_elements(delay_max) + 1); #>   vector[gt_fixed[1] ? gt_max[1] : 0] gt_fixed_pmf; #>   vector[truncation && trunc_fixed[1] ? trunc_max[1] : 0] trunc_fixed_pmf; #>   vector[delay_max_fixed] delays_fixed_pmf; #>  #>   if (gt_fixed[1]) { #>     gt_fixed_pmf = discretised_pmf(gt_mean_mean[1], gt_sd_mean[1], gt_max[1], gt_dist[1], 1); #>   } #>   if (truncation && trunc_fixed[1]) { #>     trunc_fixed_pmf = discretised_pmf( #>       trunc_mean_mean[1], trunc_sd_mean[1], trunc_max[1], trunc_dist[1], 0 #>     ); #>   } #>   if (n_fixed_delays) { #>     delays_fixed_pmf = combine_pmfs( #>       to_vector([ 1 ]), delay_mean_mean[fixed_delays], #>       delay_sd_mean[fixed_delays], delay_max[fixed_delays],  #>       delay_dist[fixed_delays], delay_max_fixed, 0, 0 #>     ); #>   } #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<upper = gt_max[1]> gt_mean[estimate_r && gt_mean_sd[1] > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd[1] > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[n_uncertain_mean_delays];         // mean of delays #>   real<lower = 0> delay_sd[n_uncertain_sd_delays];  // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0, upper = 1> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real trunc_mean[truncation && !trunc_fixed[1]];        // mean of truncation #>   real<lower = 0> trunc_sd[truncation && !trunc_fixed[1]]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     vector[gt_max[1]] gt_rev_pmf; #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean, gt_sd, gt_max, gt_dist, gt_max[1], 1, 1 #>     ); #>     R = update_Rt( #>       ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary #>     ); #>     infections = generate_infections( #>       R, seeding_time, gt_rev_pmf, initial_infections, initial_growth, pop, #>       future_time #>     ); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections( #>       shifted_cases, noise, fixed, backcalc_prior #>     ); #>   } #>   // convolve from latent infections to mean of observations #>   { #>     vector[delay_max_total] delay_rev_pmf; #>     delay_rev_pmf = combine_pmfs( #>       delays_fixed_pmf, delay_mean, delay_sd, delay_max, delay_dist, delay_max_total, 0, 1 #>     ); #>     reports = convolve_to_report(infections, delay_rev_pmf, seeding_time); #>   } #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    vector[trunc_max[1]] trunc_rev_cmf; #>    trunc_rev_cmf = reverse_mf(cumulative_sum(combine_pmfs( #>      trunc_fixed_pmf, trunc_mean, trunc_sd, trunc_max, trunc_dist, trunc_max[1], 0, 0 #>    ))); #>    obs_reports = truncate(reports[1:ot], trunc_rev_cmf, 0); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean[uncertain_mean_delays], #>     delay_mean_sd[uncertain_mean_delays], #>     delay_sd, delay_sd_mean[uncertain_sd_delays], #>     delay_sd_sd[uncertain_sd_delays], delay_dist[uncertain_mean_delays], t #>   ); #>   // priors for truncation #>   delays_lp( #>     trunc_mean, trunc_sd, #>     trunc_mean_mean, trunc_mean_sd, #>     trunc_sd_mean, trunc_sd_sd, #>     trunc_dist, 1 #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     delays_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, gt_dist, gt_weight #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0, 1]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd[1] > 0 ? gt_mean[1] : gt_mean_mean[1]); #>     real set_gt_sd = (gt_sd_sd [1]> 0 ? gt_sd[1] : gt_sd_mean[1]); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   } else { #>     // sample generation time #>     real gt_mean_sample[1]; #>     real gt_sd_sample[1]; #>     vector[gt_max[1]] gt_rev_pmf; #>  #>     gt_mean_sample[1] = (gt_mean_sd[1] > 0 ? normal_rng(gt_mean_mean[1], gt_mean_sd[1]) : gt_mean_mean[1]); #>     gt_sd_sample[1] = (gt_sd_sd[1] > 0 ? normal_rng(gt_sd_mean[1], gt_sd_sd[1]) : gt_sd_mean[1]); #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean_sample, gt_sd_sample, gt_max, gt_dist, gt_max[1], #>       1, 1 #>     ); #>  #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_rev_pmf, rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample[1], gt_sd_sample[1]); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"sampling\" #>  #> $cores #> [1] 1 #>  #> $warmup #> [1] 1000 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 24201558 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 1500 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Stan Data Required for estimate_infections — create_stan_data","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"Takes output stan_opts() converts list understood stan. Internally calls create_ family functions construct single list input stan data required present.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"","code":"create_stan_data(   reported_cases,   generation_time,   rt,   gp,   obs,   delays,   horizon,   backcalc,   shifted_cases,   truncation )"},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. generation_time call generation_time_opts() defining generation time distribution used. backwards compatibility list summary parameters can also passed. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. horizon Numeric, forecast horizon. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). shifted_cases dataframe delay shifted cases truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"list stan data","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Delay Distribution Options — delay_opts","title":"Delay Distribution Options — delay_opts","text":"Returns delay distributions formatted usage downstream functions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delay Distribution Options — delay_opts","text":"","code":"delay_opts(..., fixed = FALSE)"},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delay Distribution Options — delay_opts","text":"... list lists specifying distributions reporting delays. list passed dist_spec contain parameters linked tha functions arguments. list given assumed delay present. multiple lists given assumed independent. fixed Logical, defaults FALSE. reporting delays treated coming fixed (vs uncertain) distributions. Making simplification drastically reduces compute requirements. Setting overrides constituent delay distributions set fixed .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delay Distribution Options — delay_opts","text":"list summarising input delay distributions.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Delay Distribution Options — delay_opts","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delay Distribution Options — delay_opts","text":"","code":"# no delays delay_opts() #> $delay_mean_mean #> numeric(0) #>  #> $delay_mean_sd #> numeric(0) #>  #> $delay_sd_mean #> numeric(0) #>  #> $delay_sd_sd #> numeric(0) #>  #> $delay_fixed #> integer(0) #>  #> $delay_dist #> integer(0) #>  #> $delay_max #> integer(0) #>  #> $seeding_time #> [1] 1 #>  #> $delays #> [1] 0 #>  #> $uncertain_mean_delays #> integer(0) #>  #> $uncertain_sd_delays #> integer(0) #>  #> $fixed_delays #> integer(0) #>  #> $n_uncertain_mean_delays #> [1] 0 #>  #> $n_uncertain_sd_delays #> [1] 0 #>  #> $n_fixed_delays #> [1] 0 #>   # A single delay that has uncertainty delay <- list(mean = 1, mean_sd = 0.2, sd = 0.5, sd_sd = 0.1, max = 15) delay_opts(delay) #> $delay_mean_mean #> [1] 1 #>  #> $delay_mean_sd #> [1] 0.2 #>  #> $delay_sd_mean #> [1] 0.5 #>  #> $delay_sd_sd #> [1] 0.1 #>  #> $delay_fixed #> [1] 0 #>  #> $delay_max #> [1] 15 #>  #> $delay_dist #> [1] 0 #>  #> $seeding_time #> [1] 3 #>  #> $delays #> [1] 1 #>  #> $uncertain_mean_delays #> [1] 1 #>  #> $uncertain_sd_delays #> [1] 1 #>  #> $fixed_delays #> integer(0) #>  #> $n_uncertain_mean_delays #> [1] 1 #>  #> $n_uncertain_sd_delays #> [1] 1 #>  #> $n_fixed_delays #> [1] 0 #>   # A single delay where we override the uncertainty assumption delay_opts(delay, fixed = TRUE) #> $delay_mean_mean #> [1] 1 #>  #> $delay_mean_sd #> [1] 0 #>  #> $delay_sd_mean #> [1] 0.5 #>  #> $delay_sd_sd #> [1] 0 #>  #> $delay_fixed #> [1] 1 #>  #> $delay_max #> [1] 15 #>  #> $delay_dist #> [1] 0 #>  #> $seeding_time #> [1] 3 #>  #> $delays #> [1] 1 #>  #> $uncertain_mean_delays #> integer(0) #>  #> $uncertain_sd_delays #> integer(0) #>  #> $fixed_delays #> [1] 1 #>  #> $n_uncertain_mean_delays #> [1] 0 #>  #> $n_uncertain_sd_delays #> [1] 0 #>  #> $n_fixed_delays #> [1] 1 #>   # A delay where uncertainty is implict delay_opts(list(mean = 1, mean_sd = 0, sd = 0.5, sd_sd = 0, max = 15)) #> $delay_mean_mean #> [1] 1 #>  #> $delay_mean_sd #> [1] 0 #>  #> $delay_sd_mean #> [1] 0.5 #>  #> $delay_sd_sd #> [1] 0 #>  #> $delay_fixed #> [1] 1 #>  #> $delay_max #> [1] 15 #>  #> $delay_dist #> [1] 0 #>  #> $seeding_time #> [1] 3 #>  #> $delays #> [1] 1 #>  #> $uncertain_mean_delays #> integer(0) #>  #> $uncertain_sd_delays #> integer(0) #>  #> $fixed_delays #> [1] 1 #>  #> $n_uncertain_mean_delays #> [1] 0 #>  #> $n_uncertain_sd_delays #> [1] 0 #>  #> $n_fixed_delays #> [1] 1 #>   # Multiple delays delay_opts(delay, delay) #> $delay_mean_mean #> [1] 1 1 #>  #> $delay_mean_sd #> [1] 0.2 0.2 #>  #> $delay_sd_mean #> [1] 0.5 0.5 #>  #> $delay_sd_sd #> [1] 0.1 0.1 #>  #> $delay_fixed #> [1] 0 0 #>  #> $delay_max #> [1] 15 15 #>  #> $delay_dist #> [1] 0 0 #>  #> $seeding_time #> [1] 6 #>  #> $delays #> [1] 2 #>  #> $uncertain_mean_delays #> [1] 1 2 #>  #> $uncertain_sd_delays #> [1] 1 2 #>  #> $fixed_delays #> integer(0) #>  #> $n_uncertain_mean_delays #> [1] 2 #>  #> $n_uncertain_sd_delays #> [1] 2 #>  #> $n_fixed_delays #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"Fits integer adjusted exponential, gamma lognormal distribution using stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"","code":"dist_fit(   values = NULL,   samples = NULL,   cores = 1,   chains = 2,   dist = \"exp\",   verbose = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"values Numeric vector values samples Numeric, number samples take cores Numeric, defaults 1. Number CPU cores use (effect greater number chains). chains Numeric, defaults 2. Number MCMC chains use. better minimum two. dist Character string, distribution fit. Defaults exponential (\"exp\") bu gamma (\"gamma\") lognormal (\"lognormal\") also supported. verbose Logical, defaults FALSE. verbose progress messages printed.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"stan fit interval censored distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"","code":"# \\donttest{ # integer adjusted exponential model dist_fit(rexp(1:100, 2),   samples = 1000, dist = \"exp\",   cores = ifelse(interactive(), 4, 1), verbose = TRUE ) #>  #> SAMPLING FOR MODEL 'exp' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 3e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.3 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 1: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 1: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 1: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 1: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 1: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 1: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 1: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 1: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 1: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 1: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 1: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 1: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 1: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 1: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 1: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 1: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 1: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 1: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.079913 seconds (Warm-up) #> Chain 1:                0.079769 seconds (Sampling) #> Chain 1:                0.159682 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'exp' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 2.3e-05 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.23 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 2: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 2: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 2: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 2: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 2: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 2: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 2: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 2: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 2: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 2: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 2: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 2: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 2: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 2: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 2: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 2: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 2: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 2: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 0.077806 seconds (Warm-up) #> Chain 2:                0.072083 seconds (Sampling) #> Chain 2:                0.149889 seconds (Total) #> Chain 2:  #> Inference for Stan model: exp. #> 2 chains, each with iter=2000; warmup=1000; thin=1;  #> post-warmup draws per chain=1000, total post-warmup draws=2000. #>  #>          mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat #> lambda   2.48    0.01 0.37   1.82   2.22   2.47   2.70   3.32   940    1 #> lp__   -18.10    0.02 0.69 -20.08 -18.22 -17.83 -17.67 -17.63   905    1 #>  #> Samples were drawn using NUTS(diag_e) at Tue Jan 24 21:13:19 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1).   # integer adjusted gamma model dist_fit(rgamma(1:100, 5, 5),   samples = 1000, dist = \"gamma\",   cores = ifelse(interactive(), 4, 1), verbose = TRUE ) #>  #> SAMPLING FOR MODEL 'gamma' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000315 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 3.15 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 1: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 1: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 1: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 1: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 1: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 1: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 1: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 1: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 1: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 1: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 1: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 1: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 1: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 1: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 1: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 1: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 1: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 1: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 2.30516 seconds (Warm-up) #> Chain 1:                2.64446 seconds (Sampling) #> Chain 1:                4.94962 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'gamma' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 0.000252 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 2.52 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 2: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 2: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 2: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 2: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 2: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 2: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 2: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 2: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 2: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 2: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 2: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 2: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 2: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 2: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 2: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 2: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 2: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 2: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 2.36091 seconds (Warm-up) #> Chain 2:                2.27761 seconds (Sampling) #> Chain 2:                4.63852 seconds (Total) #> Chain 2:  #> Inference for Stan model: gamma. #> 2 chains, each with iter=2000; warmup=1000; thin=1;  #> post-warmup draws per chain=1000, total post-warmup draws=2000. #>  #>             mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat #> alpha_raw   0.83    0.03 0.55   0.04   0.39   0.76   1.18   2.10   361 1.01 #> beta_raw    1.05    0.03 0.58   0.14   0.61   0.99   1.42   2.31   391 1.00 #> alpha       6.46    0.03 0.55   5.67   6.02   6.39   6.81   7.73   361 1.01 #> beta        6.52    0.03 0.58   5.61   6.08   6.46   6.89   7.78   391 1.00 #> mu          0.99    0.00 0.07   0.86   0.94   0.99   1.04   1.15  1096 1.00 #> sigma       0.39    0.00 0.03   0.34   0.37   0.39   0.41   0.44   671 1.00 #> lp__      -12.57    0.09 1.42 -16.26 -13.16 -12.16 -11.47 -11.05   236 1.01 #>  #> Samples were drawn using NUTS(diag_e) at Tue Jan 24 21:13:28 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1).  # integer adjusted lognormal model dist_fit(rlnorm(1:100, log(5), 0.2),   samples = 1000, dist = \"lognormal\",   cores = ifelse(interactive(), 4, 1), verbose = TRUE ) #>  #> SAMPLING FOR MODEL 'lnorm' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 4.1e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.41 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 1: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 1: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 1: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 1: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 1: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 1: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 1: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 1: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 1: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 1: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 1: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 1: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 1: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 1: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 1: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 1: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 1: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 1: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.195868 seconds (Warm-up) #> Chain 1:                0.16933 seconds (Sampling) #> Chain 1:                0.365198 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'lnorm' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 3.7e-05 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.37 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 2: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 2: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 2: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 2: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 2: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 2: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 2: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 2: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 2: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 2: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 2: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 2: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 2: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 2: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 2: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 2: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 2: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 2: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 0.189494 seconds (Warm-up) #> Chain 2:                0.194106 seconds (Sampling) #> Chain 2:                0.3836 seconds (Total) #> Chain 2:  #> Inference for Stan model: lnorm. #> 2 chains, each with iter=2000; warmup=1000; thin=1;  #> post-warmup draws per chain=1000, total post-warmup draws=2000. #>  #>         mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat #> mu      1.60    0.00 0.02   1.56   1.59   1.60   1.62   1.64  1184    1 #> sigma   0.15    0.00 0.02   0.12   0.13   0.14   0.16   0.18  1128    1 #> lp__  -64.26    0.03 0.99 -66.85 -64.68 -63.95 -63.54 -63.26   866    1 #>  #> Samples were drawn using NUTS(diag_e) at Tue Jan 24 21:13:29 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1). # }"},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":null,"dir":"Reference","previous_headings":"","what":"Distribution Skeleton — dist_skel","title":"Distribution Skeleton — dist_skel","text":"function acts skeleton truncated distribution defined model type, maximum value model parameters. designed used output get_dist.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distribution Skeleton — dist_skel","text":"","code":"dist_skel(n, dist = FALSE, cum = TRUE, model, params, max_value = 120)"},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distribution Skeleton — dist_skel","text":"n Numeric vector, number samples take (days probability density). dist Logical, defaults FALSE. probability density returned rather number samples. cum Logical, defaults TRUE. dist = TRUE returned distribution cumulative. model Character string, defining model used. Supported options exponential (\"exp\"), gamma (\"gamma\"), log normal (\"lognorm\") params list parameters values (name) required model. exponential model rate parameter gamma model alpha beta. max_value Numeric, maximum value allow. Defaults 120. Samples outside range resampled.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distribution Skeleton — dist_skel","text":"vector samples probability distribution.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distribution Skeleton — dist_skel","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distribution Skeleton — dist_skel","text":"","code":"## Exponential model # sample dist_skel(10, model = \"exp\", params = list(rate = 1)) #>  [1] 0 0 0 0 0 0 1 0 0 0  # cumulative prob density dist_skel(1:10, model = \"exp\", dist = TRUE, params = list(rate = 1)) #>  [1] 0.6321206 0.8646647 0.9502129 0.9816844 0.9932621 0.9975212 0.9990881 #>  [8] 0.9996645 0.9998766 0.9999546  # probability density dist_skel(1:10,   model = \"exp\", dist = TRUE,   cum = FALSE, params = list(rate = 1) ) #>  [1] 2.325442e-01 8.554821e-02 3.147143e-02 1.157769e-02 4.259195e-03 #>  [6] 1.566870e-03 5.764193e-04 2.120528e-04 7.800987e-05 2.869823e-05  ## Gamma model # sample dist_skel(10, model = \"gamma\", params = list(alpha = 1, beta = 2)) #>  [1] 0 0 0 0 1 0 0 0 0 0  # cumulative prob density dist_skel(0:10,   model = \"gamma\", dist = TRUE,   params = list(alpha = 1, beta = 2) ) #>  [1] 0.0000000 0.8646647 0.9816844 0.9975212 0.9996645 0.9999546 0.9999939 #>  [8] 0.9999992 0.9999999 1.0000000 1.0000000  # probability density dist_skel(0:10,   model = \"gamma\", dist = TRUE,   cum = FALSE, params = list(alpha = 2, beta = 2) ) #>  [1] 5.939942e-01 3.144277e-01 7.422693e-02 1.433210e-02 2.519764e-03 #>  [6] 4.195245e-04 6.740183e-05 1.055983e-05 1.623728e-06 2.460854e-07 #> [11] 3.686845e-08  ## Log normal model # sample dist_skel(10, model = \"lognorm\", params = list(mean = log(5), sd = log(2))) #>  [1]  3  3  2  2  7 13 14  5 13  4  # cumulative prob density dist_skel(0:10,   model = \"lognorm\", dist = TRUE,   params = list(mean = log(5), sd = log(2)) ) #>  [1] 0.00000000 0.01011843 0.09309626 0.23057216 0.37375443 0.50000114 #>  [7] 0.60373934 0.68631476 0.75113865 0.80178197 0.84134666  # probability density dist_skel(0:10,   model = \"lognorm\", dist = TRUE, cum = FALSE,   params = list(mean = log(5), sd = log(2)) ) #>  [1] 0.01011843 0.08297783 0.13747590 0.14318227 0.12624670 0.10373821 #>  [7] 0.08257541 0.06482390 0.05064332 0.03956468 0.03099140"},{"path":"epiforecasts.io/EpiNow2/reference/dist_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify a distribution. — dist_spec","title":"Specify a distribution. — dist_spec","text":"Defines parameters suported distribution use onward modelling. Multiple distribution families supported - see documentation family details. function provides distribution functionality delay_opts(), generation_time_opts(), trunc_opts().","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify a distribution. — dist_spec","text":"","code":"dist_spec(   mean,   sd = 0,   mean_sd = 0,   sd_sd = 0,   dist = c(\"lognormal\", \"gamma\"),   max = NULL,   fixed = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/dist_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify a distribution. — dist_spec","text":"mean Numeric. non-zero summary parameter fixed interval distribution. sd non-zero mean distribution given dist. given vector empty vectors returned. sd Numeric, defaults 0. Sets standard deviation distribution. mean_sd Numeric, defaults 0. Sets standard deviation uncertainty around mean  distribution assuming normal prior. sd_sd Numeric, defaults 0. Sets standard deviation uncertainty around sd  distribution assuming normal prior. dist Character, defaults \"lognormal\". (discretised distribution used. sd == 0 distribution  fixed delta function used. sd > 0 distribution discretised truncated. following distributions currently supported: \"lognormal\" - lognormal distribution. distribution mean mean natural logarithm delay (log scale) sd standard deviation natural logarithm delay. \"gamma\" - gamma distribution. distribution mean mean delay sd standard deviation delay. model fitting transformed shape scale gamma distribution. dist default lognormal distribution function arguments following definition: mean mean natural logarithm delay (log scale). sd standard deviation natural logarithm delay. max Numeric, maximum value distribution. distribution truncated value. fixed Logical, defaults FALSE. delays treated coming fixed (vs uncertain) distributions. Making simplification reduces compute requirement may produce spuriously precise estimates.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify a distribution. — dist_spec","text":"list distribution options.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_spec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Specify a distribution. — dist_spec","text":"Sebastian Funk Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":null,"dir":"Reference","previous_headings":"","what":"Real-time Rt Estimation, Forecasting and Reporting — epinow","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"function wraps functionality estimate_infections() forecast_infections() orde estimate Rt cases date infection, forecast infections future. also contains additional functionality convert forecasts date report produc summary output useful reporting results interpreting . See example using epinow estimate Rt Covid-19 country ECDC data source.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"","code":"epinow(   reported_cases,   generation_time = NULL,   delays = delay_opts(),   truncation = trunc_opts(),   rt = rt_opts(),   backcalc = backcalc_opts(),   gp = gp_opts(),   obs = obs_opts(),   stan = stan_opts(),   horizon = 7,   CrIs = c(0.2, 0.5, 0.9),   filter_leading_zeros = TRUE,   zero_threshold = Inf,   return_output = FALSE,   output = c(\"samples\", \"plots\", \"latest\", \"fit\", \"timing\"),   plot_args = list(),   target_folder = NULL,   target_date,   logs = tempdir(),   id = \"epinow\",   verbose = interactive() )"},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. generation_time call generation_time_opts() defining generation time distribution used. backwards compatibility list summary parameters can also passed. delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. horizon Numeric, defaults 7. Number days future forecast. CrIs Numeric vector credible intervals calculate. filter_leading_zeros Logical, defaults TRUE. zeros start time series filtered . zero_threshold Numeric defaults Inf. Indicates detected zero cases meaningful using threshold number cases based 7 day average. average threshold zero replaced backwards looking rolling average. set infinity changes made. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. output character vector optional output return. Supported options samples (\"samples\"), plots (\"plots\"), run time (\"timing\"), copying dated folder latest folder (target_folder null, set using \"latest\"), stan fit (\"fit\"). default return options. plot_args list optional arguments passed plot.epinow(). target_folder Character string specifying save results (create present). target_date Date, defaults maximum found data specified. logs Character path indicating target folder store log information. Defaults temporary directory specified. Default logging can disabled logs set NULL. specifying custom logging setup code setup_default_logging setup_logging function sensible place start. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching. verbose Logical, defaults TRUE used interactively otherwise FALSE. verbose debug progress messages printed. Corresponds \"DEBUG\" level futile.logger. See setup_logging detailed logging options.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"list output estimate_infections, forecast_infections, report_cases, report_summary.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1)) # construct example distributions generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1),   mean_sd = 0.1,   sd = convert_to_logsd(2, 1),   sd_sd = 0.1,   max = 10 )  # example case data reported_cases <- example_confirmed[1:40]  # estimate Rt and nowcast/forecast cases by date of infection out <- epinow(   reported_cases = reported_cases, generation_time = generation_time,   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   delays = delay_opts(incubation_period, reporting_delay) ) #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpfR2b3X/regional-epinow/2020-04-01.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to the console and: /tmp/RtmpfR2b3X/epinow/2020-04-01.log #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> Error in dimnames(x)$parameters: $ operator is invalid for atomic vectors # summary of the latest estimates summary(out) #> Error in summary(out): object 'out' not found # plot estimates plot(out) #> Error in plot(out): object 'out' not found  # summary of R estimates summary(out, type = \"parameters\", params = \"R\") #> Error in summary(out, type = \"parameters\", params = \"R\"): object 'out' not found  options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate a Delay Distribution — estimate_delay","title":"Estimate a Delay Distribution — estimate_delay","text":"Estimate log normal delay distribution vector integer delays. Currently function simple wrapper bootstrapped_dist_fit.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate a Delay Distribution — estimate_delay","text":"","code":"estimate_delay(delays, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate a Delay Distribution — estimate_delay","text":"delays Integer vector delays ... Arguments pass internal methods.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate a Delay Distribution — estimate_delay","text":"list summarising bootstrapped distribution","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate a Delay Distribution — estimate_delay","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate a Delay Distribution — estimate_delay","text":"","code":"# \\donttest{ delays <- rlnorm(500, log(5), 1) estimate_delay(delays, samples = 1000, bootstraps = 10) #> $mean #> [1] 1.394596 #>  #> $mean_sd #> [1] 0.08829213 #>  #> $sd #> [1] 1.046682 #>  #> $sd_sd #> [1] 0.08369138 #>  #> $max #> [1] 114 #>  # }"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"Uses non-parametric approach reconstruct cases date infection reported cases. uses either generative Rt model non-parametric back calculation estimate underlying latent infections maps infections observed cases via uncertain reporting delays flexible observation model. See examples function arguments details options. default settings may sufficient use case number warmup samples (stan_args = list(warmup)) may need increased may overall number samples. Follow links provided warnings messages diagnose issues MCMC fit. recommended explore several Rt estimation approaches supported may suited users use cases. See example using estimate_infections within epinow wrapper estimate Rt Covid-19 country ECDC data source.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"","code":"estimate_infections(   reported_cases,   generation_time = generation_time_opts(),   delays = delay_opts(),   truncation = trunc_opts(),   rt = rt_opts(),   backcalc = backcalc_opts(),   gp = gp_opts(),   obs = obs_opts(),   stan = stan_opts(),   horizon = 7,   CrIs = c(0.2, 0.5, 0.9),   filter_leading_zeros = TRUE,   zero_threshold = Inf,   id = \"estimate_infections\",   verbose = interactive() )"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. generation_time call generation_time_opts() defining generation time distribution used. backwards compatibility list summary parameters can also passed. delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. horizon Numeric, defaults 7. Number days future forecast. CrIs Numeric vector credible intervals calculate. filter_leading_zeros Logical, defaults TRUE. zeros start time series filtered . zero_threshold Numeric defaults Inf. Indicates detected zero cases meaningful using threshold number cases based 7 day average. average threshold zero replaced backwards looking rolling average. set infinity changes made. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching. verbose Logical, defaults TRUE used interactively otherwise FALSE. verbose debug progress messages printed. Corresponds \"DEBUG\" level futile.logger. See setup_logging detailed logging options.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"list output including: posterior samples, summarised posterior samples, data used fit model, fit object .","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # get example case counts reported_cases <- example_confirmed[1:60]  # set up example generation time generation_time <- generation_time_opts(  disease = \"SARS-CoV-2\", source = \"ganyani\", fixed = TRUE ) # set delays between infection and case report incubation_period <- get_incubation_period(  disease = \"SARS-CoV-2\", source = \"lauer\" ) reporting_delay <- list(   mean = convert_to_logmean(2, 1), mean_sd = 0,   sd = convert_to_logsd(2, 1), sd_sd = 0, max = 10 )  # default settings but assuming that delays are fixed rather than uncertain def <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay, fixed = TRUE),   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   stan = stan_opts(control = list(adapt_delta = 0.95)) ) #> Warning: There were 5 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems # real time estimates summary(def) #>                                  measure                estimate #> 1: New confirmed cases by infection date     2201 (1143 -- 4096) #> 2:        Expected change in daily cases       Likely decreasing #> 3:            Effective reproduction no.      0.86 (0.62 -- 1.2) #> 4:                        Rate of growth -0.038 (-0.11 -- 0.042) #> 5:          Doubling/halving time (days)        -18 (17 -- -6.2) # summary plot plot(def)   # decreasing the accuracy of the approximate Gaussian to speed up computation. # These settings are an area of active research. See ?gp_opts for details. agp <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay, fixed = TRUE),   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   gp = gp_opts(ls_min = 10, basis_prop = 0.1),   stan = stan_opts(control = list(adapt_delta = 0.95)) ) #> Warning: There were 7 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems summary(agp) #>                                  measure                estimate #> 1: New confirmed cases by infection date     2314 (1233 -- 4022) #> 2:        Expected change in daily cases       Likely decreasing #> 3:            Effective reproduction no.      0.88 (0.63 -- 1.1) #> 4:                        Rate of growth -0.033 (-0.11 -- 0.038) #> 5:          Doubling/halving time (days)        -21 (18 -- -6.4) plot(agp)   # Adjusting for future susceptible depletion dep <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay, fixed = TRUE),   rt = rt_opts(     prior = list(mean = 2, sd = 0.1),     pop = 1000000, future = \"latest\"   ),   gp = gp_opts(ls_min = 10, basis_prop = 0.1), horizon = 21,   stan = stan_opts(control = list(adapt_delta = 0.95)) ) #> Warning: There were 12 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems plot(dep)   # Adjusting for truncation of the most recent data # See estimate_truncation for an approach to estimating this from data trunc_dist <- trunc_opts(dist = list(    mean = convert_to_logmean(0.5, 0.5), mean_sd = 0.1,    sd = convert_to_logsd(0.5, 0.5), sd_sd = 0.1,    max = 3  ) ) trunc <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay, fixed = TRUE),   truncation = trunc_dist,   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   gp = gp_opts(ls_min = 10, basis_prop = 0.1),   stan = stan_opts(control = list(adapt_delta = 0.95)) ) #> Warning: There were 1928 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems #> Warning: The largest R-hat is 1.76, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess plot(trunc)   # using back calculation (combined here with under reporting) # this model is in the order of 10 ~ 100 faster than the gaussian process # method # it is likely robust for retrospective Rt but less reliable for real time # estimates # the width of the prior window controls the reliance on observed data and # can be optionally switched off using backcalc_opts(prior = \"none\"), # see ?backcalc_opts for other options backcalc <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay, fixed = TRUE),   rt = NULL, backcalc = backcalc_opts(),   obs = obs_opts(scale = list(mean = 0.4, sd = 0.05)),   horizon = 0 ) plot(backcalc)   # Rt projected into the future using the Gaussian process project_rt <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay, fixed = TRUE),   rt = rt_opts(     prior = list(mean = 2, sd = 0.1),     future = \"project\"   ) ) #> Warning: There were 14 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess plot(project_rt)   # default settings on a later snapshot of data snapshot_cases <- example_confirmed[80:130] snapshot <- estimate_infections(snapshot_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay, fixed = TRUE),   rt = rt_opts(prior = list(mean = 1, sd = 0.1)) ) #> Warning: There were 7 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess plot(snapshot)   # stationary Rt assumption (likely to provide biased real-time estimates) # with uncertain reporting delays stat <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1), gp_on = \"R0\") ) plot(stat)   # no gaussian process (i.e fixed Rt assuming no breakpoints) # with uncertain reporting delays fixed <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   gp = NULL ) plot(fixed)   # no delays no_delay <- estimate_infections(reported_cases, generation_time = generation_time) #> Warning: There were 11 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems plot(no_delay)   # break point but otherwise static Rt # with uncertain reporting delays bp_cases <- data.table::copy(reported_cases) bp_cases <- bp_cases[, breakpoint := ifelse(date == as.Date(\"2020-03-16\"), 1, 0)] bkp <- estimate_infections(bp_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   gp = NULL ) # break point effect summary(bkp, type = \"parameters\", params = \"breakpoints\") #>    date    variable strat type     median       mean         sd   lower_90 #> 1: <NA> breakpoints     1 <NA> -0.6564691 -0.6570471 0.02531694 -0.6984013 #>      lower_50   lower_20   upper_20   upper_50   upper_90 #> 1: -0.6737741 -0.6627833 -0.6505058 -0.6403915 -0.6143719 plot(bkp)   # weekly random walk # with uncertain reporting delays rw <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1), rw = 7),   gp = NULL )  # random walk effects summary(rw, type = \"parameters\", params = \"breakpoints\") #>    date    variable strat type      median        mean         sd   lower_90 #> 1: <NA> breakpoints     1 <NA> -0.12582946 -0.12815207 0.06675518 -0.2421135 #> 2: <NA> breakpoints     2 <NA> -0.14910253 -0.14826445 0.08074447 -0.2790339 #> 3: <NA> breakpoints     3 <NA> -0.21334207 -0.21589626 0.08705577 -0.3578994 #> 4: <NA> breakpoints     4 <NA> -0.29334932 -0.29359367 0.09290919 -0.4485432 #> 5: <NA> breakpoints     5 <NA> -0.06717593 -0.06183288 0.09648055 -0.2212360 #> 6: <NA> breakpoints     6 <NA>  0.04792154  0.05193018 0.10019039 -0.1084141 #> 7: <NA> breakpoints     7 <NA> -0.06719907 -0.07029738 0.11149115 -0.2517603 #> 8: <NA> breakpoints     8 <NA> -0.02693395 -0.02816943 0.18236343 -0.3306411 #>       lower_50    lower_20    upper_20     upper_50    upper_90 #> 1: -0.17258097 -0.14320882 -0.11203364 -0.082722208 -0.02066878 #> 2: -0.20269935 -0.16662862 -0.12743212 -0.095914080 -0.01892783 #> 3: -0.27301776 -0.23621611 -0.19335806 -0.157825096 -0.07795397 #> 4: -0.35304037 -0.31417328 -0.27043256 -0.233352546 -0.14185234 #> 5: -0.12575962 -0.08790910 -0.04023543  0.002652400  0.09384088 #> 6: -0.01169444  0.02759016  0.07093774  0.116558764  0.21818056 #> 7: -0.14358056 -0.09768137 -0.04036403  0.002999406  0.11013563 #> 8: -0.13205546 -0.06747388  0.01852860  0.086348166  0.25910918 plot(rw)   options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"Estimates relationship primary secondary observation, example hospital admissions deaths hospital admissions bed occupancy. See secondary_opts() model structure options. See parameter documentation model defaults options. See examples case studies using synthetic data example forecasting Covid-19 deaths Covid-19 cases. See prototype function may used estimate forecast secondary observation primary across multiple regions application forecasting Covid-19 deaths Germany Poland.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"","code":"estimate_secondary(   reports,   secondary = secondary_opts(),   delays = delay_opts(list(mean = 2.5, mean_sd = 0.5, sd = 0.47, sd_sd = 0.25, max = 30)),   truncation = trunc_opts(),   obs = obs_opts(),   burn_in = 14,   CrIs = c(0.2, 0.5, 0.9),   priors = NULL,   model = NULL,   verbose = interactive(),   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"reports data frame containing date report primary secondary reports. secondary call secondary_opts() list containing following  binary variables: cumulative, historic, primary_hist_additive, current, primary_current_additive. parameters control structure secondary model, see secondary_opts() details. delays call delay_opts() defining delay distributions primary secondary observations See documentation delay_opts() details. default diffuse prior  assumed mean 14 days standard deviation 7 days (standard deviation 0.5 0.25 respectively log scale). truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). burn_in Integer, defaults 14 days. number data points use estimation fit beginning time series. must less number observations. CrIs Numeric vector credible intervals calculate. priors data.frame named priors used model fitting rather defaults supplied arguments. typically useful wanting inform estimate posterior another model fit. model compiled stan model override default model. May useful package developers developing extensions. verbose Logical, model fitting progress returned. Defaults interactive(). ... Additional parameters pass rstan::sampling.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"list containing: predictions (data frame ordered date primary, secondary observations, summary model estimated secondary observations), posterior contains summary entire model posterior, data (list data used fit model), fit (stanfit object).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # load data.table for manipulation library(data.table)  #### Incidence data example ####  # make some example secondary incidence data cases <- example_confirmed cases <- as.data.table(cases)[, primary := confirm] # Assume that only 40 percent of cases are reported cases[, scaling := 0.4] #>            date confirm primary scaling #>   1: 2020-02-22      14      14     0.4 #>   2: 2020-02-23      62      62     0.4 #>   3: 2020-02-24      53      53     0.4 #>   4: 2020-02-25      97      97     0.4 #>   5: 2020-02-26      93      93     0.4 #>  ---                                    #> 126: 2020-06-26     296     296     0.4 #> 127: 2020-06-27     255     255     0.4 #> 128: 2020-06-28     175     175     0.4 #> 129: 2020-06-29     174     174     0.4 #> 130: 2020-06-30     126     126     0.4 # Parameters of the assumed log normal delay distribution cases[, meanlog := 1.8][, sdlog := 0.5] #>            date confirm primary scaling meanlog sdlog #>   1: 2020-02-22      14      14     0.4     1.8   0.5 #>   2: 2020-02-23      62      62     0.4     1.8   0.5 #>   3: 2020-02-24      53      53     0.4     1.8   0.5 #>   4: 2020-02-25      97      97     0.4     1.8   0.5 #>   5: 2020-02-26      93      93     0.4     1.8   0.5 #>  ---                                                  #> 126: 2020-06-26     296     296     0.4     1.8   0.5 #> 127: 2020-06-27     255     255     0.4     1.8   0.5 #> 128: 2020-06-28     175     175     0.4     1.8   0.5 #> 129: 2020-06-29     174     174     0.4     1.8   0.5 #> 130: 2020-06-30     126     126     0.4     1.8   0.5  # Simulate secondary cases cases <- simulate_secondary(cases, type = \"incidence\") # fit model to example data specifying a weak prior for fraction reported # with a secondary case inc <- estimate_secondary(cases[1:60],   obs = obs_opts(scale = list(mean = 0.2, sd = 0.2), week_effect = FALSE) ) plot(inc, primary = TRUE)   # forecast future secondary cases from primary inc_preds <- forecast_secondary(inc, cases[61:.N][, value := primary]) plot(inc_preds, new_obs = cases, from = \"2020-05-01\")   #### Prevalence data example ####  # make some example prevalence data cases <- example_confirmed cases <- as.data.table(cases)[, primary := confirm] # Assume that only 30 percent of cases are reported cases[, scaling := 0.3] #>            date confirm primary scaling #>   1: 2020-02-22      14      14     0.3 #>   2: 2020-02-23      62      62     0.3 #>   3: 2020-02-24      53      53     0.3 #>   4: 2020-02-25      97      97     0.3 #>   5: 2020-02-26      93      93     0.3 #>  ---                                    #> 126: 2020-06-26     296     296     0.3 #> 127: 2020-06-27     255     255     0.3 #> 128: 2020-06-28     175     175     0.3 #> 129: 2020-06-29     174     174     0.3 #> 130: 2020-06-30     126     126     0.3 # Parameters of the assumed log normal delay distribution cases[, meanlog := 1.6][, sdlog := 0.8] #>            date confirm primary scaling meanlog sdlog #>   1: 2020-02-22      14      14     0.3     1.6   0.8 #>   2: 2020-02-23      62      62     0.3     1.6   0.8 #>   3: 2020-02-24      53      53     0.3     1.6   0.8 #>   4: 2020-02-25      97      97     0.3     1.6   0.8 #>   5: 2020-02-26      93      93     0.3     1.6   0.8 #>  ---                                                  #> 126: 2020-06-26     296     296     0.3     1.6   0.8 #> 127: 2020-06-27     255     255     0.3     1.6   0.8 #> 128: 2020-06-28     175     175     0.3     1.6   0.8 #> 129: 2020-06-29     174     174     0.3     1.6   0.8 #> 130: 2020-06-30     126     126     0.3     1.6   0.8  # Simulate secondary cases cases <- simulate_secondary(cases, type = \"prevalence\")  # fit model to example prevalence data prev <- estimate_secondary(cases[1:100],   secondary = secondary_opts(type = \"prevalence\"),   obs = obs_opts(     week_effect = FALSE,     scale = list(mean = 0.4, sd = 0.1)   ) ) plot(prev, primary = TRUE)   # forecast future secondary cases from primary prev_preds <- forecast_secondary(prev, cases[101:.N][, value := primary]) plot(prev_preds, new_obs = cases, from = \"2020-06-01\")   options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Truncation of Observed Data — estimate_truncation","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"Estimates truncation distribution multiple snapshots data source time. distribution can used regional_epinow, epinow, estimate_infections adjust truncated data. See example using approach Covid-19 data England. functionality offered function now available principled manner epinowcast R package. model truncation follows: truncation distribution assumed discretised log normal wit mean standard deviation informed data. data set latest observations adjusted truncation using truncation distribution. Earlier data sets recreated applying truncation distribution adjusted latest observations time period earlier data set. data sets compared earlier observations assuming negative binomial observation model additive noise term deal zero observations. model fit using stan standard normal, half normal, prior mean, standard deviation, 1 square root dispersionn additive noise term. approach assumes : Current truncation related past truncation. Truncation multiplicative scaling underlying reported cases. Truncation log normally distributed.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"","code":"estimate_truncation(   obs,   max_truncation,   trunc_max = 10,   trunc_dist = c(\"lognormal\"),   model = NULL,   CrIs = c(0.2, 0.5, 0.9),   verbose = TRUE,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"obs list data frames containing date variable confirm (integer) variable. data set snapshot reported data time. data sets must contain complete vector dates. max_truncation Deprecated; use trunc_max instead. trunc_max Integer, defaults 10. Maximum number days include truncation distribution. trunc_dist Character, defaults \"lognormal\". parametric distribution used truncation. model compiled stan model override default model. May useful package developers developing extensions. CrIs Numeric vector credible intervals calculate. verbose Logical, model fitting progress returned. ... Additional parameters pass rstan::sampling.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"list containing: summary parameters truncation distribution (dist), estimated CMF truncation distribution (cmf, can used adjusted new data), data frame containing observed truncated data, latest observed data adjusted truncation observations (obs), data frame containing last observed data (last_obs, useful plotting validation), data used fitting (data) fit object (fit).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"","code":"# set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # get example case counts reported_cases <- example_confirmed[1:60]  # define example truncation distribution (note not integer adjusted) trunc <- list(   mean = convert_to_logmean(3, 2),   mean_sd = 0.1,   sd = convert_to_logsd(3, 2),   sd_sd = 0.1,   max = 10 )  # apply truncation to example data construct_truncation <- function(index, cases, dist) {   set.seed(index)   cmf <- cumsum(     dlnorm(       1:(dist$max + 1),       rnorm(1, dist$mean, dist$mean_sd),       rnorm(1, dist$sd, dist$sd_sd)     )   )   cmf <- cmf / cmf[dist$max + 1]   cmf <- rev(cmf)[-1]   trunc_cases <- data.table::copy(cases)[1:(.N - index)]   trunc_cases[(.N - length(cmf) + 1):.N, confirm := as.integer(confirm * cmf)]   return(trunc_cases) } example_data <- purrr::map(c(20, 15, 10, 0),   construct_truncation,   cases = reported_cases,   dist = trunc )  # fit model to example data est <- estimate_truncation(example_data,   verbose = interactive(),   chains = 2, iter = 2000 ) #> Error in check_pars(allpars, pars): no parameter cmf  # summary of the distribution est$dist #> Error in eval(expr, envir, enclos): object 'est' not found # summary of the estimated truncation cmf (can be applied to new data) print(est$cmf) #> Error in print(est$cmf): object 'est' not found # observations linked to truncation adjusted estimates print(est$obs) #> Error in print(est$obs): object 'est' not found # validation plot of observations vs estimates plot(est) #> Error in plot(est): object 'est' not found  options(old_opts)"},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Cases by Report Date — estimates_by_report_date","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"Either extracts converts reported cases input data table. output estimate_infections simple filtering step.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"","code":"estimates_by_report_date(   estimates,   CrIs = c(0.2, 0.5, 0.9),   target_folder = NULL,   samples = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"estimates List data frames output estimate_infections CrIs Numeric vector credible intervals calculate. target_folder Character string specifying save results (create present). samples Logical, defaults TRUE. samples saved","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"list samples summarised estimates estimated cases date report.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/example_confirmed.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Confirmed Case Data Set — example_confirmed","title":"Example Confirmed Case Data Set — example_confirmed","text":"example data frame observed cases","code":""},{"path":"epiforecasts.io/EpiNow2/reference/example_confirmed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Confirmed Case Data Set — example_confirmed","text":"","code":"example_confirmed"},{"path":"epiforecasts.io/EpiNow2/reference/example_confirmed.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Confirmed Case Data Set — example_confirmed","text":"data frame containing cases reported date.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/expose_stan_fns.html","id":null,"dir":"Reference","previous_headings":"","what":"Expose internal package stan functions in R — expose_stan_fns","title":"Expose internal package stan functions in R — expose_stan_fns","text":"function exposes internal stan functions R user supplied list target files. Allows testing stan functions R potentially user use R code.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/expose_stan_fns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expose internal package stan functions in R — expose_stan_fns","text":"","code":"expose_stan_fns(files, target_dir, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/expose_stan_fns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expose internal package stan functions in R — expose_stan_fns","text":"files character vector indicating target files target_dir character string indicating target directory file ... Additional arguments passed rstan::expose_stan_functions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/expose_stan_fns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expose internal package stan functions in R — expose_stan_fns","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Credible Intervals Present — extract_CrIs","title":"Extract Credible Intervals Present — extract_CrIs","text":"Helper function extract credible intervals present data frame.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Credible Intervals Present — extract_CrIs","text":"","code":"extract_CrIs(summarised)"},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Credible Intervals Present — extract_CrIs","text":"summarised data frame processed calc_CrIs","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Credible Intervals Present — extract_CrIs","text":"numeric vector credible intervals detected data frame.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Credible Intervals Present — extract_CrIs","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") summarised <- calc_CrIs(samples,   summarise_by = \"type\",   CrIs = c(seq(0.05, 0.95, 0.05)) ) extract_CrIs(summarised) #>  [1] 95 90 85 80 75 70 65 60 55 50 45 40 35 30 25 20 15 10  5"},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate initial conditions from a Stan fit — extract_inits","title":"Generate initial conditions from a Stan fit — extract_inits","text":"Extracts posterior samples use initialise full model fit. may useful certain data sets sampler gets stuck easily initialised. estimate_infections(), epinow() \\ regional_epinow() option can engaged setting stan_opts(init_fit = <stanfit>). implementation based approach taken epidemia authored James Scott.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate initial conditions from a Stan fit — extract_inits","text":"","code":"extract_inits(fit, current_inits, exclude_list = NULL, samples = 50)"},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate initial conditions from a Stan fit — extract_inits","text":"fit stanfit object. current_inits function returns list initial conditions (create_initial_conditions()). used exclude_list specified. exclude_list character vector parameters initialise fit object, defaulting NULL. samples Numeric, defaults 50. Number posterior samples.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate initial conditions from a Stan fit — extract_inits","text":"function called returns set initial conditions named list.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate initial conditions from a Stan fit — extract_inits","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Samples for a Parameter from a Stan model — extract_parameter","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"Extracts single list stan output returns data.table.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"","code":"extract_parameter(param, samples, dates)"},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"param Character string indicating parameter extract samples Extracted stan model (using rstan::extract) dates vector identifying dimensionality parameter extract. Generally date.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"data frame containing parameter name, date, sample id sample value.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"Extracts custom set parameters stan object adds stratification dates appropriate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"","code":"extract_parameter_samples(   stan_fit,   data,   reported_dates,   reported_inf_dates,   drop_length_1 = FALSE,   merge = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"stan_fit fit Stan model returned rstan:sampling. data list data supplied rstan::sampling call. reported_dates vector dates report estimates . reported_inf_dates vector dates report infection estimates . drop_length_1 Logical; whether first dimension dropped length 1; necessary processing simulation results. merge TRUE, merge samples data parameters can extracted data.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"list dataframes containing posterior parameter","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a Parameter Summary from a Stan Object — extract_stan_param","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"Extracts summarised parameter posteriors stanfit object using rstan::summary format consistent summary functions EpiNow2.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"","code":"extract_stan_param(   fit,   params = NULL,   CrIs = c(0.2, 0.5, 0.9),   var_names = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"fit stanfit objec. params character vector parameters extract. Defaults parameters. CrIs Numeric vector credible intervals calculate. var_names Logical defaults FALSE. variables named. Automatically set TRUE multiple parameters extracted.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"data.table summarising parameter posteriors. Contains following variables: variable, mean, mean_se, sd, median, lower_, upper_ followed credible interval labels indicating credible intervals present.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"Extract Samples Parameter Single Dimension","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"","code":"extract_static_parameter(param, samples)"},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"param Character string indicating parameter extract samples Extracted stan model (using rstan::extract)","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"data frame containing parameter name, sample id sample value","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/filter_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter Options for a Target Region — filter_opts","title":"Filter Options for a Target Region — filter_opts","text":"helper function allows selection region specific settings present otherwise applies overarching settings","code":""},{"path":"epiforecasts.io/EpiNow2/reference/filter_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter Options for a Target Region — filter_opts","text":"","code":"filter_opts(opts, region)"},{"path":"epiforecasts.io/EpiNow2/reference/filter_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter Options for a Target Region — filter_opts","text":"opts Either list calls _opts() function single call _opts() function. region character string indicating region interest.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/filter_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter Options for a Target Region — filter_opts","text":"list options","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"Fits stan model using rstan::sampling. Provides optional ability run chains using future error catching, timeouts merging completed chains.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"","code":"fit_model_with_nuts(   args,   future = FALSE,   max_execution_time = Inf,   id = \"stan\" )"},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"args List stan arguments. future Logical, defaults FALSE. future used run stan chains parallel. max_execution_time Numeric, defaults Inf. maximum execution time per chain seconds. Results still returned long least 2 chains complete successfully within timelimit. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"stan model object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Stan Model using Variational Inference — fit_model_with_vb","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"Fits stan model using variational inference.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"","code":"fit_model_with_vb(args, future = FALSE, id = \"stan\")"},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"args List stan arguments. future Logical, defaults FALSE. future used run stan chains parallel. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"stan model object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"function forecasts secondary observations using output estimate_secondary() either observed primary data forecast primary observations. See examples estimate_secondary() one use case. can also combined estimate_infections() t produce forecast secondary observation forecast primary observation. See examples estimate_secondary() example use cases synthetic data. See example forecasting Covid-19 deaths Covid-19 cases.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"","code":"forecast_secondary(   estimate,   primary,   primary_variable = \"reported_cases\",   model = NULL,   samples = NULL,   all_dates = FALSE,   CrIs = c(0.2, 0.5, 0.9) )"},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"estimate object class \"estimate_secondary\" produced estimate_secondary(). primary data.frame containing least date value (integer) variables optionally sample. Used primary observation used forecast secondary observations. Alternatively, may object class \"estimate_infections\" produced estimate_infections(). primary class \"estimate_infections\" internal samples filtered minimum date ahead observed estimate object. primary_variable character string indicating primary variable, defaulting \"reported_cases\". used primary class \"estimate_infections\". model compiled stan model returned rstan::stan_model. samples Numeric, number posterior samples simulate . default use samples primary input present. present default use 1000 samples. all_dates Logical, defaults FALSE. forecast dates just forecast horizon returned. CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"list containing: predictions (data frame ordered date primary, secondary observations, summary forecast secondary observations. primary observations forecast horizon uncertainty present median used), samples data frame forecast secondary observation posterior samples, forecast summary forecast secondary observation posterior.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Format Posterior Samples — format_fit","title":"Format Posterior Samples — format_fit","text":"Summaries posterior samples adds additional custom variables.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format Posterior Samples — format_fit","text":"","code":"format_fit(posterior_samples, horizon, shift, burn_in, start_date, CrIs)"},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format Posterior Samples — format_fit","text":"posterior_samples list posterior samples returned extract_parameter_samples. horizon Numeric, forecast horizon. shift Numeric, shift apply estimates. burn_in Numeric, number days discard estimates . start_date Date, earliest date data. CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format Posterior Samples — format_fit","text":"list samples summarised posterior parameter estimates.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Format Posterior Samples — format_fit","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"Generates distribution definition parameter estimates available gamma distributed parameters. See rgamma distribution information.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"","code":"gamma_dist_def(   shape,   shape_sd,   scale,   scale_sd,   mean,   mean_sd,   sd,   sd_sd,   max_value,   samples )"},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"shape Numeric, shape parameter gamma distribution. shape_sd Numeric, standard deviation shape parameter. scale Numeric, scale parameter gamma distribution. scale_sd Numeric, standard deviation scale parameter. mean Numeric, log mean parameter gamma distribution. mean_sd Numeric, standard deviation log mean parameter. sd Numeric, log sd parameter gamma distribution. sd_sd Numeric, standard deviation log sd parameter. max_value Numeric, maximum value allow. Defaults 120. Samples outside range resampled. samples Numeric, number sample distributions generate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"data.table defining distribution used dist_skel","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"","code":"# using estimated shape and scale def <- gamma_dist_def(   shape = 5.807, shape_sd = 0.2,   scale = 0.9, scale_sd = 0.05,   max_value = 20, samples = 10 ) print(def) #>     model    params max_value #>  1: gamma <list[2]>        20 #>  2: gamma <list[2]>        20 #>  3: gamma <list[2]>        20 #>  4: gamma <list[2]>        20 #>  5: gamma <list[2]>        20 #>  6: gamma <list[2]>        20 #>  7: gamma <list[2]>        20 #>  8: gamma <list[2]>        20 #>  9: gamma <list[2]>        20 #> 10: gamma <list[2]>        20 def$params[[1]] #> $alpha #> [1] 5.720998 #>  #> $beta #> [1] 1.100175 #>   # using mean and sd def <- gamma_dist_def(   mean = 3, mean_sd = 0.5,   sd = 3, sd_sd = 0.1,   max_value = 20, samples = 10 ) print(def) #>     model    params max_value #>  1: gamma <list[2]>        20 #>  2: gamma <list[2]>        20 #>  3: gamma <list[2]>        20 #>  4: gamma <list[2]>        20 #>  5: gamma <list[2]>        20 #>  6: gamma <list[2]>        20 #>  7: gamma <list[2]>        20 #>  8: gamma <list[2]>        20 #>  9: gamma <list[2]>        20 #> 10: gamma <list[2]>        20 def$params[[1]] #> $alpha #> [1] 1.018861 #>  #> $beta #> [1] 0.3328072 #>"},{"path":"epiforecasts.io/EpiNow2/reference/generation_time_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Generation Time Distribution Options — generation_time_opts","title":"Generation Time Distribution Options — generation_time_opts","text":"Returns generation time parameters format lower level model use. generation time can either given disease source passed get_generation_time, parameters distribution passed dist_spec.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/generation_time_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generation Time Distribution Options — generation_time_opts","text":"","code":"generation_time_opts(   ...,   disease,   source,   max = 15L,   fixed = FALSE,   prior_weight = NULL )"},{"path":"epiforecasts.io/EpiNow2/reference/generation_time_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generation Time Distribution Options — generation_time_opts","text":"... parameters passed dist_spec(), generation time given parameters distribution rather disease source. case mean parameter set mean 1 assumed, max parameter set max set 15 ensure backwards compatibility, dist parameter given gamma distribution used backwards compatibility. delay_opts() list parameters can also supplied describe distribution (unlike delay_opts() multiple distributions may currently used (example output get_generation_time()). disease character string indicating disease interest. source character string indicating source interest. max Integer, defaults 15. Maximum generation time. fixed Logical, defaults FALSE. generation time treated coming fixed (vs uncertain) distributions. prior_weight numeric, weight given generation time prior. default generation time prior weighted number observation data points, usually preventing posteriors shifting much given distribution. Another sensible option 1, .e. treating generation time distribution single parameter.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/generation_time_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generation Time Distribution Options — generation_time_opts","text":"list summarising input delay distributions.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/generation_time_opts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generation Time Distribution Options — generation_time_opts","text":"Sebastian Funk Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/generation_time_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generation Time Distribution Options — generation_time_opts","text":"","code":"# default settings with a fixed generation time generation_time_opts() #> $gt_mean_mean #> [1] 1 #>  #> $gt_mean_sd #> [1] 0 #>  #> $gt_sd_mean #> [1] 0 #>  #> $gt_sd_sd #> [1] 0 #>  #> $gt_fixed #> [1] 1 #>  #> $gt_max #> [1] 1 #>  #> $gt_dist #> [1] 1 #>   # A fixed gamma distributed generation time generation_time_opts(mean = 3, sd = 2) #> $gt_mean_mean #> [1] 3 #>  #> $gt_mean_sd #> [1] 0 #>  #> $gt_sd_mean #> [1] 2 #>  #> $gt_sd_sd #> [1] 0 #>  #> $gt_fixed #> [1] 1 #>  #> $gt_dist #> [1] 1 #>   # An uncertain gamma distributed generation time generation_time_opts(mean = 3, sd = 2, mean_sd = 1, sd_sd = 0.5) #> $gt_mean_mean #> [1] 3 #>  #> $gt_mean_sd #> [1] 1 #>  #> $gt_sd_mean #> [1] 2 #>  #> $gt_sd_sd #> [1] 0.5 #>  #> $gt_fixed #> [1] 0 #>  #> $gt_dist #> [1] 1 #>"},{"path":"epiforecasts.io/EpiNow2/reference/generation_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Literature Estimates of Generation Times — generation_times","title":"Literature Estimates of Generation Times — generation_times","text":"Generation time estimates. See details: https://github.com/epiforecasts/EpiNow2/blob/main/data-raw/generation-time.R","code":""},{"path":"epiforecasts.io/EpiNow2/reference/generation_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Literature Estimates of Generation Times — generation_times","text":"","code":"generation_times"},{"path":"epiforecasts.io/EpiNow2/reference/generation_times.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Literature Estimates of Generation Times — generation_times","text":"data.table summarising distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a Literature Distribution — get_dist","title":"Get a Literature Distribution — get_dist","text":"Search data frame distribution return format expected delay_opts() generation_time argument epinow estimate_infections.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Literature Distribution — get_dist","text":"","code":"get_dist(data, disease, source, max_value = 15, fixed = FALSE)"},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Literature Distribution — get_dist","text":"data data.table format generation_times. disease character string indicating disease interest. source character string indicating source interest. max_value Numeric, maximum value allow. Defaults 15 days. fixed Logical, defaults FALSE. distributions supplied fixed values (vs uncertainty)?","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Literature Distribution — get_dist","text":"list defining distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get a Literature Distribution — get_dist","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a Literature Distribution — get_dist","text":"","code":"get_dist(EpiNow2::generation_times, disease = \"SARS-CoV-2\", source = \"ganyani\") #> $mean #> [1] 3.635272 #>  #> $mean_sd #> [1] 0.7109351 #>  #> $sd #> [1] 3.075315 #>  #> $sd_sd #> [1] 0.7695178 #>  #> $max #> [1] 15 #>  #> $dist #> [1] \"gamma\" #>"},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a Literature Distribution for the Generation Time — get_generation_time","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"Extracts literature distribution generation_times.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"","code":"get_generation_time(disease, source, max_value = 15, fixed = FALSE)"},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"disease character string indicating disease interest. source character string indicating source interest. max_value Numeric, maximum value allow. Defaults 15 days. fixed Logical, defaults FALSE. distributions supplied fixed values (vs uncertainty)?","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"list defining distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"","code":"get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") #> $mean #> [1] 3.635272 #>  #> $mean_sd #> [1] 0.7109351 #>  #> $sd #> [1] 3.075315 #>  #> $sd_sd #> [1] 0.7695178 #>  #> $max #> [1] 15 #>  #> $dist #> [1] \"gamma\" #>"},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a Literature Distribution for the Incubation Period — get_incubation_period","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"Extracts literature distribution incubation_periods.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"","code":"get_incubation_period(disease, source, max_value = 15, fixed = FALSE)"},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"disease character string indicating disease interest. source character string indicating source interest. max_value Numeric, maximum value allow. Defaults 15 days. fixed Logical, defaults FALSE. distributions supplied fixed values (vs uncertainty)?","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"list defining distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"","code":"get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") #> $mean #> [1] 1.621 #>  #> $mean_sd #> [1] 0.064 #>  #> $sd #> [1] 0.418 #>  #> $sd_sd #> [1] 0.0691 #>  #> $max #> [1] 15 #>  #> $dist #> [1] \"lognormal\" #>"},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/get_raw_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Single Raw Result — get_raw_result","text":"","code":"get_raw_result(file, region, date, result_dir)"},{"path":"epiforecasts.io/EpiNow2/reference/get_raw_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Single Raw Result — get_raw_result","text":"file Character string giving result files name. region Character string giving region interest. date Target date (format \"yyyy-mm-dd). result_dir Character string giving location target directory.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_raw_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Single Raw Result — get_raw_result","text":"R object read targeted .rds file","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_raw_result.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get a Single Raw Result — get_raw_result","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Combined Regional Results — get_regional_results","title":"Get Combined Regional Results — get_regional_results","text":"Summarises results across regions either input disk. See examples details.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Combined Regional Results — get_regional_results","text":"","code":"get_regional_results(   regional_output,   results_dir,   date,   samples = TRUE,   forecast = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Combined Regional Results — get_regional_results","text":"regional_output list output produced regional_epinow stored regional list. results_dir character string indicating folder containing EpiNow2 results extract. date Character string (format \"yyyy-mm-dd\") indicating date extract data . Defaults \"latest\" finds latest results available. samples Logical, defaults TRUE. samples returned. forecast Logical, defaults FALSE. forecast results returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Combined Regional Results — get_regional_results","text":"list estimates, forecasts estimated cases date report.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get Combined Regional Results — get_regional_results","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Combined Regional Results — get_regional_results","text":"","code":"# \\donttest{ # construct example distributions generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- estimate_delay(rlnorm(100, log(6), 1), max_value = 10)  # example case vector cases <- example_confirmed[1:30] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # save results to tmp folder dir <- file.path(tempdir(check = TRUE), \"results\") # run multiregion estimates regional_out <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(rw = 7), gp = NULL,   output = c(\"regions\", \"latest\"),   target_folder = dir,   return_output = TRUE ) #> INFO [2023-01-24 21:51:41] Producing following optional outputs: regions, latest #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpfR2b3X/regional-epinow/2020-03-22.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpfR2b3X/epinow/2020-03-22.log #> INFO [2023-01-24 21:51:41] Reporting estimates using data up to: 2020-03-22 #> INFO [2023-01-24 21:51:41] Saving estimates to : /tmp/RtmpfR2b3X/results #> INFO [2023-01-24 21:51:41] Producing estimates for: testland, realland #> INFO [2023-01-24 21:51:41] Regions excluded: none #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> failed to create the sampler; sampling not done #> INFO [2023-01-24 21:51:41] Completed regional estimates #> INFO [2023-01-24 21:51:41] Regions with estimates: 0 #> INFO [2023-01-24 21:51:41] Regions with runtime errors: 2 #> INFO [2023-01-24 21:51:41] Saving timings information to : /tmp/RtmpfR2b3X/results # from output results <- get_regional_results(regional_out$regional, samples = FALSE) names(results) #> [1] \"estimates\"  # from a folder folder_results <- get_regional_results(results_dir = dir, samples = FALSE) #> Warning: cannot open compressed file '/tmp/RtmpfR2b3X/results/realland/latest/summarised_estimates.rds', probable reason 'No such file or directory' #> Warning: cannot open compressed file '/tmp/RtmpfR2b3X/results/testland/latest/summarised_estimates.rds', probable reason 'No such file or directory' names(folder_results) #> [1] \"estimates\" # }"},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/get_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Folders with Results — get_regions","text":"","code":"get_regions(results_dir)"},{"path":"epiforecasts.io/EpiNow2/reference/get_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Folders with Results — get_regions","text":"results_dir character string giving directory results stored (produced regional_rt_pipeline).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Folders with Results — get_regions","text":"named character vector containing results plot.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get Folders with Results — get_regions","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Regions with Most Reported Cases — get_regions_with_most_reports","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"Extract vector regions reported cases set time window.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"","code":"get_regions_with_most_reports(reported_cases, time_window = 7, no_regions = 6)"},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"reported_cases data frame confirmed cases (confirm) date (date), region (region). time_window Numeric, number days include latest date data. Defaults 7 days. no_regions Numeric, number regions return. Defaults 6.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"character vector regions highest reported cases","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate Gaussian Process Settings — gp_opts","title":"Approximate Gaussian Process Settings — gp_opts","text":"Defines list specifying structure approximate Gaussian process. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate Gaussian Process Settings — gp_opts","text":"","code":"gp_opts(   basis_prop = 0.2,   boundary_scale = 1.5,   ls_mean = 21,   ls_sd = 7,   ls_min = 0,   ls_max = 60,   alpha_sd = 0.05,   kernel = \"matern\",   matern_type = 3/2 )"},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate Gaussian Process Settings — gp_opts","text":"basis_prop Numeric, proportion time points use basis functions. Defaults 0.1. Decreasing value results decrease accuracy faster compute time (increasing first effect). general smaller posterior length scales require higher proportion basis functions. See (Riutort-Mayol et al. 2020 https://arxiv.org/abs/2004.11408) advice updating default. setting area active research. boundary_scale Numeric, defaults 1.5. Boundary scale approximate Gaussian process. See (Riutort-Mayol et al. 2020 https://arxiv.org/abs/2004.11408) advice updating default. ls_mean Numeric, defaults 21 days. mean lognormal length scale. ls_sd Numeric, defaults 7 days. standard deviation log normal length scale. ls_sd = 0, inverse-gamma prior Gaussian process length scale used recommended parameters inv_gamma(1.499007, 0.057277 * ls_max). ls_min Numeric, defaults 0. minimum value length scale. ls_max Numeric, defaults 60. maximum value length scale. Updated create_gp_data length input data smaller. alpha_sd Numeric, defaults 0.05. standard deviation magnitude parameter Gaussian process kernel. approximately expected standard deviation logged Rt. kernel Character string, type kernel required. Currently supporting squared exponential kernel (\"se\") 3 2 Matern kernel (\"matern\", matern_type = 3/2). Defaulting Matern 3 2 kernel discontinuities expected  Rt infections. matern_type Numeric, defaults 3/2. Type Matern Kernel use. Currently Matern 3/2 kernel supported.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate Gaussian Process Settings — gp_opts","text":"list settings defining Gaussian process","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate Gaussian Process Settings — gp_opts","text":"","code":"# default settings gp_opts() #> $basis_prop #> [1] 0.2 #>  #> $boundary_scale #> [1] 1.5 #>  #> $ls_mean #> [1] 21 #>  #> $ls_sd #> [1] 7 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 60 #>  #> $alpha_sd #> [1] 0.05 #>  #> $kernel #> [1] \"matern_3/2\" #>  #> $matern_type #> [1] 1.5 #>   # add a custom length scale gp_opts(ls_mean = 4) #> $basis_prop #> [1] 0.2 #>  #> $boundary_scale #> [1] 1.5 #>  #> $ls_mean #> [1] 4 #>  #> $ls_sd #> [1] 7 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 60 #>  #> $alpha_sd #> [1] 0.05 #>  #> $kernel #> [1] \"matern_3/2\" #>  #> $matern_type #> [1] 1.5 #>"},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Growth Rates to Reproduction numbers. — growth_to_R","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"See justification. Now handled internally stan may removed future updates user demand.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"","code":"growth_to_R(r, gamma_mean, gamma_sd)"},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"r Numeric, rate growth estimates gamma_mean Numeric, mean gamma distribution gamma_sd Numeric, standard deviation gamma distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"Numeric vector reproduction number estimates","code":""},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"","code":"growth_to_R(0.2, 4, 1) #> [1] 2.182875"},{"path":"epiforecasts.io/EpiNow2/reference/incubation_periods.html","id":null,"dir":"Reference","previous_headings":"","what":"Literature Estimates of Incubation Periods — incubation_periods","title":"Literature Estimates of Incubation Periods — incubation_periods","text":"Incubation period estimates. See details: https://github.com/epiforecasts/EpiNow2/blob/main/data-raw/incubation-period.R","code":""},{"path":"epiforecasts.io/EpiNow2/reference/incubation_periods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Literature Estimates of Incubation Periods — incubation_periods","text":"","code":"incubation_periods"},{"path":"epiforecasts.io/EpiNow2/reference/incubation_periods.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Literature Estimates of Incubation Periods — incubation_periods","text":"data.table summarising distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"Fits model cumulative cases. may useful approach initialising full model fit certain data sets sampler gets stuck easily initialised fitting cumulative cases changes shape posterior distribution. estimate_infections(), epinow() regional_epinow() option can engaged setting stan_opts(init_fit = \"cumulative\"). implementation based approach taken epidemia authored James Scott.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"","code":"init_cumulative_fit(   args,   samples = 50,   warmup = 50,   id = \"init\",   verbose = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"args List stan arguments. samples Numeric, defaults 50. Number posterior samples. warmup Numeric, defaults 50. Number warmup samples. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching. verbose Logical, fitting progress returned. Defaults FALSE.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"stanfit object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"Generates distribution definition parameter estimates available log normal distributed parameters. See rlnorm distribution information.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"","code":"lognorm_dist_def(mean, mean_sd, sd, sd_sd, max_value, samples, to_log = FALSE)"},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"mean Numeric, log mean parameter gamma distribution. mean_sd Numeric, standard deviation log mean parameter. sd Numeric, log sd parameter gamma distribution. sd_sd Numeric, standard deviation log sd parameter. max_value Numeric, maximum value allow. Defaults 120. Samples outside range resampled. samples Numeric, number sample distributions generate. to_log Logical, parameters logged use.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"data.table defining distribution used dist_skel","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"","code":"def <- lognorm_dist_def(   mean = 1.621, mean_sd = 0.0640,   sd = 0.418, sd_sd = 0.0691,   max_value = 20, samples = 10 ) print(def) #>       model    params max_value #>  1: lognorm <list[2]>        20 #>  2: lognorm <list[2]>        20 #>  3: lognorm <list[2]>        20 #>  4: lognorm <list[2]>        20 #>  5: lognorm <list[2]>        20 #>  6: lognorm <list[2]>        20 #>  7: lognorm <list[2]>        20 #>  8: lognorm <list[2]>        20 #>  9: lognorm <list[2]>        20 #> 10: lognorm <list[2]>        20 def$params[[1]] #> $mean #> [1] 1.693223 #>  #> $sd #> [1] 0.319885 #>   def <- lognorm_dist_def(   mean = 5, mean_sd = 1,   sd = 3, sd_sd = 1,   max_value = 20, samples = 10,   to_log = TRUE ) print(def) #>       model    params max_value #>  1: lognorm <list[2]>        20 #>  2: lognorm <list[2]>        20 #>  3: lognorm <list[2]>        20 #>  4: lognorm <list[2]>        20 #>  5: lognorm <list[2]>        20 #>  6: lognorm <list[2]>        20 #>  7: lognorm <list[2]>        20 #>  8: lognorm <list[2]>        20 #>  9: lognorm <list[2]>        20 #> 10: lognorm <list[2]>        20 def$params[[1]] #> $mean #> [1] 1.475956 #>  #> $sd #> [1] 0.6237088 #>"},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":null,"dir":"Reference","previous_headings":"","what":"Format Credible Intervals — make_conf","title":"Format Credible Intervals — make_conf","text":"Combines list values formatted credible intervals.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format Credible Intervals — make_conf","text":"","code":"make_conf(value, CrI = 90, reverse = FALSE)"},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format Credible Intervals — make_conf","text":"value List value map string. Requires, point, lower, upper. CrI Numeric, credible interval report. Defaults 90 reverse Logical, defaults FALSE. reported credible interval switched.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format Credible Intervals — make_conf","text":"character vector formatted reporting","code":""},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format Credible Intervals — make_conf","text":"","code":"value <- list(median = 2, lower_90 = 1, upper_90 = 3) make_conf(value) #> [1] \"2 (1 -- 3)\""},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Categorise the Probability of Change for Rt — map_prob_change","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"Categorises numeric variable \"Increasing\" (< 0.05), \"Likely increasing\" (<0.4), \"Stable\" (< 0.6), \"Likely decreasing\" (< 0.95), \"Decreasing\" (<= 1)","code":""},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"","code":"map_prob_change(var)"},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"var Numeric variable categorised","code":""},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"character variable.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"","code":"var <- seq(0.01, 1, 0.01) var #>   [1] 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 #>  [16] 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 #>  [31] 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 #>  [46] 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 #>  [61] 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 #>  [76] 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 #>  [91] 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00  map_prob_change(var) #>   [1] Increasing        Increasing        Increasing        Increasing        #>   [5] Likely increasing Likely increasing Likely increasing Likely increasing #>   [9] Likely increasing Likely increasing Likely increasing Likely increasing #>  [13] Likely increasing Likely increasing Likely increasing Likely increasing #>  [17] Likely increasing Likely increasing Likely increasing Likely increasing #>  [21] Likely increasing Likely increasing Likely increasing Likely increasing #>  [25] Likely increasing Likely increasing Likely increasing Likely increasing #>  [29] Likely increasing Likely increasing Likely increasing Likely increasing #>  [33] Likely increasing Likely increasing Likely increasing Likely increasing #>  [37] Likely increasing Likely increasing Likely increasing Stable            #>  [41] Stable            Stable            Stable            Stable            #>  [45] Stable            Stable            Stable            Stable            #>  [49] Stable            Stable            Stable            Stable            #>  [53] Stable            Stable            Stable            Stable            #>  [57] Stable            Stable            Stable            Likely decreasing #>  [61] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [65] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [69] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [73] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [77] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [81] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [85] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [89] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [93] Likely decreasing Likely decreasing Decreasing        Decreasing        #>  [97] Decreasing        Decreasing        Decreasing        Decreasing        #> Levels: Increasing Likely increasing Stable Likely decreasing Decreasing"},{"path":"epiforecasts.io/EpiNow2/reference/match_output_arguments.html","id":null,"dir":"Reference","previous_headings":"","what":"Match User Supplied Arguments with Supported Options — match_output_arguments","title":"Match User Supplied Arguments with Supported Options — match_output_arguments","text":"Match user supplied arguments supported options return logical list internal usage","code":""},{"path":"epiforecasts.io/EpiNow2/reference/match_output_arguments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match User Supplied Arguments with Supported Options — match_output_arguments","text":"","code":"match_output_arguments(   input_args = c(),   supported_args = c(),   logger = NULL,   level = \"info\" )"},{"path":"epiforecasts.io/EpiNow2/reference/match_output_arguments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match User Supplied Arguments with Supported Options — match_output_arguments","text":"input_args character vector input arguments (can partial). supported_args character vector supported output arguments. logger character vector indicating logger target messages . Defaults logging. level Character string defaulting \"info\". Logging level see documentation futile.logger details. Supported options \"info\" \"debug\"","code":""},{"path":"epiforecasts.io/EpiNow2/reference/match_output_arguments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match User Supplied Arguments with Supported Options — match_output_arguments","text":"logical vector named output arguments","code":""},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation Model Options — obs_opts","title":"Observation Model Options — obs_opts","text":"Defines list specifying structure observation model. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation Model Options — obs_opts","text":"","code":"obs_opts(   family = \"negbin\",   phi = c(0, 1),   weight = 1,   week_effect = TRUE,   week_length = 7,   scale = list(),   likelihood = TRUE,   return_likelihood = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation Model Options — obs_opts","text":"family Character string defining observation model. Options Negative binomial (\"negbin\"), default, Poisson. phi numeric vector length 2, defaults 0, 1. Indicates mean standard deviation normal prior used observation process. weight Numeric, defaults 1. Weight give observed data log density. week_effect Logical defaulting TRUE. day week effect used observation model. week_length Numeric assumed length week days, defaulting 7 days. can modified data aggregated period week data non-weekly periodicity. scale List, defaulting empty list. scaling factor applied map latent infections (convolved date report). none empty mean (mean) standard deviation (sd) needs supplied defining normally distributed scaling factor. likelihood Logical, defaults TRUE. likelihood included model return_likelihood Logical, defaults FALSE. likelihood returned model.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation Model Options — obs_opts","text":"list observation model settings.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation Model Options — obs_opts","text":"","code":"# default settings obs_opts() #> $family #> [1] \"negbin\" #>  #> $phi #> [1] 0 1 #>  #> $weight #> [1] 1 #>  #> $week_effect #> [1] TRUE #>  #> $week_length #> [1] 7 #>  #> $scale #> list() #>  #> $likelihood #> [1] TRUE #>  #> $return_likelihood #> [1] FALSE #>   # Turn off day of the week effect obs_opts(week_effect = TRUE) #> $family #> [1] \"negbin\" #>  #> $phi #> [1] 0 1 #>  #> $weight #> [1] 1 #>  #> $week_effect #> [1] TRUE #>  #> $week_length #> [1] 7 #>  #> $scale #> list() #>  #> $likelihood #> [1] TRUE #>  #> $return_likelihood #> [1] FALSE #>   # Scale reported data obs_opts(scale = list(mean = 0.2, sd = 0.02)) #> $family #> [1] \"negbin\" #>  #> $phi #> [1] 0 1 #>  #> $weight #> [1] 1 #>  #> $week_effect #> [1] TRUE #>  #> $week_length #> [1] 7 #>  #> $scale #> $scale$mean #> [1] 0.2 #>  #> $scale$sd #> [1] 0.02 #>  #>  #> $likelihood #> [1] TRUE #>  #> $return_likelihood #> [1] FALSE #>"},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Return an _opts List per Region — opts_list","title":"Return an _opts List per Region — opts_list","text":"Define list _opts() pass regional_epinow _opts() accepting arguments. useful different settings needed regions within single regional_epinow call. Using opts_list defaults can applied regions present override passed regions necessary (either within opts_list externally).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return an _opts List per Region — opts_list","text":"","code":"opts_list(opts, reported_cases, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return an _opts List per Region — opts_list","text":"opts _opts() function call rt_opts() reported_cases data frame containing region variable indicating target regions ... Optional override region defaults. See examples use case.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return an _opts List per Region — opts_list","text":"named list options per region can passed _opt accepting arguments regional_epinow","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return an _opts List per Region — opts_list","text":"","code":"# uses example case vector cases <- example_confirmed[1:40] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # default settings opts_list(rt_opts(), cases) #> $testland #> $testland$prior #> $testland$prior$mean #> [1] 1 #>  #> $testland$prior$sd #> [1] 1 #>  #>  #> $testland$use_rt #> [1] TRUE #>  #> $testland$rw #> [1] 0 #>  #> $testland$use_breakpoints #> [1] TRUE #>  #> $testland$future #> [1] \"latest\" #>  #> $testland$pop #> [1] 0 #>  #> $testland$gp_on #> [1] \"R_t-1\" #>  #>  #> $realland #> $realland$prior #> $realland$prior$mean #> [1] 1 #>  #> $realland$prior$sd #> [1] 1 #>  #>  #> $realland$use_rt #> [1] TRUE #>  #> $realland$rw #> [1] 0 #>  #> $realland$use_breakpoints #> [1] TRUE #>  #> $realland$future #> [1] \"latest\" #>  #> $realland$pop #> [1] 0 #>  #> $realland$gp_on #> [1] \"R_t-1\" #>  #>   # add a weekly random walk in realland opts_list(rt_opts(), cases, realland = rt_opts(rw = 7)) #> $testland #> $testland$prior #> $testland$prior$mean #> [1] 1 #>  #> $testland$prior$sd #> [1] 1 #>  #>  #> $testland$use_rt #> [1] TRUE #>  #> $testland$rw #> [1] 0 #>  #> $testland$use_breakpoints #> [1] TRUE #>  #> $testland$future #> [1] \"latest\" #>  #> $testland$pop #> [1] 0 #>  #> $testland$gp_on #> [1] \"R_t-1\" #>  #>  #> $realland #> $realland$prior #> $realland$prior$mean #> [1] 1 #>  #> $realland$prior$sd #> [1] 1 #>  #>  #> $realland$use_rt #> [1] TRUE #>  #> $realland$rw #> [1] 7 #>  #> $realland$use_breakpoints #> [1] TRUE #>  #> $realland$future #> [1] \"latest\" #>  #> $realland$pop #> [1] 0 #>  #> $realland$gp_on #> [1] \"R_t-1\" #>  #>   # add a weekly random walk externally rt <- opts_list(rt_opts(), cases) rt$realland$rw <- 7 rt #> $testland #> $testland$prior #> $testland$prior$mean #> [1] 1 #>  #> $testland$prior$sd #> [1] 1 #>  #>  #> $testland$use_rt #> [1] TRUE #>  #> $testland$rw #> [1] 0 #>  #> $testland$use_breakpoints #> [1] TRUE #>  #> $testland$future #> [1] \"latest\" #>  #> $testland$pop #> [1] 0 #>  #> $testland$gp_on #> [1] \"R_t-1\" #>  #>  #> $realland #> $realland$prior #> $realland$prior$mean #> [1] 1 #>  #> $realland$prior$sd #> [1] 1 #>  #>  #> $realland$use_rt #> [1] TRUE #>  #> $realland$rw #> [1] 7 #>  #> $realland$use_breakpoints #> [1] TRUE #>  #> $realland$future #> [1] \"latest\" #>  #> $realland$pop #> [1] 0 #>  #> $realland$gp_on #> [1] \"R_t-1\" #>  #>"},{"path":"epiforecasts.io/EpiNow2/reference/plot.epinow.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for epinow — plot.epinow","title":"Plot method for epinow — plot.epinow","text":"plot method class \"epinow\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.epinow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for epinow — plot.epinow","text":"","code":"# S3 method for epinow plot(x, type = \"summary\", ...)"},{"path":"epiforecasts.io/EpiNow2/reference/plot.epinow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for epinow — plot.epinow","text":"x list output produced epinow type character vector indicating name plots return. Defaults  \"summary\" supported options \"infections\", \"reports\", \"R\", \"growth_rate\", \"summary\", \"\". ... Pass additional arguments report_plots","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.epinow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for epinow — plot.epinow","text":"List plots produced report_plots","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for estimate_infections — plot.estimate_infections","title":"Plot method for estimate_infections — plot.estimate_infections","text":"plot method class \"estimate_infections\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for estimate_infections — plot.estimate_infections","text":"","code":"# S3 method for estimate_infections plot(x, type = \"summary\", ...)"},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for estimate_infections — plot.estimate_infections","text":"x list output produced estimate_infections type character vector indicating name plots return. Defaults  \"summary\" supported options \"infections\", \"reports\", \"R\", \"growth_rate\", \"summary\", \"\". ... Pass additional arguments report_plots","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for estimate_infections — plot.estimate_infections","text":"List plots produced report_plots","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for estimate_secondary — plot.estimate_secondary","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"plot method class \"estimate_secondary\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"","code":"# S3 method for estimate_secondary plot(x, primary = FALSE, from = NULL, to = NULL, new_obs = NULL, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"x list output produced estimate_secondary primary Logical, defaults FALSE. primary reports also plot? Date object indicating plot . Date object indicating plot . new_obs data.frame containing columns date secondary replace secondary observations stored estimate_secondary output. ... Pass additional arguments plot function. currently use.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"ggplot object.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for estimate_truncation — plot.estimate_truncation","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"plot method class \"estimate_truncation\". Returns plot faceted dataset used fitting latest observations columns, data observed time (truncated) dots truncation adjusted estimates ribbon.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"","code":"# S3 method for estimate_truncation plot(x, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"x list output produced estimate_truncation ... Pass additional arguments plot function. currently use.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"ggplot2 object","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_CrIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot EpiNow2 Credible Intervals — plot_CrIs","title":"Plot EpiNow2 Credible Intervals — plot_CrIs","text":"Adds lineranges user specified credible intervals","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_CrIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot EpiNow2 Credible Intervals — plot_CrIs","text":"","code":"plot_CrIs(plot, CrIs, alpha, linewidth)"},{"path":"epiforecasts.io/EpiNow2/reference/plot_CrIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot EpiNow2 Credible Intervals — plot_CrIs","text":"plot ggplot2 plot CrIs Numeric list credible intervals present data. produced extract_CrIs alpha Numeric, overall alpha target line range linewidth Numeric, line width default line range.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_CrIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot EpiNow2 Credible Intervals — plot_CrIs","text":"ggplot2 plot.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Estimates — plot_estimates","title":"Plot Estimates — plot_estimates","text":"Allows users plot output estimate_infections easily. future releases may depreciated favour increasing functionality S3 plot methods.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Estimates — plot_estimates","text":"","code":"plot_estimates(   estimate,   reported,   ylab = \"Cases\",   hline,   obs_as_col = TRUE,   max_plot = 10,   estimate_type = NULL )"},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Estimates — plot_estimates","text":"estimate data.table estimates containing following variables: date, type (must contain \"estimate\", \"estimate based partial data\" optionally \"forecast\"), reported data.table reported cases following variables: date, confirm. ylab Character string, defaulting \"Cases\". Title plot y axis. hline Numeric, supplied gives horizontal intercept indicator line. obs_as_col Logical, defaults TRUE. observed data, supplied, plotted using columns points (linked using line). max_plot Numeric, defaults 10. multiplicative upper bound number cases shown plot. Based maximum number reported cases. estimate_type Character vector indicating type data plot. Default types supported options : \"Estimate\", \"Estimate based partial data\", \"Forecast\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Estimates — plot_estimates","text":"ggplot2 object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Estimates — plot_estimates","text":"","code":"# \\donttest{ # define example cases cases <- example_confirmed[1:40]  # set up example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- estimate_delay(rlnorm(100, log(6), 1), max_value = 10)  # run model out <- estimate_infections(cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay) ) #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> Error in dimnames(x)$parameters: $ operator is invalid for atomic vectors # plot infections plot_estimates(   estimate = out$summarised[variable == \"infections\"],   reported = cases,   ylab = \"Cases\", max_plot = 2 ) + ggplot2::facet_wrap(~type, scales = \"free_y\") #> Error in data.table::as.data.table(estimate): object 'out' not found  # plot reported cases estimated via Rt plot_estimates(   estimate = out$summarised[variable == \"reported_cases\"],   reported = cases,   ylab = \"Cases\" ) #> Error in data.table::as.data.table(estimate): object 'out' not found  # plot Rt estimates plot_estimates(   estimate = out$summarised[variable == \"R\"],   ylab = \"Effective Reproduction No.\",   hline = 1 ) #> Error in data.table::as.data.table(estimate): object 'out' not found  #' # plot Rt estimates without forecasts plot_estimates(   estimate = out$summarised[variable == \"R\"],   ylab = \"Effective Reproduction No.\",   hline = 1, estimate_type = \"Estimate\" ) #> Error in data.table::as.data.table(estimate): object 'out' not found # }"},{"path":"epiforecasts.io/EpiNow2/reference/plot_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a Summary of the Latest Results — plot_summary","title":"Plot a Summary of the Latest Results — plot_summary","text":"Used return summary plot across regions (using results generated summarise_results). May depreciated later releases favour enhanced S3 methods.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a Summary of the Latest Results — plot_summary","text":"","code":"plot_summary(summary_results, x_lab = \"Region\", log_cases = FALSE, max_cases)"},{"path":"epiforecasts.io/EpiNow2/reference/plot_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a Summary of the Latest Results — plot_summary","text":"summary_results data.table returned summarise_results (data object). x_lab character string giving label x axis, defaults region. log_cases Logical, cases shown logged scale. Defaults FALSE max_cases Numeric, default. maximum number cases plot.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a Summary of the Latest Results — plot_summary","text":"ggplot2 object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Process regional estimate — process_region","title":"Process regional estimate — process_region","text":"Internal function removes output required, returns logging information.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process regional estimate — process_region","text":"","code":"process_region(   out,   target_region,   timing,   return_output = TRUE,   return_timing = TRUE,   complete_logger = \"EpiNow2.epinow\" )"},{"path":"epiforecasts.io/EpiNow2/reference/process_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process regional estimate — process_region","text":"List output returned epinow target_region Character string indicating region evaluated timing Output Sys.time return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. return_timing Logical, runtime returned complete_logger Character string indicating logger output completion estimation .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process regional estimate — process_region","text":"list processed output","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/process_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Process all Region Estimates — process_regions","title":"Process all Region Estimates — process_regions","text":"Internal function processes output multiple epinow runs, adds summary logging information.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process all Region Estimates — process_regions","text":"","code":"process_regions(regional_out, regions)"},{"path":"epiforecasts.io/EpiNow2/reference/process_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process all Region Estimates — process_regions","text":"regional_out list output multiple runs regional_epinow regions character vector identifying regions run","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process all Region Estimates — process_regions","text":"list regional estimates successful regional estimates","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":null,"dir":"Reference","previous_headings":"","what":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"Efficiently runs epinow() across multiple regions efficient manner conducts basic data checks cleaning removing regions fewer non_zero_points unlikely produce reasonable results whilst consuming significant resources. See documentation epinow information. default arguments supporting input _opts() functions shared across regions (including delays, truncation, Rt settings, stan settings, gaussian process settings). Region specific settings supported passing named list _opts() calls (entry per region) relevant argument. helper function (opts_list) available facilitate building list. Regions can estimated parallel using {future} package (see setup_future). progress producing estimates across multiple regions tracked using progressr package. Modify behaviour using progressr::handlers enable batch setting R_PROGRESSR_ENABLE=TRUE environment variable.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"","code":"regional_epinow(   reported_cases,   generation_time,   delays = delay_opts(),   truncation = trunc_opts(),   rt = rt_opts(),   backcalc = backcalc_opts(),   gp = gp_opts(),   obs = obs_opts(),   stan = stan_opts(),   horizon = 7,   CrIs = c(0.2, 0.5, 0.9),   target_folder = NULL,   target_date,   non_zero_points = 2,   output = c(\"regions\", \"summary\", \"samples\", \"plots\", \"latest\"),   return_output = FALSE,   summary_args = list(),   verbose = FALSE,   logs = tempdir(check = TRUE),   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"reported_cases data frame confirmed cases (confirm) date (date), region (region). generation_time call generation_time_opts() defining generation time distribution used. backwards compatibility list summary parameters can also passed. delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. horizon Numeric, defaults 7. Number days future forecast. CrIs Numeric vector credible intervals calculate. target_folder Character string specifying save results (create present). target_date Date, defaults maximum found data specified. non_zero_points Numeric, minimum number time points non-zero cases region required region evaluated. Defaults 7. output character vector optional output return. Supported options individual regional estimates (\"regions\"),  samples (\"samples\"), plots (\"plots\"), copying individual region dated folder latest folder (target_folder null, set using \"latest\"), stan fit underlying model (\"fit\"), overall summary across regions (\"summary\"). default return samples plots alongside summarised estimates summary statistics. target_folder NULL default also copy results latest folder. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. summary_args list arguments passed regional_summary. See regional_summary documentation details. verbose Logical defaults FALSE. Outputs verbose progress messages console epinow. logs Character path indicating target folder store log information. Defaults temporary directory specified. Default logging can disabled logs set NULL. specifying custom logging setup code setup_default_logging setup_logging function sensible place start. ... Pass additional arguments epinow. See documentation epinow details.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"list output stratified top level regional output across region output summary output","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # construct example distributions generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1),   mean_sd = 0.1,   sd = convert_to_logsd(2, 1),   sd_sd = 0.1, max = 15 )  # uses example case vector cases <- example_confirmed[1:60] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # run epinow across multiple regions and generate summaries # samples and warmup have been reduced for this example def <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.2)),   stan = stan_opts(     samples = 100, warmup = 200,     control = list(adapt_delta = 0.95)   ),   verbose = interactive() ) #> INFO [2023-01-24 21:51:54] Producing following optional outputs: regions, summary, samples, plots, latest #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpfR2b3X/regional-epinow/2020-04-21.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpfR2b3X/epinow/2020-04-21.log #> INFO [2023-01-24 21:51:54] Reporting estimates using data up to: 2020-04-21 #> INFO [2023-01-24 21:51:54] No target directory specified so returning output #> INFO [2023-01-24 21:51:54] Producing estimates for: testland, realland #> INFO [2023-01-24 21:51:54] Regions excluded: none #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> failed to create the sampler; sampling not done #> INFO [2023-01-24 21:51:54] Completed regional estimates #> INFO [2023-01-24 21:51:54] Regions with estimates: 0 #> INFO [2023-01-24 21:51:54] Regions with runtime errors: 2 #> INFO [2023-01-24 21:51:54] Producing summary #> INFO [2023-01-24 21:51:54] No summary directory specified so returning summary output #> INFO [2023-01-24 21:51:54] Errors caught whilst generating summary statistics:  #> INFO [2023-01-24 21:51:54] Error in .checkTypos(e, names_x): Object 'variable' not found amongst  #>  #> INFO [2023-01-24 21:51:54] No target directory specified so returning timings  # apply a different rt method per region # (here a gaussian process and a weekly random walk) gp <- opts_list(gp_opts(), cases) gp <- update_list(gp, list(realland = NULL)) rt <- opts_list(rt_opts(), cases, realland = rt_opts(rw = 7)) region_rt <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt, gp = gp,   stan = stan_opts(     samples = 100, warmup = 200,     control = list(adapt_delta = 0.95)   ),   verbose = interactive() ) #> INFO [2023-01-24 21:51:54] Producing following optional outputs: regions, summary, samples, plots, latest #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpfR2b3X/regional-epinow/2020-04-21.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpfR2b3X/epinow/2020-04-21.log #> INFO [2023-01-24 21:51:54] Reporting estimates using data up to: 2020-04-21 #> INFO [2023-01-24 21:51:54] No target directory specified so returning output #> INFO [2023-01-24 21:51:54] Producing estimates for: testland, realland #> INFO [2023-01-24 21:51:54] Regions excluded: none #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> failed to create the sampler; sampling not done #> INFO [2023-01-24 21:51:55] Completed regional estimates #> INFO [2023-01-24 21:51:55] Regions with estimates: 0 #> INFO [2023-01-24 21:51:55] Regions with runtime errors: 2 #> INFO [2023-01-24 21:51:55] Producing summary #> INFO [2023-01-24 21:51:55] No summary directory specified so returning summary output #> INFO [2023-01-24 21:51:55] Errors caught whilst generating summary statistics:  #> INFO [2023-01-24 21:51:55] Error in .checkTypos(e, names_x): Object 'variable' not found amongst  #>  #> INFO [2023-01-24 21:51:55] No target directory specified so returning timings  options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise Regional Runtimes — regional_runtimes","title":"Summarise Regional Runtimes — regional_runtimes","text":"Used internally regional_epinow summarise region run times.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise Regional Runtimes — regional_runtimes","text":"","code":"regional_runtimes(   regional_output = NULL,   target_folder = NULL,   target_date = NULL,   return_output = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise Regional Runtimes — regional_runtimes","text":"regional_output list output produced regional_epinow stored regional list. target_folder Character string specifying save results (create present). target_date character string giving target date extract results (format \"yyyy-mm-dd\"). Defaults latest available estimates. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise Regional Runtimes — regional_runtimes","text":"data.table region run times","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise Regional Runtimes — regional_runtimes","text":"","code":"# \\donttest{ # example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- estimate_delay(rlnorm(100, log(6), 1), max_value = 15)  cases <- example_confirmed[1:30] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # run basic nowcasting pipeline regional_out <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   stan = stan_opts(samples = 100, warmup = 100),   output = c(\"region\", \"timing\") ) #> INFO [2023-01-24 21:52:02] Producing following optional outputs: regions, timing #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpfR2b3X/regional-epinow/2020-03-22.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpfR2b3X/epinow/2020-03-22.log #> INFO [2023-01-24 21:52:02] Reporting estimates using data up to: 2020-03-22 #> INFO [2023-01-24 21:52:02] No target directory specified so returning output #> INFO [2023-01-24 21:52:02] Producing estimates for: testland, realland #> INFO [2023-01-24 21:52:02] Regions excluded: none #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> failed to create the sampler; sampling not done #> INFO [2023-01-24 21:52:02] Completed regional estimates #> INFO [2023-01-24 21:52:02] Regions with estimates: 0 #> INFO [2023-01-24 21:52:02] Regions with runtime errors: 2 #> INFO [2023-01-24 21:52:02] No target directory specified so returning timings  regional_runtimes(regional_output = regional_out$regional) #> INFO [2023-01-24 21:52:02] No target directory specified so returning timings #>      region time #> 1: testland    0 #> 2: realland    0 # }"},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Regional Summary Output — regional_summary","title":"Regional Summary Output — regional_summary","text":"Used produce summary output either internally regional_epinow externally.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regional Summary Output — regional_summary","text":"","code":"regional_summary(   regional_output = NULL,   reported_cases,   results_dir = NULL,   summary_dir = NULL,   target_date = NULL,   region_scale = \"Region\",   all_regions = TRUE,   return_output = FALSE,   plot = TRUE,   max_plot = 10,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regional Summary Output — regional_summary","text":"regional_output list output produced regional_epinow stored regional list. reported_cases data frame confirmed cases (confirm) date (date), region (region). results_dir optional character string indicating location results directory extract results . summary_dir character string giving directory store summary results. target_date character string giving target date extract results (format \"yyyy-mm-dd\"). Defaults latest available estimates. region_scale character string indicating name give regions summarised. all_regions Logical, defaults TRUE. summary plots regions returned rather just regions interest. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. plot Logical, defaults TRUE. regional summary plots produced. max_plot Numeric, defaults 10. multiplicative upper bound number cases shown plot. Based maximum number reported cases. ... Additional arguments passed report_plots.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regional Summary Output — regional_summary","text":"list summary measures plots","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regional Summary Output — regional_summary","text":"","code":"# \\donttest{ # example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- estimate_delay(rlnorm(100, log(6), 1), max_value = 30)  # example case vector from EpiSoon cases <- example_confirmed[1:30] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # run basic nowcasting pipeline out <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   output = \"region\",   rt = NULL ) #> INFO [2023-01-24 21:52:09] Producing following optional outputs: regions #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpfR2b3X/regional-epinow/2020-03-22.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpfR2b3X/epinow/2020-03-22.log #> INFO [2023-01-24 21:52:09] Reporting estimates using data up to: 2020-03-22 #> INFO [2023-01-24 21:52:09] No target directory specified so returning output #> INFO [2023-01-24 21:52:09] Producing estimates for: testland, realland #> INFO [2023-01-24 21:52:09] Regions excluded: none #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> failed to create the sampler; sampling not done #> INFO [2023-01-24 21:52:10] Completed regional estimates #> INFO [2023-01-24 21:52:10] Regions with estimates: 0 #> INFO [2023-01-24 21:52:10] Regions with runtime errors: 2 #> INFO [2023-01-24 21:52:10] No target directory specified so returning timings  regional_summary(   regional_output = out$regional,   reported_cases = cases ) #> INFO [2023-01-24 21:52:10] No summary directory specified so returning summary output #> Error in .checkTypos(e, names_x): Object 'variable' not found amongst  # }"},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Report case counts by date of report — report_cases","title":"Report case counts by date of report — report_cases","text":"Convolves latent infections reported cases via observation model. Likely removed/replaced later releases functionality drawing stan implementation.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report case counts by date of report — report_cases","text":"","code":"report_cases(   case_estimates,   case_forecast = NULL,   delays,   type = \"sample\",   reporting_effect,   CrIs = c(0.2, 0.5, 0.9) )"},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report case counts by date of report — report_cases","text":"case_estimates data.table case estimates following variables: date, sample, cases case_forecast data.table case forecasts following variables: date, sample, cases. supplied default incorporate forecasts. delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. type Character string indicating method use transform counts. Supports either \"sample\" approximates sampling \"median\" shift median distribution. reporting_effect data.table giving weekly reporting effect following variables: sample (must nowcast), effect (numeric scaling factor weekday),day (numeric 1 - 7 (1 = Monday 7 = Sunday)). supplied weekly reporting effect assumed. CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report case counts by date of report — report_cases","text":"list data.tables. first entry contains following variables sample, date cases second summarised across samples.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report case counts by date of report — report_cases","text":"","code":"# \\donttest{ # define example cases cases <- example_confirmed[1:40]  # set up example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1), mean_sd = 0.1,   sd = convert_to_logsd(2, 1), sd_sd = 0.1, max = 10 )  # Instead of running them model we use example  # data for speed in this example. cases <- cases[, cases := as.integer(confirm)] cases <- cases[, confirm := NULL][, sample := 1]  reported_cases <- report_cases(   case_estimates = cases,   delays = delay_opts(incubation_period, reporting_delay),   type = \"sample\" ) print(reported_cases) #> $samples #>     sample       date value #>  1:      1 2020-02-23     1 #>  2:      1 2020-02-24     4 #>  3:      1 2020-02-25    14 #>  4:      1 2020-02-26    19 #>  5:      1 2020-02-27    34 #>  6:      1 2020-02-28    48 #>  7:      1 2020-02-29    59 #>  8:      1 2020-03-01    81 #>  9:      1 2020-03-02   109 #> 10:      1 2020-03-03   167 #> 11:      1 2020-03-04   205 #> 12:      1 2020-03-05   266 #> 13:      1 2020-03-06   342 #> 14:      1 2020-03-07   374 #> 15:      1 2020-03-08   447 #> 16:      1 2020-03-09   577 #> 17:      1 2020-03-10   646 #> 18:      1 2020-03-11   874 #> 19:      1 2020-03-12   934 #> 20:      1 2020-03-13  1136 #> 21:      1 2020-03-14  1363 #> 22:      1 2020-03-15  1539 #> 23:      1 2020-03-16  1821 #> 24:      1 2020-03-17  2065 #> 25:      1 2020-03-18  2440 #> 26:      1 2020-03-19  2718 #> 27:      1 2020-03-20  2889 #> 28:      1 2020-03-21  3255 #> 29:      1 2020-03-22  3637 #> 30:      1 2020-03-23  4082 #> 31:      1 2020-03-24  4491 #> 32:      1 2020-03-25  4808 #> 33:      1 2020-03-26  5027 #> 34:      1 2020-03-27  5213 #> 35:      1 2020-03-28  5229 #> 36:      1 2020-03-29  5386 #> 37:      1 2020-03-30  5466 #> 38:      1 2020-03-31  5652 #> 39:      1 2020-04-01  5663 #>     sample       date value #>  #> $summarised #>           date median mean sd lower_90 lower_50 lower_20 upper_20 upper_50 #>  1: 2020-02-23      1    1 NA        1        1        1        1        1 #>  2: 2020-02-24      4    4 NA        4        4        4        4        4 #>  3: 2020-02-25     14   14 NA       14       14       14       14       14 #>  4: 2020-02-26     19   19 NA       19       19       19       19       19 #>  5: 2020-02-27     34   34 NA       34       34       34       34       34 #>  6: 2020-02-28     48   48 NA       48       48       48       48       48 #>  7: 2020-02-29     59   59 NA       59       59       59       59       59 #>  8: 2020-03-01     81   81 NA       81       81       81       81       81 #>  9: 2020-03-02    109  109 NA      109      109      109      109      109 #> 10: 2020-03-03    167  167 NA      167      167      167      167      167 #> 11: 2020-03-04    205  205 NA      205      205      205      205      205 #> 12: 2020-03-05    266  266 NA      266      266      266      266      266 #> 13: 2020-03-06    342  342 NA      342      342      342      342      342 #> 14: 2020-03-07    374  374 NA      374      374      374      374      374 #> 15: 2020-03-08    447  447 NA      447      447      447      447      447 #> 16: 2020-03-09    577  577 NA      577      577      577      577      577 #> 17: 2020-03-10    646  646 NA      646      646      646      646      646 #> 18: 2020-03-11    874  874 NA      874      874      874      874      874 #> 19: 2020-03-12    934  934 NA      934      934      934      934      934 #> 20: 2020-03-13   1136 1136 NA     1136     1136     1136     1136     1136 #> 21: 2020-03-14   1363 1363 NA     1363     1363     1363     1363     1363 #> 22: 2020-03-15   1539 1539 NA     1539     1539     1539     1539     1539 #> 23: 2020-03-16   1821 1821 NA     1821     1821     1821     1821     1821 #> 24: 2020-03-17   2065 2065 NA     2065     2065     2065     2065     2065 #> 25: 2020-03-18   2440 2440 NA     2440     2440     2440     2440     2440 #> 26: 2020-03-19   2718 2718 NA     2718     2718     2718     2718     2718 #> 27: 2020-03-20   2889 2889 NA     2889     2889     2889     2889     2889 #> 28: 2020-03-21   3255 3255 NA     3255     3255     3255     3255     3255 #> 29: 2020-03-22   3637 3637 NA     3637     3637     3637     3637     3637 #> 30: 2020-03-23   4082 4082 NA     4082     4082     4082     4082     4082 #> 31: 2020-03-24   4491 4491 NA     4491     4491     4491     4491     4491 #> 32: 2020-03-25   4808 4808 NA     4808     4808     4808     4808     4808 #> 33: 2020-03-26   5027 5027 NA     5027     5027     5027     5027     5027 #> 34: 2020-03-27   5213 5213 NA     5213     5213     5213     5213     5213 #> 35: 2020-03-28   5229 5229 NA     5229     5229     5229     5229     5229 #> 36: 2020-03-29   5386 5386 NA     5386     5386     5386     5386     5386 #> 37: 2020-03-30   5466 5466 NA     5466     5466     5466     5466     5466 #> 38: 2020-03-31   5652 5652 NA     5652     5652     5652     5652     5652 #> 39: 2020-04-01   5663 5663 NA     5663     5663     5663     5663     5663 #>           date median mean sd lower_90 lower_50 lower_20 upper_20 upper_50 #>     upper_90 #>  1:        1 #>  2:        4 #>  3:       14 #>  4:       19 #>  5:       34 #>  6:       48 #>  7:       59 #>  8:       81 #>  9:      109 #> 10:      167 #> 11:      205 #> 12:      266 #> 13:      342 #> 14:      374 #> 15:      447 #> 16:      577 #> 17:      646 #> 18:      874 #> 19:      934 #> 20:     1136 #> 21:     1363 #> 22:     1539 #> 23:     1821 #> 24:     2065 #> 25:     2440 #> 26:     2718 #> 27:     2889 #> 28:     3255 #> 29:     3637 #> 30:     4082 #> 31:     4491 #> 32:     4808 #> 33:     5027 #> 34:     5213 #> 35:     5229 #> 36:     5386 #> 37:     5466 #> 38:     5652 #> 39:     5663 #>     upper_90 #>  # }"},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":null,"dir":"Reference","previous_headings":"","what":"Report plots — report_plots","title":"Report plots — report_plots","text":"Returns key summary plots estimates. May depreciated later releases current S3 methods enhanced.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report plots — report_plots","text":"","code":"report_plots(summarised_estimates, reported, target_folder = NULL, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report plots — report_plots","text":"summarised_estimates data.table summarised estimates containing following variables: variable, median, bottom, top. also contain following estimates: R, infections, reported_cases_rt, r (rate growth). reported data.table reported cases following variables: date, confirm. target_folder Character string specifying save results (create present). ... Additional arguments passed plot_estimates().","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report plots — report_plots","text":"named list ggplot2 objects, list(infections, reports, R, growth_rate, summary), correspond summary combination (last item) leading items @seealso plot_estimates() summarised_estimates[variable == \"infections\"], summarised_estimates[variable == \"reported_cases\"], summarised_estimates[variable == \"R\"], summarised_estimates[variable == \"growth_rate\"], respectively.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report plots — report_plots","text":"","code":"# \\donttest{ # define example cases cases <- example_confirmed[1:40]  # set up example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- bootstrapped_dist_fit(rlnorm(100, log(6), 1), max_value = 30)  # run model out <- estimate_infections(cases,   stan = stan_opts(samples = 500),   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = NULL ) #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> Error in dimnames(x)$parameters: $ operator is invalid for atomic vectors  # plot infections plots <- report_plots(   summarised_estimates = out$summarised,   reported = cases ) #> Error in data.table::setDT(summarised_estimates): object 'out' not found plots #> Error in eval(expr, envir, enclos): object 'plots' not found # }"},{"path":"epiforecasts.io/EpiNow2/reference/report_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","title":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","text":"Creates snapshot summary estimates. May removed later releases S3 methods enhanced.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","text":"","code":"report_summary(   summarised_estimates,   rt_samples,   target_folder = NULL,   return_numeric = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/report_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","text":"summarised_estimates data.table summarised estimates containing following variables: variable, median, bottom, top. contain following estimates: R, infections, r (rate growth). rt_samples data.table containing Rt samples following variables: sample value. target_folder Character string specifying save results (create present). return_numeric numeric summary information returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","text":"data.table containing formatted numeric summary measures","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Rstan Options — rstan_opts","title":"Rstan Options — rstan_opts","text":"Defines list specifying arguments passed underlying rstan functions via rstan_sampling_opts() rstan_vb_opts().Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rstan Options — rstan_opts","text":"","code":"rstan_opts(object = NULL, samples = 2000, method = \"sampling\", ...)"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rstan Options — rstan_opts","text":"object Stan model object. default uses compiled package default. samples Numeric, default 2000. Overall number posterior samples. using multiple chains iterations per chain samples / chains. method character string, defaulting sampling. Currently supports rstan::sampling (\"sampling\") rstan:vb (\"vb\"). ... Additional parameters pass  underlying option functions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rstan Options — rstan_opts","text":"list arguments pass appropriate rstan functions.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rstan Options — rstan_opts","text":"","code":"rstan_opts(samples = 1000) #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // convolve two vectors #> // length of x #> // produces a convolution across the lenght specified #> vector convolve(vector x, vector y, int len) { #>   int xlen = num_elements(x); #>   int ylen = num_elements(y); #>   vector[len] convolution = rep_vector(0, len); #>   for (i in 1:xlen) { #>     for (j in 1:(min(len - i + 1, ylen))) { #>       convolution[i + j - 1] += x[i] * y[j]; #>     } #>   } #>   return(convolution); #> } #>  #> // convolve two vectors as a backwards dot product #> // y vector shoud be reversed #> // limited to the length of x and backwards looking for x indexes #> // designed for use convolve a case vector and a delay pmf #> vector convolve_dot_product(vector x, vector y, int len) { #>     int ylen = num_elements(y); #>     vector[len] z; #>     for (s in 1:len) { #>         z[s] = dot_product( #>             x[max(1, (s - ylen + 1)):s], tail(y, min(ylen, s)) #>           ); #>     } #>    return(z); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           vector delay_rev_pmf, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_rev_pmf); #>   if (delays) { #>     unobs_reports = convolve_dot_product(unobs_reports, delay_rev_pmf, t); #>     reports = unobs_reports[(seeding_time + 1):t]; #>   } else { #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> // Calculate the daily probability of reporting using parametric #> // distributions up to the maximum observed delay. #> // If sigma is 0 all the probability mass is put on n. #> // Adapted from https://github.com/epiforecasts/epinowcast #> // @author Sam Abbott #> // @author Adrian Lison #> vector discretised_pmf(real mu, real sigma, int n, int dist, #>                        int left_truncate) { #>   vector[n] pmf; #>   if (sigma > 0) { #>     vector[n + 1] upper_cdf; #>     if (dist == 0) { #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = lognormal_cdf(i - 1 + left_truncate, mu, sigma); #>       } #>     } else if (dist == 1) { #>       real alpha = mu^2 / sigma^2; #>       real beta = mu / sigma^2; #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = gamma_cdf(i - 1 + left_truncate, alpha, beta); #>       } #>     } else { #>       reject(\"Unknown distribution function provided.\"); #>     } #>     // discretise #>     pmf = upper_cdf[2:(n + 1)] - upper_cdf[1:n]; #>     // normalize #>     pmf = pmf / (upper_cdf[n + 1] - upper_cdf[1]); #>   } else { #>     // delta function #>     pmf = rep_vector(0, n); #>     pmf[n] = 1; #>   } #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // combined fixed/variable pmfs #> vector combine_pmfs(vector fixed_pmf, real[] pmf_mu, real[] pmf_sigma, int[] pmf_n, int[] dist, int len, int left_truncate, int reverse_pmf) { #>   int n_fixed = num_elements(fixed_pmf); #>   int n_variable = num_elements(pmf_mu); #>   vector[len] pmf = rep_vector(0, len); #>   if (n_fixed > 0) { #>     pmf[1:n_fixed] = fixed_pmf; #>   } else if (n_variable > 0) { #>     pmf[1] = 1; #>   } #>   for (s in 1:n_variable) { #>     vector[pmf_n[s]] variable_pmf; #>     variable_pmf = discretised_pmf(pmf_mu[s], pmf_sigma[s], pmf_n[s], dist[s], left_truncate); #>     pmf = convolve(pmf, variable_pmf, len); #>   } #>   if (reverse_pmf) { #>     pmf = reverse_mf(pmf); #>   } #>   return(pmf); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, #>                int[] delay_dist, int weight) { #>     int mean_delays = num_elements(delay_mean); #>     int sd_delays = num_elements(delay_sd); #>     if (mean_delays) { #>       for (s in 1:mean_delays) { #>         if (delay_mean_sd[s] > 0) { #>           // uncertain mean #>           target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           // if a distribution with postive support only truncate the prior #>           if (delay_dist[s]) { #>             target += -normal_lccdf(0 | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           } #>         } #>       } #>     } #>     if (sd_delays) { #>       for (s in 1:sd_delays) { #>         if (delay_sd_sd[s] > 0) { #>           // uncertain sd #>           target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>           target += -normal_lccdf(0 | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>         } #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_rev_pmf, #>                            int seeding_time, int index){ #>   int gt_max = num_elements(gt_rev_pmf); #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - gt_max)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(gt_max, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product( #>     infections[inf_start:inf_end], tail(gt_rev_pmf, pmf_accessed) #>   ); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, vector gt_rev_pmf, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_rev_pmf, uot, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, vector trunc_rev_cmf, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = num_elements(trunc_rev_cmf); #>   int first_t = t - trunc_max + 1; #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ trunc_rev_cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* trunc_rev_cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     if (trunc_mean_sd[1] > 0) { #>       // uncertain mean #>       truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     } #>     if (trunc_sd_sd[1] > 0) { #>       // uncertain sd #>       truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>     } #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     vector gt_rev_pmf, int smooth) { #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_rev_pmf, seeding_time, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   int n_uncertain_mean_delays;   // no. of delay distributions with uncertain mean #>   int n_uncertain_sd_delays;     // no. of delay distributions with uncertain sd #>   int n_fixed_delays;     // no. of delay distributions with uncertain sd #>   // indices of delay distributions with uncertainty #>   int<lower = 1, upper = delays> uncertain_mean_delays[n_uncertain_mean_delays]; #>   int<lower = 1, upper = delays> uncertain_sd_delays[n_uncertain_sd_delays]; #>   int<lower = 1, upper = delays> fixed_delays[n_fixed_delays]; #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int<lower = 1> delay_max[delays];       // maximum incubation period #>   int delay_dist[delays];       // 0 = lognormal; 1 = gamma #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd[1];                   // prior sd of mean generation time #>   real gt_mean_mean[1];                 // prior mean of mean generation time #>   real gt_sd_mean[1];                   // prior mean of sd of generation time #>   real gt_sd_sd[1];                     // prior sd of sd of generation time #>   int<lower = 1> gt_max[1];                        // maximum generation time #>   int gt_fixed[1];                      // 0 = variable gt; 1 = fixed gt #>   int gt_dist[1];                    // distribution (0 = lognormal, 1 = gamma) #>   int gt_weight;                    #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int<lower = 1> trunc_max[truncation];    // maximum truncation supported #>   int trunc_fixed[truncation];    // whether the truncation distribution is fixed #>   int trunc_dist[truncation];    // 0 = lognormal; 1 = gamma #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #>  #>   int delay_max_fixed = (n_fixed_delays == 0 ? 0 : #>     sum(delay_max[fixed_delays]) - num_elements(fixed_delays) + 1); #>   int delay_max_total = (delays == 0 ? 0 : #>     sum(delay_max) - num_elements(delay_max) + 1); #>   vector[gt_fixed[1] ? gt_max[1] : 0] gt_fixed_pmf; #>   vector[truncation && trunc_fixed[1] ? trunc_max[1] : 0] trunc_fixed_pmf; #>   vector[delay_max_fixed] delays_fixed_pmf; #>  #>   if (gt_fixed[1]) { #>     gt_fixed_pmf = discretised_pmf(gt_mean_mean[1], gt_sd_mean[1], gt_max[1], gt_dist[1], 1); #>   } #>   if (truncation && trunc_fixed[1]) { #>     trunc_fixed_pmf = discretised_pmf( #>       trunc_mean_mean[1], trunc_sd_mean[1], trunc_max[1], trunc_dist[1], 0 #>     ); #>   } #>   if (n_fixed_delays) { #>     delays_fixed_pmf = combine_pmfs( #>       to_vector([ 1 ]), delay_mean_mean[fixed_delays], #>       delay_sd_mean[fixed_delays], delay_max[fixed_delays],  #>       delay_dist[fixed_delays], delay_max_fixed, 0, 0 #>     ); #>   } #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<upper = gt_max[1]> gt_mean[estimate_r && gt_mean_sd[1] > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd[1] > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[n_uncertain_mean_delays];         // mean of delays #>   real<lower = 0> delay_sd[n_uncertain_sd_delays];  // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0, upper = 1> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real trunc_mean[truncation && !trunc_fixed[1]];        // mean of truncation #>   real<lower = 0> trunc_sd[truncation && !trunc_fixed[1]]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     vector[gt_max[1]] gt_rev_pmf; #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean, gt_sd, gt_max, gt_dist, gt_max[1], 1, 1 #>     ); #>     R = update_Rt( #>       ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary #>     ); #>     infections = generate_infections( #>       R, seeding_time, gt_rev_pmf, initial_infections, initial_growth, pop, #>       future_time #>     ); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections( #>       shifted_cases, noise, fixed, backcalc_prior #>     ); #>   } #>   // convolve from latent infections to mean of observations #>   { #>     vector[delay_max_total] delay_rev_pmf; #>     delay_rev_pmf = combine_pmfs( #>       delays_fixed_pmf, delay_mean, delay_sd, delay_max, delay_dist, delay_max_total, 0, 1 #>     ); #>     reports = convolve_to_report(infections, delay_rev_pmf, seeding_time); #>   } #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    vector[trunc_max[1]] trunc_rev_cmf; #>    trunc_rev_cmf = reverse_mf(cumulative_sum(combine_pmfs( #>      trunc_fixed_pmf, trunc_mean, trunc_sd, trunc_max, trunc_dist, trunc_max[1], 0, 0 #>    ))); #>    obs_reports = truncate(reports[1:ot], trunc_rev_cmf, 0); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean[uncertain_mean_delays], #>     delay_mean_sd[uncertain_mean_delays], #>     delay_sd, delay_sd_mean[uncertain_sd_delays], #>     delay_sd_sd[uncertain_sd_delays], delay_dist[uncertain_mean_delays], t #>   ); #>   // priors for truncation #>   delays_lp( #>     trunc_mean, trunc_sd, #>     trunc_mean_mean, trunc_mean_sd, #>     trunc_sd_mean, trunc_sd_sd, #>     trunc_dist, 1 #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     delays_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, gt_dist, gt_weight #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0, 1]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd[1] > 0 ? gt_mean[1] : gt_mean_mean[1]); #>     real set_gt_sd = (gt_sd_sd [1]> 0 ? gt_sd[1] : gt_sd_mean[1]); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   } else { #>     // sample generation time #>     real gt_mean_sample[1]; #>     real gt_sd_sample[1]; #>     vector[gt_max[1]] gt_rev_pmf; #>  #>     gt_mean_sample[1] = (gt_mean_sd[1] > 0 ? normal_rng(gt_mean_mean[1], gt_mean_sd[1]) : gt_mean_mean[1]); #>     gt_sd_sample[1] = (gt_sd_sd[1] > 0 ? normal_rng(gt_sd_mean[1], gt_sd_sd[1]) : gt_sd_mean[1]); #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean_sample, gt_sd_sample, gt_max, gt_dist, gt_max[1], #>       1, 1 #>     ); #>  #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_rev_pmf, rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample[1], gt_sd_sample[1]); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"sampling\" #>  #> $cores #> [1] 1 #>  #> $warmup #> [1] 250 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 97720352 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 500 #>   # using vb rstan_opts(method = \"vb\") #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // convolve two vectors #> // length of x #> // produces a convolution across the lenght specified #> vector convolve(vector x, vector y, int len) { #>   int xlen = num_elements(x); #>   int ylen = num_elements(y); #>   vector[len] convolution = rep_vector(0, len); #>   for (i in 1:xlen) { #>     for (j in 1:(min(len - i + 1, ylen))) { #>       convolution[i + j - 1] += x[i] * y[j]; #>     } #>   } #>   return(convolution); #> } #>  #> // convolve two vectors as a backwards dot product #> // y vector shoud be reversed #> // limited to the length of x and backwards looking for x indexes #> // designed for use convolve a case vector and a delay pmf #> vector convolve_dot_product(vector x, vector y, int len) { #>     int ylen = num_elements(y); #>     vector[len] z; #>     for (s in 1:len) { #>         z[s] = dot_product( #>             x[max(1, (s - ylen + 1)):s], tail(y, min(ylen, s)) #>           ); #>     } #>    return(z); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           vector delay_rev_pmf, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_rev_pmf); #>   if (delays) { #>     unobs_reports = convolve_dot_product(unobs_reports, delay_rev_pmf, t); #>     reports = unobs_reports[(seeding_time + 1):t]; #>   } else { #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> // Calculate the daily probability of reporting using parametric #> // distributions up to the maximum observed delay. #> // If sigma is 0 all the probability mass is put on n. #> // Adapted from https://github.com/epiforecasts/epinowcast #> // @author Sam Abbott #> // @author Adrian Lison #> vector discretised_pmf(real mu, real sigma, int n, int dist, #>                        int left_truncate) { #>   vector[n] pmf; #>   if (sigma > 0) { #>     vector[n + 1] upper_cdf; #>     if (dist == 0) { #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = lognormal_cdf(i - 1 + left_truncate, mu, sigma); #>       } #>     } else if (dist == 1) { #>       real alpha = mu^2 / sigma^2; #>       real beta = mu / sigma^2; #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = gamma_cdf(i - 1 + left_truncate, alpha, beta); #>       } #>     } else { #>       reject(\"Unknown distribution function provided.\"); #>     } #>     // discretise #>     pmf = upper_cdf[2:(n + 1)] - upper_cdf[1:n]; #>     // normalize #>     pmf = pmf / (upper_cdf[n + 1] - upper_cdf[1]); #>   } else { #>     // delta function #>     pmf = rep_vector(0, n); #>     pmf[n] = 1; #>   } #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // combined fixed/variable pmfs #> vector combine_pmfs(vector fixed_pmf, real[] pmf_mu, real[] pmf_sigma, int[] pmf_n, int[] dist, int len, int left_truncate, int reverse_pmf) { #>   int n_fixed = num_elements(fixed_pmf); #>   int n_variable = num_elements(pmf_mu); #>   vector[len] pmf = rep_vector(0, len); #>   if (n_fixed > 0) { #>     pmf[1:n_fixed] = fixed_pmf; #>   } else if (n_variable > 0) { #>     pmf[1] = 1; #>   } #>   for (s in 1:n_variable) { #>     vector[pmf_n[s]] variable_pmf; #>     variable_pmf = discretised_pmf(pmf_mu[s], pmf_sigma[s], pmf_n[s], dist[s], left_truncate); #>     pmf = convolve(pmf, variable_pmf, len); #>   } #>   if (reverse_pmf) { #>     pmf = reverse_mf(pmf); #>   } #>   return(pmf); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, #>                int[] delay_dist, int weight) { #>     int mean_delays = num_elements(delay_mean); #>     int sd_delays = num_elements(delay_sd); #>     if (mean_delays) { #>       for (s in 1:mean_delays) { #>         if (delay_mean_sd[s] > 0) { #>           // uncertain mean #>           target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           // if a distribution with postive support only truncate the prior #>           if (delay_dist[s]) { #>             target += -normal_lccdf(0 | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           } #>         } #>       } #>     } #>     if (sd_delays) { #>       for (s in 1:sd_delays) { #>         if (delay_sd_sd[s] > 0) { #>           // uncertain sd #>           target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>           target += -normal_lccdf(0 | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>         } #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_rev_pmf, #>                            int seeding_time, int index){ #>   int gt_max = num_elements(gt_rev_pmf); #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - gt_max)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(gt_max, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product( #>     infections[inf_start:inf_end], tail(gt_rev_pmf, pmf_accessed) #>   ); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, vector gt_rev_pmf, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_rev_pmf, uot, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, vector trunc_rev_cmf, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = num_elements(trunc_rev_cmf); #>   int first_t = t - trunc_max + 1; #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ trunc_rev_cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* trunc_rev_cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     if (trunc_mean_sd[1] > 0) { #>       // uncertain mean #>       truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     } #>     if (trunc_sd_sd[1] > 0) { #>       // uncertain sd #>       truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>     } #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     vector gt_rev_pmf, int smooth) { #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_rev_pmf, seeding_time, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   int n_uncertain_mean_delays;   // no. of delay distributions with uncertain mean #>   int n_uncertain_sd_delays;     // no. of delay distributions with uncertain sd #>   int n_fixed_delays;     // no. of delay distributions with uncertain sd #>   // indices of delay distributions with uncertainty #>   int<lower = 1, upper = delays> uncertain_mean_delays[n_uncertain_mean_delays]; #>   int<lower = 1, upper = delays> uncertain_sd_delays[n_uncertain_sd_delays]; #>   int<lower = 1, upper = delays> fixed_delays[n_fixed_delays]; #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int<lower = 1> delay_max[delays];       // maximum incubation period #>   int delay_dist[delays];       // 0 = lognormal; 1 = gamma #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd[1];                   // prior sd of mean generation time #>   real gt_mean_mean[1];                 // prior mean of mean generation time #>   real gt_sd_mean[1];                   // prior mean of sd of generation time #>   real gt_sd_sd[1];                     // prior sd of sd of generation time #>   int<lower = 1> gt_max[1];                        // maximum generation time #>   int gt_fixed[1];                      // 0 = variable gt; 1 = fixed gt #>   int gt_dist[1];                    // distribution (0 = lognormal, 1 = gamma) #>   int gt_weight;                    #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int<lower = 1> trunc_max[truncation];    // maximum truncation supported #>   int trunc_fixed[truncation];    // whether the truncation distribution is fixed #>   int trunc_dist[truncation];    // 0 = lognormal; 1 = gamma #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #>  #>   int delay_max_fixed = (n_fixed_delays == 0 ? 0 : #>     sum(delay_max[fixed_delays]) - num_elements(fixed_delays) + 1); #>   int delay_max_total = (delays == 0 ? 0 : #>     sum(delay_max) - num_elements(delay_max) + 1); #>   vector[gt_fixed[1] ? gt_max[1] : 0] gt_fixed_pmf; #>   vector[truncation && trunc_fixed[1] ? trunc_max[1] : 0] trunc_fixed_pmf; #>   vector[delay_max_fixed] delays_fixed_pmf; #>  #>   if (gt_fixed[1]) { #>     gt_fixed_pmf = discretised_pmf(gt_mean_mean[1], gt_sd_mean[1], gt_max[1], gt_dist[1], 1); #>   } #>   if (truncation && trunc_fixed[1]) { #>     trunc_fixed_pmf = discretised_pmf( #>       trunc_mean_mean[1], trunc_sd_mean[1], trunc_max[1], trunc_dist[1], 0 #>     ); #>   } #>   if (n_fixed_delays) { #>     delays_fixed_pmf = combine_pmfs( #>       to_vector([ 1 ]), delay_mean_mean[fixed_delays], #>       delay_sd_mean[fixed_delays], delay_max[fixed_delays],  #>       delay_dist[fixed_delays], delay_max_fixed, 0, 0 #>     ); #>   } #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<upper = gt_max[1]> gt_mean[estimate_r && gt_mean_sd[1] > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd[1] > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[n_uncertain_mean_delays];         // mean of delays #>   real<lower = 0> delay_sd[n_uncertain_sd_delays];  // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0, upper = 1> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real trunc_mean[truncation && !trunc_fixed[1]];        // mean of truncation #>   real<lower = 0> trunc_sd[truncation && !trunc_fixed[1]]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     vector[gt_max[1]] gt_rev_pmf; #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean, gt_sd, gt_max, gt_dist, gt_max[1], 1, 1 #>     ); #>     R = update_Rt( #>       ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary #>     ); #>     infections = generate_infections( #>       R, seeding_time, gt_rev_pmf, initial_infections, initial_growth, pop, #>       future_time #>     ); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections( #>       shifted_cases, noise, fixed, backcalc_prior #>     ); #>   } #>   // convolve from latent infections to mean of observations #>   { #>     vector[delay_max_total] delay_rev_pmf; #>     delay_rev_pmf = combine_pmfs( #>       delays_fixed_pmf, delay_mean, delay_sd, delay_max, delay_dist, delay_max_total, 0, 1 #>     ); #>     reports = convolve_to_report(infections, delay_rev_pmf, seeding_time); #>   } #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    vector[trunc_max[1]] trunc_rev_cmf; #>    trunc_rev_cmf = reverse_mf(cumulative_sum(combine_pmfs( #>      trunc_fixed_pmf, trunc_mean, trunc_sd, trunc_max, trunc_dist, trunc_max[1], 0, 0 #>    ))); #>    obs_reports = truncate(reports[1:ot], trunc_rev_cmf, 0); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean[uncertain_mean_delays], #>     delay_mean_sd[uncertain_mean_delays], #>     delay_sd, delay_sd_mean[uncertain_sd_delays], #>     delay_sd_sd[uncertain_sd_delays], delay_dist[uncertain_mean_delays], t #>   ); #>   // priors for truncation #>   delays_lp( #>     trunc_mean, trunc_sd, #>     trunc_mean_mean, trunc_mean_sd, #>     trunc_sd_mean, trunc_sd_sd, #>     trunc_dist, 1 #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     delays_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, gt_dist, gt_weight #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0, 1]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd[1] > 0 ? gt_mean[1] : gt_mean_mean[1]); #>     real set_gt_sd = (gt_sd_sd [1]> 0 ? gt_sd[1] : gt_sd_mean[1]); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   } else { #>     // sample generation time #>     real gt_mean_sample[1]; #>     real gt_sd_sample[1]; #>     vector[gt_max[1]] gt_rev_pmf; #>  #>     gt_mean_sample[1] = (gt_mean_sd[1] > 0 ? normal_rng(gt_mean_mean[1], gt_mean_sd[1]) : gt_mean_mean[1]); #>     gt_sd_sample[1] = (gt_sd_sd[1] > 0 ? normal_rng(gt_sd_mean[1], gt_sd_sd[1]) : gt_sd_mean[1]); #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean_sample, gt_sd_sample, gt_max, gt_dist, gt_max[1], #>       1, 1 #>     ); #>  #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_rev_pmf, rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample[1], gt_sd_sample[1]); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"vb\" #>  #> $trials #> [1] 10 #>  #> $iter #> [1] 10000 #>  #> $output_samples #> [1] 2000 #>"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Rstan Sampling Options — rstan_sampling_opts","title":"Rstan Sampling Options — rstan_sampling_opts","text":"Defines list specifying arguments passed rstan::sampling. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rstan Sampling Options — rstan_sampling_opts","text":"","code":"rstan_sampling_opts(   cores = getOption(\"mc.cores\", 1L),   warmup = 250,   samples = 2000,   chains = 4,   control = list(),   save_warmup = FALSE,   seed = as.integer(runif(1, 1, 1e+08)),   future = FALSE,   max_execution_time = Inf,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rstan Sampling Options — rstan_sampling_opts","text":"cores Number cores use executing chains parallel, defaults 1 recommended set mc.cores option many processors hardware RAM allow (number chains). warmup Numeric, defaults 250. Number warmup samples per chain. samples Numeric, default 2000. Overall number posterior samples. using multiple chains iterations per chain samples / chains. chains Numeric, defaults 4. Number MCMC chains use. control List, defaults empty. control parameters pass underlying rstan function. default adapt_delta = 0.95 max_treedepth = 15 though settings can overwritten. save_warmup Logical, defaults FALSE. warmup progress saved. seed Numeric, defaults uniform random number 1 1e8. Seed sampling process. future Logical, defaults FALSE. stan chains run parallel using future. allows users chains fail gracefully (.e combined max_execution_time). combined call future::plan max_execution_time Numeric, defaults Inf (seconds). set kill processing chain finished within specified timeout. 2 chains finish successfully estimates still returned. less 2 chains return within allowed time estimation fail informative error. ... Additional parameters pass rstan::sampling.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rstan Sampling Options — rstan_sampling_opts","text":"list arguments pass rstan::sampling","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rstan Sampling Options — rstan_sampling_opts","text":"","code":"rstan_sampling_opts(samples = 2000) #> $cores #> [1] 1 #>  #> $warmup #> [1] 250 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 22140682 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 750 #>"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Rstan Variational Bayes Options — rstan_vb_opts","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"Defines list specifying arguments passed rstan::vb. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"","code":"rstan_vb_opts(samples = 2000, trials = 10, iter = 10000, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"samples Numeric, default 2000. Overall number approximate posterior samples. trials Numeric, defaults 10. Number attempts use rstan::vb failing. iter Numeric, defaulting 10000. Number iterations use rtan::vb. ... Additional parameters pass rstan::vb.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"list arguments pass rstan::vb","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"","code":"rstan_vb_opts(samples = 1000) #> $trials #> [1] 10 #>  #> $iter #> [1] 10000 #>  #> $output_samples #> [1] 1000 #>"},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-Varying Reproduction Number Options — rt_opts","title":"Time-Varying Reproduction Number Options — rt_opts","text":"Defines list specifying optional arguments time-varying reproduction number. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-Varying Reproduction Number Options — rt_opts","text":"","code":"rt_opts(   prior = list(mean = 1, sd = 1),   use_rt = TRUE,   rw = 0,   use_breakpoints = TRUE,   future = \"latest\",   gp_on = \"R_t-1\",   pop = 0 )"},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-Varying Reproduction Number Options — rt_opts","text":"prior List containing named numeric elements \"mean\" \"sd\". mean standard deviation log normal Rt prior. Defaults mean 1 standard deviation 1. use_rt Logical, defaults TRUE. Rt used generate infections hence reported cases. rw Numeric step size random walk, defaults 0. specify weekly random walk set rw = 7. custom break point settings consider passing breakpoints variable outlined next section. use_breakpoints Logical, defaults TRUE. break points used present breakpoint variable input data. Break points defined 1 present otherwise 0. default breakpoints fit jointly global non-parametric effect represent conservative estimate break point changes (alter setting gp = NULL). future character string integer. argument indicates set future Rt values. Supported options project using Rt model (\"project\"), use latest estimate based partial data (\"latest\"), use latest estimate based data 50% complete (\"estimate\"). integer supplied Rt estimate many days future (past negative) past used forwards time. gp_on Character string, defaulting  \"R_t-1\". Indicates Gaussian process, use, applied Rt.  Currently supported options applying Gaussian process last estimated Rt (.e Rt = Rt-1 * GP), applying Gaussian process global mean (.e Rt = R0 * GP). produced comparable results data sparse method relying global mean revert real time estimates, may desirable. pop Integer, defaults 0. Susceptible population initially present. Used adjust Rt estimates otherwise fixed based proportion population susceptible. set 0 population adjustment done.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time-Varying Reproduction Number Options — rt_opts","text":"list settings defining time-varying reproduction number","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-Varying Reproduction Number Options — rt_opts","text":"","code":"# default settings rt_opts() #> $prior #> $prior$mean #> [1] 1 #>  #> $prior$sd #> [1] 1 #>  #>  #> $use_rt #> [1] TRUE #>  #> $rw #> [1] 0 #>  #> $use_breakpoints #> [1] TRUE #>  #> $future #> [1] \"latest\" #>  #> $pop #> [1] 0 #>  #> $gp_on #> [1] \"R_t-1\" #>   # add a custom length scale rt_opts(prior = list(mean = 2, sd = 1)) #> $prior #> $prior$mean #> [1] 2 #>  #> $prior$sd #> [1] 1 #>  #>  #> $use_rt #> [1] TRUE #>  #> $rw #> [1] 0 #>  #> $use_breakpoints #> [1] TRUE #>  #> $future #> [1] \"latest\" #>  #> $pop #> [1] 0 #>  #> $gp_on #> [1] \"R_t-1\" #>   # add a weekly random walk rt_opts(rw = 7) #> $prior #> $prior$mean #> [1] 1 #>  #> $prior$sd #> [1] 1 #>  #>  #> $use_rt #> [1] TRUE #>  #> $rw #> [1] 7 #>  #> $use_breakpoints #> [1] TRUE #>  #> $future #> [1] \"latest\" #>  #> $pop #> [1] 0 #>  #> $gp_on #> [1] \"R_t-1\" #>"},{"path":"epiforecasts.io/EpiNow2/reference/run_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Run epinow with Regional Processing Code — run_region","title":"Run epinow with Regional Processing Code — run_region","text":"Internal function handles calling epinow. Future work extend function better handle stan logs allow user modify settings regions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/run_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run epinow with Regional Processing Code — run_region","text":"","code":"run_region(   target_region,   generation_time,   delays,   truncation,   rt,   backcalc,   gp,   obs,   stan,   horizon,   CrIs,   reported_cases,   target_folder,   target_date,   return_output,   output,   complete_logger,   verbose,   progress_fn,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/run_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run epinow with Regional Processing Code — run_region","text":"target_region Character string indicating region evaluated generation_time call generation_time_opts() defining generation time distribution used. backwards compatibility list summary parameters can also passed. delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. horizon Numeric, defaults 7. Number days future forecast. CrIs Numeric vector credible intervals calculate. reported_cases data frame confirmed cases (confirm) date (date), region (region). target_folder Character string specifying save results (create present). target_date Date, defaults maximum found data specified. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. output character vector optional output return. Supported options individual regional estimates (\"regions\"),  samples (\"samples\"), plots (\"plots\"), copying individual region dated folder latest folder (target_folder null, set using \"latest\"), stan fit underlying model (\"fit\"), overall summary across regions (\"summary\"). default return samples plots alongside summarised estimates summary statistics. target_folder NULL default also copy results latest folder. complete_logger Character string indicating logger output completion estimation . verbose Logical defaults FALSE. Outputs verbose progress messages console epinow. progress_fn Function returned progressr::progressor. Allows use progress bar. ... Pass additional arguments epinow. See documentation epinow details.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/run_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run epinow with Regional Processing Code — run_region","text":"list processed output produced process_region","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate Sampling a Distribution using Counts — sample_approx_dist","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"Convolves cases PMF function. function soon removed replaced robust stan implementation.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"","code":"sample_approx_dist(   cases = NULL,   dist_fn = NULL,   max_value = 120,   earliest_allowed_mapped = NULL,   direction = \"backwards\",   type = \"sample\",   truncate_future = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"cases dataframe cases (date order) following variables: date cases. dist_fn Function takes two arguments first numeric second logical (defined dist). return probability density sample defined distribution. See examples . max_value Numeric, maximum value allow. Defaults 120 days earliest_allowed_mapped character string representing date (\"2020-01-01\"). Indicates earliest allowed mapped value. direction Character string, defato \"backwards\". Direction map cases. Supports either \"backwards\" \"forwards\". type Character string indicating method use transform counts. Supports either \"sample\" approximates sampling \"median\" shift median distribution. truncate_future Logical, cases truncated occur first date reported data. Defaults TRUE.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"data.table cases date onset","code":""},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"","code":"# \\donttest{ cases <- example_confirmed cases <- cases[, cases := as.integer(confirm)] print(cases) #>            date confirm cases #>   1: 2020-02-22      14    14 #>   2: 2020-02-23      62    62 #>   3: 2020-02-24      53    53 #>   4: 2020-02-25      97    97 #>   5: 2020-02-26      93    93 #>  ---                          #> 126: 2020-06-26     296   296 #> 127: 2020-06-27     255   255 #> 128: 2020-06-28     175   175 #> 129: 2020-06-29     174   174 #> 130: 2020-06-30     126   126  # total cases sum(cases$cases) #> [1] 240581  delay_fn <- function(n, dist, cum) {   if (dist) {     pgamma(n + 0.9999, 2, 1) - pgamma(n - 1e-5, 2, 1)   } else {     as.integer(rgamma(n, 2, 1))   } }  onsets <- sample_approx_dist(   cases = cases,   dist_fn = delay_fn )  # estimated onset distribution print(onsets) #>            date cases #>   1: 2020-02-14     1 #>   2: 2020-02-15     0 #>   3: 2020-02-16     0 #>   4: 2020-02-17     0 #>   5: 2020-02-18     3 #>  ---                  #> 134: 2020-06-26   214 #> 135: 2020-06-27   176 #> 136: 2020-06-28   116 #> 137: 2020-06-29    89 #> 138: 2020-06-30    36  # check that sum is equal to reported cases total_onsets <- median(   purrr::map_dbl(     1:10,     ~ sum(sample_approx_dist(       cases = cases,       dist_fn = delay_fn     )$cases)   ) ) total_onsets #> [1] 240650   # map from onset cases to reported reports <- sample_approx_dist(   cases = cases,   dist_fn = delay_fn,   direction = \"forwards\" )   # map from onset cases to reported using a mean shift reports <- sample_approx_dist(   cases = cases,   dist_fn = delay_fn,   direction = \"forwards\",   type = \"median\" ) # }"},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Save Estimated Infections — save_estimate_infections","title":"Save Estimated Infections — save_estimate_infections","text":"Saves output estimate_infections target directory.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save Estimated Infections — save_estimate_infections","text":"","code":"save_estimate_infections(   estimates,   target_folder = NULL,   samples = TRUE,   return_fit = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save Estimated Infections — save_estimate_infections","text":"estimates List data frames output estimate_infections target_folder Character string specifying save results (create present). samples Logical, defaults TRUE. samples saved return_fit Logical, defaults TRUE. fit stan object returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save Estimated Infections — save_estimate_infections","text":"return value, called side effects","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Save Estimated Infections — save_estimate_infections","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Save Observed Data — save_input","title":"Save Observed Data — save_input","text":"Saves observed data target location given.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save Observed Data — save_input","text":"","code":"save_input(reported_cases, target_folder)"},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save Observed Data — save_input","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. target_folder Character string specifying save results (create present).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save Observed Data — save_input","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Save Observed Data — save_input","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Secondary Reports Options — secondary_opts","title":"Secondary Reports Options — secondary_opts","text":"Returns list options defining secondary model used estimate_secondary(). model combination convolution previously observed primary reports combined current primary reports (either additive subtractive). can optionally cumulative. See documentation type sensible options cover use cases returned values secondary_opts() currently supported options.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Secondary Reports Options — secondary_opts","text":"","code":"secondary_opts(type = \"incidence\", ...)"},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Secondary Reports Options — secondary_opts","text":"type character string indicating type observation secondary reports . Options include: \"incidence\": Assumes secondary reports equal convolution previously observed primary reported cases. example application deaths infectious disease predicted reported cases disease (estimated infections). \"prevalence\": Assumes secondary reports cumulative defined currently observed primary reports minus convolution secondary reports. example application hospital bed usage predicted hospital admissions. ... Overwrite options defined type. See returned values options can passed.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Secondary Reports Options — secondary_opts","text":"list binary options summarising secondary model used estimate_secondary(). Options returned cumulative (secondary report cumulative), historic (convolution primary reported cases used predict secondary reported cases), primary_hist_additive (historic convolution primary reported cases additive subtractive), current (currently observed primary reported cases contribute current secondary reported cases), primary_current_additive (current primary reported cases additive subtractive).","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Secondary Reports Options — secondary_opts","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Secondary Reports Options — secondary_opts","text":"","code":"# incidence model secondary_opts(\"incidence\") #> $cumulative #> [1] 0 #>  #> $historic #> [1] 1 #>  #> $primary_hist_additive #> [1] 1 #>  #> $current #> [1] 0 #>  #> $primary_current_additive #> [1] 0 #>   # prevalence model secondary_opts(\"prevalence\") #> $cumulative #> [1] 1 #>  #> $historic #> [1] 1 #>  #> $primary_hist_additive #> [1] 0 #>  #> $current #> [1] 1 #>  #> $primary_current_additive #> [1] 1 #>"},{"path":"epiforecasts.io/EpiNow2/reference/set_dt_single_thread.html","id":null,"dir":"Reference","previous_headings":"","what":"Set to Single Threading — set_dt_single_thread","title":"Set to Single Threading — set_dt_single_thread","text":"function sets threads used data.table 1 parent function restores initial data.table threads function exits. primarily used internal function inside functions generally used .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/set_dt_single_thread.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set to Single Threading — set_dt_single_thread","text":"","code":"set_dt_single_thread()"},{"path":"epiforecasts.io/EpiNow2/reference/set_dt_single_thread.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set to Single Threading — set_dt_single_thread","text":"environment parent frame named \"dt_settings\"","code":""},{"path":"epiforecasts.io/EpiNow2/reference/set_dt_single_thread.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set to Single Threading — set_dt_single_thread","text":"","code":"# \\donttest{ data.table::setDTthreads(2) test_function <- function() {   set_dt_single_thread()    print(data.table::getDTthreads()) } test_function() #> [1] 1 data.table::getDTthreads() #> [1] 2 # }"},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup Default Logging — setup_default_logging","title":"Setup Default Logging — setup_default_logging","text":"Sets default logging. Usage logging currently explored current setup log stan errors progress.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup Default Logging — setup_default_logging","text":"","code":"setup_default_logging(   logs = tempdir(check = TRUE),   mirror_epinow = FALSE,   target_date = NULL )"},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup Default Logging — setup_default_logging","text":"logs Character path indicating target folder store log information. Defaults temporary directory specified. Default logging can disabled logs set NULL. specifying custom logging setup code setup_default_logging setup_logging function sensible place start. mirror_epinow Logical, defaults FALSE. internal logging returned epinow console. target_date Date, defaults maximum found data specified.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup Default Logging — setup_default_logging","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Setup Default Logging — setup_default_logging","text":"","code":"setup_default_logging() #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpfR2b3X/regional-epinow/latest.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpfR2b3X/epinow/latest.log"},{"path":"epiforecasts.io/EpiNow2/reference/setup_dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to Data Table — setup_dt","title":"Convert to Data Table — setup_dt","text":"Convenience function sets number data.table cores 1 maps input data.table","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to Data Table — setup_dt","text":"","code":"setup_dt(reported_cases)"},{"path":"epiforecasts.io/EpiNow2/reference/setup_dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to Data Table — setup_dt","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to Data Table — setup_dt","text":"data table","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_future.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up Future Backend — setup_future","title":"Set up Future Backend — setup_future","text":"utility function aims streamline set required future backend sensible defaults users regional_epinow. advanced users recommended setup future backend based available resources.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_future.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up Future Backend — setup_future","text":"","code":"setup_future(   reported_cases,   strategies = c(\"multisession\", \"multisession\"),   min_cores_per_worker = 4 )"},{"path":"epiforecasts.io/EpiNow2/reference/setup_future.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up Future Backend — setup_future","text":"reported_cases data frame confirmed cases (confirm) date (date), region (region). strategies vector length 1 2 strategies pass future::plan. Nesting parallelisation top level . default set nesting parallelisation using future::multisession (future::multicore likely faster option supported platforms). single level parallelisation use single strategy future::plan directly. See ?future::plan options. min_cores_per_worker Numeric, minimum number cores per worker. Defaults 4 assumes 4 MCMC chains use per region.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_future.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up Future Backend — setup_future","text":"Numeric number cores use per worker. greater 1 pass stan_args = list(cores = \"output setup future\") use future = TRUE. single strategy used nothing returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_logging.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup Logging — setup_logging","title":"Setup Logging — setup_logging","text":"Sets futile.logger logging, integrated EpiNow2. See documentation futile.logger full details. default EpiNow2 prints logs \"INFO\" level returns console. Usage logging currently explored current setup log stan errors progress.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_logging.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup Logging — setup_logging","text":"","code":"setup_logging(   threshold = \"INFO\",   file = NULL,   mirror_to_console = FALSE,   name = \"EpiNow2\" )"},{"path":"epiforecasts.io/EpiNow2/reference/setup_logging.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup Logging — setup_logging","text":"threshold Character string indicating logging level see (?futile.logger details available options). Defaults \"INFO\". file Character string indicating path save logs . default logs written console. mirror_to_console Logical, defaults FALSE. saving logs file also duplicated console. name Character string defaulting EpiNow2. indicates name logger setup. default logger EpiNow2 called EpiNow2. Nested options include: Epinow2.epinow controls logging epinow nested functions, EpiNow2.epinow.estimate_infections (logging estimate_infections), EpiNow2.epinow.estimate_infections.fit (logging fitting functions).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_logging.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup Logging — setup_logging","text":"Nothing","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_target_folder.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup Target Folder for Saving — setup_target_folder","title":"Setup Target Folder for Saving — setup_target_folder","text":"Sets folders saving results","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_target_folder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup Target Folder for Saving — setup_target_folder","text":"","code":"setup_target_folder(target_folder = NULL, target_date)"},{"path":"epiforecasts.io/EpiNow2/reference/setup_target_folder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup Target Folder for Saving — setup_target_folder","text":"target_folder Character string specifying save results (create present). target_date Date, defaults maximum found data specified.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_target_folder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup Target Folder for Saving — setup_target_folder","text":"list containing path dated folder latest folder","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"function simulates infections using existing fit observed cases modified time-varying reproduction number. can used explore forecast models past counterfactuals. Simulations can run parallel using future::plan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"","code":"simulate_infections(   estimates,   R = NULL,   model = NULL,   samples = NULL,   batch_size = 10,   verbose = interactive() )"},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"estimates estimates element epinow run done output = \"fit\", result estimate_infections return_fit set TRUE. R numeric vector reproduction numbers; overwrite reproduction numbers contained estimates, except elements set NA. Alternatively accepts data.frame containing least date value (integer) variables optionally sample. (fewer) days original fit can simulated. model compiled stan model returned rstan::stan_model. samples Numeric, number posterior samples simulate . default use samples estimates input. batch_size Numeric, defaults 10. Size batches simulate. May decrease run times due reduced IO costs still evaluated. set NULL al simulations done . verbose Logical defaults interactive(). progress bar (progressr) shown.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"list output returned estimate_infections() based results specified scenario rather fitting.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # get example case counts reported_cases <- example_confirmed[1:50]  # set up example generation time generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") # set delays between infection and case report incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1), mean_sd = 0.1,   sd = convert_to_logsd(2, 1), sd_sd = 0.1, max = 15 )  # fit model to data to recover Rt estimates est <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1), rw = 7),   stan = stan_opts(control = list(adapt_delta = 0.9)),   obs = obs_opts(scale = list(mean = 0.1, sd = 0.01)),   gp = NULL, horizon = 0 ) #> Error : Exception: variable does not exist; processing stage=data initialization; variable name=gt_max; base type=int  (in 'data/generation_time.stan' at line 5; included from 'model_estimate_infections' at line 16) #>  #> failed to create the sampler; sampling not done #> Error in dimnames(x)$parameters: $ operator is invalid for atomic vectors  # update Rt trajectory and simulate new infections using it R <- c(rep(NA_real_, 26), rep(0.5, 10), rep(0.8, 7)) sims <- simulate_infections(est, R) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'extract': object 'est' not found plot(sims) #> Error in plot(sims): object 'sims' not found  # with a data.frame input of samples R_dt <- data.frame(   date = seq(      min(summary(est, type = \"parameters\", param = \"R\")$date),      by = \"day\", length.out = length(R)    ),   value = R ) #> Error in summary(est, type = \"parameters\", param = \"R\"): object 'est' not found sims <- simulate_infections(est, R_dt) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'extract': object 'est' not found plot(sims) #> Error in plot(sims): object 'sims' not found  #' # with a data.frame input of samples R_samples <- summary(est, type = \"samples\", param = \"R\") #> Error in summary(est, type = \"samples\", param = \"R\"): object 'est' not found R_samples <- R_samples[, .(date, sample, value)][sample <= 1000][date <= \"2020-04-10\"] #> Error in eval(expr, envir, enclos): object 'R_samples' not found R_samples <- R_samples[date >= \"2020-04-01\", value := 1.1] #> Error in eval(expr, envir, enclos): object 'R_samples' not found sims <- simulate_infections(est, R_samples) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'extract': object 'est' not found plot(sims) #> Error in plot(sims): object 'sims' not found  options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/simulate_secondary.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a secondary observation — simulate_secondary","title":"Simulate a secondary observation — simulate_secondary","text":"Simulate secondary observation","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_secondary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a secondary observation — simulate_secondary","text":"","code":"simulate_secondary(   data,   type = \"incidence\",   family = \"poisson\",   delay_max = 30,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/simulate_secondary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a secondary observation — simulate_secondary","text":"data data frame containing date report primary cases numeric vector. type character string indicating type observation secondary reports . Options include: \"incidence\": Assumes secondary reports equal convolution previously observed primary reported cases. example application deaths infectious disease predicted reported cases disease (estimated infections). \"prevalence\": Assumes secondary reports cumulative defined currently observed primary reports minus convolution secondary reports. example application hospital bed usage predicted hospital admissions. family Character string defining observation model. Options Negative binomial (\"negbin\"), default, Poisson (\"poisson\"), \"none\" meaning expectation returned. delay_max Integer, defaulting 30 days. maximum delay used convolution model. ... Additional parameters pass observation model (.e rnbinom rpois).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_secondary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a secondary observation — simulate_secondary","text":"data frame containing simulated data format required estimate_secondary().","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/simulate_secondary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a secondary observation — simulate_secondary","text":"Sam Abbott Sebastian Funk","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_secondary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a secondary observation — simulate_secondary","text":"","code":"# load data.table for manipulation library(data.table)  #### Incidence data example ####  # make some example secondary incidence data cases <- example_confirmed cases <- as.data.table(cases)[, primary := confirm]  # Assume that only 40 percent of cases are reported cases[, scaling := 0.4] #>            date confirm primary scaling #>   1: 2020-02-22      14      14     0.4 #>   2: 2020-02-23      62      62     0.4 #>   3: 2020-02-24      53      53     0.4 #>   4: 2020-02-25      97      97     0.4 #>   5: 2020-02-26      93      93     0.4 #>  ---                                    #> 126: 2020-06-26     296     296     0.4 #> 127: 2020-06-27     255     255     0.4 #> 128: 2020-06-28     175     175     0.4 #> 129: 2020-06-29     174     174     0.4 #> 130: 2020-06-30     126     126     0.4  # Parameters of the assumed log normal delay distribution cases[, meanlog := 1.8][, sdlog := 0.5] #>            date confirm primary scaling meanlog sdlog #>   1: 2020-02-22      14      14     0.4     1.8   0.5 #>   2: 2020-02-23      62      62     0.4     1.8   0.5 #>   3: 2020-02-24      53      53     0.4     1.8   0.5 #>   4: 2020-02-25      97      97     0.4     1.8   0.5 #>   5: 2020-02-26      93      93     0.4     1.8   0.5 #>  ---                                                  #> 126: 2020-06-26     296     296     0.4     1.8   0.5 #> 127: 2020-06-27     255     255     0.4     1.8   0.5 #> 128: 2020-06-28     175     175     0.4     1.8   0.5 #> 129: 2020-06-29     174     174     0.4     1.8   0.5 #> 130: 2020-06-30     126     126     0.4     1.8   0.5  # Simulate secondary cases cases <- simulate_secondary(cases, type = \"incidence\") cases #>            date confirm primary scaling meanlog sdlog index scaled       conv #>   1: 2020-02-22      14      14     0.4     1.8   0.5     1    5.6   5.600000 #>   2: 2020-02-23      62      62     0.4     1.8   0.5     2   24.8   5.827560 #>   3: 2020-02-24      53      53     0.4     1.8   0.5     3   21.2   8.801043 #>   4: 2020-02-25      97      97     0.4     1.8   0.5     4   38.8  12.938343 #>   5: 2020-02-26      93      93     0.4     1.8   0.5     5   37.2  16.590082 #>  ---                                                                          #> 126: 2020-06-26     296     296     0.4     1.8   0.5   126  118.4  91.429685 #> 127: 2020-06-27     255     255     0.4     1.8   0.5   127  102.0  95.779467 #> 128: 2020-06-28     175     175     0.4     1.8   0.5   128   70.0 103.797728 #> 129: 2020-06-29     174     174     0.4     1.8   0.5   129   69.6 109.079519 #> 130: 2020-06-30     126     126     0.4     1.8   0.5   130   50.4 109.018943 #>      secondary #>   1:         6 #>   2:         7 #>   3:        14 #>   4:        16 #>   5:        15 #>  ---           #> 126:        90 #> 127:        93 #> 128:       107 #> 129:       114 #> 130:       104 #### Prevalence data example ####  # make some example prevalence data cases <- example_confirmed cases <- as.data.table(cases)[, primary := confirm]  # Assume that only 30 percent of cases are reported cases[, scaling := 0.3] #>            date confirm primary scaling #>   1: 2020-02-22      14      14     0.3 #>   2: 2020-02-23      62      62     0.3 #>   3: 2020-02-24      53      53     0.3 #>   4: 2020-02-25      97      97     0.3 #>   5: 2020-02-26      93      93     0.3 #>  ---                                    #> 126: 2020-06-26     296     296     0.3 #> 127: 2020-06-27     255     255     0.3 #> 128: 2020-06-28     175     175     0.3 #> 129: 2020-06-29     174     174     0.3 #> 130: 2020-06-30     126     126     0.3  # Parameters of the assumed log normal delay distribution cases[, meanlog := 1.6][, sdlog := 0.8] #>            date confirm primary scaling meanlog sdlog #>   1: 2020-02-22      14      14     0.3     1.6   0.8 #>   2: 2020-02-23      62      62     0.3     1.6   0.8 #>   3: 2020-02-24      53      53     0.3     1.6   0.8 #>   4: 2020-02-25      97      97     0.3     1.6   0.8 #>   5: 2020-02-26      93      93     0.3     1.6   0.8 #>  ---                                                  #> 126: 2020-06-26     296     296     0.3     1.6   0.8 #> 127: 2020-06-27     255     255     0.3     1.6   0.8 #> 128: 2020-06-28     175     175     0.3     1.6   0.8 #> 129: 2020-06-29     174     174     0.3     1.6   0.8 #> 130: 2020-06-30     126     126     0.3     1.6   0.8  # Simulate secondary cases cases <- simulate_secondary(cases, type = \"prevalence\") cases #>            date confirm primary scaling meanlog sdlog index scaled      conv #>   1: 2020-02-22      14      14     0.3     1.6   0.8     1    4.2  4.200000 #>   2: 2020-02-23      62      62     0.3     1.6   0.8     2   18.6  6.749663 #>   3: 2020-02-24      53      53     0.3     1.6   0.8     3   15.9 10.939618 #>   4: 2020-02-25      97      97     0.3     1.6   0.8     4   29.1 13.765588 #>   5: 2020-02-26      93      93     0.3     1.6   0.8     5   27.9 17.347381 #>  ---                                                                         #> 126: 2020-06-26     296     296     0.3     1.6   0.8   126   88.8 77.928567 #> 127: 2020-06-27     255     255     0.3     1.6   0.8   127   76.5 82.956283 #> 128: 2020-06-28     175     175     0.3     1.6   0.8   128   52.5 83.358105 #> 129: 2020-06-29     174     174     0.3     1.6   0.8   129   52.2 80.055418 #> 130: 2020-06-30     126     126     0.3     1.6   0.8   130   37.8 75.242850 #>      secondary #>   1:         5 #>   2:        17 #>   3:        22 #>   4:        43 #>   5:        46 #>  ---           #> 126:       275 #> 127:       269 #> 128:       263 #> 129:       202 #> 130:       155"},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Stan Options — stan_opts","title":"Stan Options — stan_opts","text":"Defines list specifying arguments passed underlying stan backend functions via rstan_sampling_opts() rstan_vb_opts(). Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stan Options — stan_opts","text":"","code":"stan_opts(   samples = 2000,   backend = \"rstan\",   init_fit = NULL,   return_fit = TRUE,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stan Options — stan_opts","text":"samples Numeric, default 2000. Overall number posterior samples. using multiple chains iterations per chain samples / chains. backend Character string indicating backend use fitting stan models. Currently \"rstan\" supported. init_fit Character string stanfit object, defaults NULL. initial fit used initialise full fit. example scenario using national level fit parametrise regional level fits. Optionally character string can passed currently supported option \"cumulative\". fits model cumulative cases may useful certain data sets sampler gets stuck struggles initialise. See init_cumulative_fit() details. implementation based approach taken epidemia authored James Scott. return_fit Logical, defaults TRUE. fit stan model returned. ... Additional parameters pass  underlying option functions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stan Options — stan_opts","text":"list arguments pass appropriate rstan functions.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stan Options — stan_opts","text":"","code":"# using default of rstan::sampling stan_opts(samples = 1000) #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // convolve two vectors #> // length of x #> // produces a convolution across the lenght specified #> vector convolve(vector x, vector y, int len) { #>   int xlen = num_elements(x); #>   int ylen = num_elements(y); #>   vector[len] convolution = rep_vector(0, len); #>   for (i in 1:xlen) { #>     for (j in 1:(min(len - i + 1, ylen))) { #>       convolution[i + j - 1] += x[i] * y[j]; #>     } #>   } #>   return(convolution); #> } #>  #> // convolve two vectors as a backwards dot product #> // y vector shoud be reversed #> // limited to the length of x and backwards looking for x indexes #> // designed for use convolve a case vector and a delay pmf #> vector convolve_dot_product(vector x, vector y, int len) { #>     int ylen = num_elements(y); #>     vector[len] z; #>     for (s in 1:len) { #>         z[s] = dot_product( #>             x[max(1, (s - ylen + 1)):s], tail(y, min(ylen, s)) #>           ); #>     } #>    return(z); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           vector delay_rev_pmf, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_rev_pmf); #>   if (delays) { #>     unobs_reports = convolve_dot_product(unobs_reports, delay_rev_pmf, t); #>     reports = unobs_reports[(seeding_time + 1):t]; #>   } else { #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> // Calculate the daily probability of reporting using parametric #> // distributions up to the maximum observed delay. #> // If sigma is 0 all the probability mass is put on n. #> // Adapted from https://github.com/epiforecasts/epinowcast #> // @author Sam Abbott #> // @author Adrian Lison #> vector discretised_pmf(real mu, real sigma, int n, int dist, #>                        int left_truncate) { #>   vector[n] pmf; #>   if (sigma > 0) { #>     vector[n + 1] upper_cdf; #>     if (dist == 0) { #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = lognormal_cdf(i - 1 + left_truncate, mu, sigma); #>       } #>     } else if (dist == 1) { #>       real alpha = mu^2 / sigma^2; #>       real beta = mu / sigma^2; #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = gamma_cdf(i - 1 + left_truncate, alpha, beta); #>       } #>     } else { #>       reject(\"Unknown distribution function provided.\"); #>     } #>     // discretise #>     pmf = upper_cdf[2:(n + 1)] - upper_cdf[1:n]; #>     // normalize #>     pmf = pmf / (upper_cdf[n + 1] - upper_cdf[1]); #>   } else { #>     // delta function #>     pmf = rep_vector(0, n); #>     pmf[n] = 1; #>   } #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // combined fixed/variable pmfs #> vector combine_pmfs(vector fixed_pmf, real[] pmf_mu, real[] pmf_sigma, int[] pmf_n, int[] dist, int len, int left_truncate, int reverse_pmf) { #>   int n_fixed = num_elements(fixed_pmf); #>   int n_variable = num_elements(pmf_mu); #>   vector[len] pmf = rep_vector(0, len); #>   if (n_fixed > 0) { #>     pmf[1:n_fixed] = fixed_pmf; #>   } else if (n_variable > 0) { #>     pmf[1] = 1; #>   } #>   for (s in 1:n_variable) { #>     vector[pmf_n[s]] variable_pmf; #>     variable_pmf = discretised_pmf(pmf_mu[s], pmf_sigma[s], pmf_n[s], dist[s], left_truncate); #>     pmf = convolve(pmf, variable_pmf, len); #>   } #>   if (reverse_pmf) { #>     pmf = reverse_mf(pmf); #>   } #>   return(pmf); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, #>                int[] delay_dist, int weight) { #>     int mean_delays = num_elements(delay_mean); #>     int sd_delays = num_elements(delay_sd); #>     if (mean_delays) { #>       for (s in 1:mean_delays) { #>         if (delay_mean_sd[s] > 0) { #>           // uncertain mean #>           target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           // if a distribution with postive support only truncate the prior #>           if (delay_dist[s]) { #>             target += -normal_lccdf(0 | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           } #>         } #>       } #>     } #>     if (sd_delays) { #>       for (s in 1:sd_delays) { #>         if (delay_sd_sd[s] > 0) { #>           // uncertain sd #>           target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>           target += -normal_lccdf(0 | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>         } #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_rev_pmf, #>                            int seeding_time, int index){ #>   int gt_max = num_elements(gt_rev_pmf); #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - gt_max)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(gt_max, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product( #>     infections[inf_start:inf_end], tail(gt_rev_pmf, pmf_accessed) #>   ); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, vector gt_rev_pmf, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_rev_pmf, uot, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, vector trunc_rev_cmf, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = num_elements(trunc_rev_cmf); #>   int first_t = t - trunc_max + 1; #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ trunc_rev_cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* trunc_rev_cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     if (trunc_mean_sd[1] > 0) { #>       // uncertain mean #>       truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     } #>     if (trunc_sd_sd[1] > 0) { #>       // uncertain sd #>       truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>     } #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     vector gt_rev_pmf, int smooth) { #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_rev_pmf, seeding_time, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   int n_uncertain_mean_delays;   // no. of delay distributions with uncertain mean #>   int n_uncertain_sd_delays;     // no. of delay distributions with uncertain sd #>   int n_fixed_delays;     // no. of delay distributions with uncertain sd #>   // indices of delay distributions with uncertainty #>   int<lower = 1, upper = delays> uncertain_mean_delays[n_uncertain_mean_delays]; #>   int<lower = 1, upper = delays> uncertain_sd_delays[n_uncertain_sd_delays]; #>   int<lower = 1, upper = delays> fixed_delays[n_fixed_delays]; #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int<lower = 1> delay_max[delays];       // maximum incubation period #>   int delay_dist[delays];       // 0 = lognormal; 1 = gamma #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd[1];                   // prior sd of mean generation time #>   real gt_mean_mean[1];                 // prior mean of mean generation time #>   real gt_sd_mean[1];                   // prior mean of sd of generation time #>   real gt_sd_sd[1];                     // prior sd of sd of generation time #>   int<lower = 1> gt_max[1];                        // maximum generation time #>   int gt_fixed[1];                      // 0 = variable gt; 1 = fixed gt #>   int gt_dist[1];                    // distribution (0 = lognormal, 1 = gamma) #>   int gt_weight;                    #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int<lower = 1> trunc_max[truncation];    // maximum truncation supported #>   int trunc_fixed[truncation];    // whether the truncation distribution is fixed #>   int trunc_dist[truncation];    // 0 = lognormal; 1 = gamma #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #>  #>   int delay_max_fixed = (n_fixed_delays == 0 ? 0 : #>     sum(delay_max[fixed_delays]) - num_elements(fixed_delays) + 1); #>   int delay_max_total = (delays == 0 ? 0 : #>     sum(delay_max) - num_elements(delay_max) + 1); #>   vector[gt_fixed[1] ? gt_max[1] : 0] gt_fixed_pmf; #>   vector[truncation && trunc_fixed[1] ? trunc_max[1] : 0] trunc_fixed_pmf; #>   vector[delay_max_fixed] delays_fixed_pmf; #>  #>   if (gt_fixed[1]) { #>     gt_fixed_pmf = discretised_pmf(gt_mean_mean[1], gt_sd_mean[1], gt_max[1], gt_dist[1], 1); #>   } #>   if (truncation && trunc_fixed[1]) { #>     trunc_fixed_pmf = discretised_pmf( #>       trunc_mean_mean[1], trunc_sd_mean[1], trunc_max[1], trunc_dist[1], 0 #>     ); #>   } #>   if (n_fixed_delays) { #>     delays_fixed_pmf = combine_pmfs( #>       to_vector([ 1 ]), delay_mean_mean[fixed_delays], #>       delay_sd_mean[fixed_delays], delay_max[fixed_delays],  #>       delay_dist[fixed_delays], delay_max_fixed, 0, 0 #>     ); #>   } #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<upper = gt_max[1]> gt_mean[estimate_r && gt_mean_sd[1] > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd[1] > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[n_uncertain_mean_delays];         // mean of delays #>   real<lower = 0> delay_sd[n_uncertain_sd_delays];  // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0, upper = 1> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real trunc_mean[truncation && !trunc_fixed[1]];        // mean of truncation #>   real<lower = 0> trunc_sd[truncation && !trunc_fixed[1]]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     vector[gt_max[1]] gt_rev_pmf; #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean, gt_sd, gt_max, gt_dist, gt_max[1], 1, 1 #>     ); #>     R = update_Rt( #>       ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary #>     ); #>     infections = generate_infections( #>       R, seeding_time, gt_rev_pmf, initial_infections, initial_growth, pop, #>       future_time #>     ); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections( #>       shifted_cases, noise, fixed, backcalc_prior #>     ); #>   } #>   // convolve from latent infections to mean of observations #>   { #>     vector[delay_max_total] delay_rev_pmf; #>     delay_rev_pmf = combine_pmfs( #>       delays_fixed_pmf, delay_mean, delay_sd, delay_max, delay_dist, delay_max_total, 0, 1 #>     ); #>     reports = convolve_to_report(infections, delay_rev_pmf, seeding_time); #>   } #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    vector[trunc_max[1]] trunc_rev_cmf; #>    trunc_rev_cmf = reverse_mf(cumulative_sum(combine_pmfs( #>      trunc_fixed_pmf, trunc_mean, trunc_sd, trunc_max, trunc_dist, trunc_max[1], 0, 0 #>    ))); #>    obs_reports = truncate(reports[1:ot], trunc_rev_cmf, 0); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean[uncertain_mean_delays], #>     delay_mean_sd[uncertain_mean_delays], #>     delay_sd, delay_sd_mean[uncertain_sd_delays], #>     delay_sd_sd[uncertain_sd_delays], delay_dist[uncertain_mean_delays], t #>   ); #>   // priors for truncation #>   delays_lp( #>     trunc_mean, trunc_sd, #>     trunc_mean_mean, trunc_mean_sd, #>     trunc_sd_mean, trunc_sd_sd, #>     trunc_dist, 1 #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     delays_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, gt_dist, gt_weight #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0, 1]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd[1] > 0 ? gt_mean[1] : gt_mean_mean[1]); #>     real set_gt_sd = (gt_sd_sd [1]> 0 ? gt_sd[1] : gt_sd_mean[1]); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   } else { #>     // sample generation time #>     real gt_mean_sample[1]; #>     real gt_sd_sample[1]; #>     vector[gt_max[1]] gt_rev_pmf; #>  #>     gt_mean_sample[1] = (gt_mean_sd[1] > 0 ? normal_rng(gt_mean_mean[1], gt_mean_sd[1]) : gt_mean_mean[1]); #>     gt_sd_sample[1] = (gt_sd_sd[1] > 0 ? normal_rng(gt_sd_mean[1], gt_sd_sd[1]) : gt_sd_mean[1]); #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean_sample, gt_sd_sample, gt_max, gt_dist, gt_max[1], #>       1, 1 #>     ); #>  #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_rev_pmf, rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample[1], gt_sd_sample[1]); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"sampling\" #>  #> $cores #> [1] 1 #>  #> $warmup #> [1] 250 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 8661993 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 500 #>  #> $return_fit #> [1] TRUE #>   # using vb stan_opts(method = \"vb\") #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // convolve two vectors #> // length of x #> // produces a convolution across the lenght specified #> vector convolve(vector x, vector y, int len) { #>   int xlen = num_elements(x); #>   int ylen = num_elements(y); #>   vector[len] convolution = rep_vector(0, len); #>   for (i in 1:xlen) { #>     for (j in 1:(min(len - i + 1, ylen))) { #>       convolution[i + j - 1] += x[i] * y[j]; #>     } #>   } #>   return(convolution); #> } #>  #> // convolve two vectors as a backwards dot product #> // y vector shoud be reversed #> // limited to the length of x and backwards looking for x indexes #> // designed for use convolve a case vector and a delay pmf #> vector convolve_dot_product(vector x, vector y, int len) { #>     int ylen = num_elements(y); #>     vector[len] z; #>     for (s in 1:len) { #>         z[s] = dot_product( #>             x[max(1, (s - ylen + 1)):s], tail(y, min(ylen, s)) #>           ); #>     } #>    return(z); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           vector delay_rev_pmf, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_rev_pmf); #>   if (delays) { #>     unobs_reports = convolve_dot_product(unobs_reports, delay_rev_pmf, t); #>     reports = unobs_reports[(seeding_time + 1):t]; #>   } else { #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> // Calculate the daily probability of reporting using parametric #> // distributions up to the maximum observed delay. #> // If sigma is 0 all the probability mass is put on n. #> // Adapted from https://github.com/epiforecasts/epinowcast #> // @author Sam Abbott #> // @author Adrian Lison #> vector discretised_pmf(real mu, real sigma, int n, int dist, #>                        int left_truncate) { #>   vector[n] pmf; #>   if (sigma > 0) { #>     vector[n + 1] upper_cdf; #>     if (dist == 0) { #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = lognormal_cdf(i - 1 + left_truncate, mu, sigma); #>       } #>     } else if (dist == 1) { #>       real alpha = mu^2 / sigma^2; #>       real beta = mu / sigma^2; #>       for (i in 1:(n + 1)) { #>         upper_cdf[i] = gamma_cdf(i - 1 + left_truncate, alpha, beta); #>       } #>     } else { #>       reject(\"Unknown distribution function provided.\"); #>     } #>     // discretise #>     pmf = upper_cdf[2:(n + 1)] - upper_cdf[1:n]; #>     // normalize #>     pmf = pmf / (upper_cdf[n + 1] - upper_cdf[1]); #>   } else { #>     // delta function #>     pmf = rep_vector(0, n); #>     pmf[n] = 1; #>   } #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // combined fixed/variable pmfs #> vector combine_pmfs(vector fixed_pmf, real[] pmf_mu, real[] pmf_sigma, int[] pmf_n, int[] dist, int len, int left_truncate, int reverse_pmf) { #>   int n_fixed = num_elements(fixed_pmf); #>   int n_variable = num_elements(pmf_mu); #>   vector[len] pmf = rep_vector(0, len); #>   if (n_fixed > 0) { #>     pmf[1:n_fixed] = fixed_pmf; #>   } else if (n_variable > 0) { #>     pmf[1] = 1; #>   } #>   for (s in 1:n_variable) { #>     vector[pmf_n[s]] variable_pmf; #>     variable_pmf = discretised_pmf(pmf_mu[s], pmf_sigma[s], pmf_n[s], dist[s], left_truncate); #>     pmf = convolve(pmf, variable_pmf, len); #>   } #>   if (reverse_pmf) { #>     pmf = reverse_mf(pmf); #>   } #>   return(pmf); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, #>                int[] delay_dist, int weight) { #>     int mean_delays = num_elements(delay_mean); #>     int sd_delays = num_elements(delay_sd); #>     if (mean_delays) { #>       for (s in 1:mean_delays) { #>         if (delay_mean_sd[s] > 0) { #>           // uncertain mean #>           target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           // if a distribution with postive support only truncate the prior #>           if (delay_dist[s]) { #>             target += -normal_lccdf(0 | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>           } #>         } #>       } #>     } #>     if (sd_delays) { #>       for (s in 1:sd_delays) { #>         if (delay_sd_sd[s] > 0) { #>           // uncertain sd #>           target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>           target += -normal_lccdf(0 | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>         } #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_rev_pmf, #>                            int seeding_time, int index){ #>   int gt_max = num_elements(gt_rev_pmf); #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - gt_max)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(gt_max, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product( #>     infections[inf_start:inf_end], tail(gt_rev_pmf, pmf_accessed) #>   ); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, vector gt_rev_pmf, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_rev_pmf, uot, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, vector trunc_rev_cmf, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = num_elements(trunc_rev_cmf); #>   int first_t = t - trunc_max + 1; #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ trunc_rev_cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* trunc_rev_cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     if (trunc_mean_sd[1] > 0) { #>       // uncertain mean #>       truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     } #>     if (trunc_sd_sd[1] > 0) { #>       // uncertain sd #>       truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>     } #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     vector gt_rev_pmf, int smooth) { #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_rev_pmf, seeding_time, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   int n_uncertain_mean_delays;   // no. of delay distributions with uncertain mean #>   int n_uncertain_sd_delays;     // no. of delay distributions with uncertain sd #>   int n_fixed_delays;     // no. of delay distributions with uncertain sd #>   // indices of delay distributions with uncertainty #>   int<lower = 1, upper = delays> uncertain_mean_delays[n_uncertain_mean_delays]; #>   int<lower = 1, upper = delays> uncertain_sd_delays[n_uncertain_sd_delays]; #>   int<lower = 1, upper = delays> fixed_delays[n_fixed_delays]; #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int<lower = 1> delay_max[delays];       // maximum incubation period #>   int delay_dist[delays];       // 0 = lognormal; 1 = gamma #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd[1];                   // prior sd of mean generation time #>   real gt_mean_mean[1];                 // prior mean of mean generation time #>   real gt_sd_mean[1];                   // prior mean of sd of generation time #>   real gt_sd_sd[1];                     // prior sd of sd of generation time #>   int<lower = 1> gt_max[1];                        // maximum generation time #>   int gt_fixed[1];                      // 0 = variable gt; 1 = fixed gt #>   int gt_dist[1];                    // distribution (0 = lognormal, 1 = gamma) #>   int gt_weight;                    #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int<lower = 1> trunc_max[truncation];    // maximum truncation supported #>   int trunc_fixed[truncation];    // whether the truncation distribution is fixed #>   int trunc_dist[truncation];    // 0 = lognormal; 1 = gamma #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #>  #>   int delay_max_fixed = (n_fixed_delays == 0 ? 0 : #>     sum(delay_max[fixed_delays]) - num_elements(fixed_delays) + 1); #>   int delay_max_total = (delays == 0 ? 0 : #>     sum(delay_max) - num_elements(delay_max) + 1); #>   vector[gt_fixed[1] ? gt_max[1] : 0] gt_fixed_pmf; #>   vector[truncation && trunc_fixed[1] ? trunc_max[1] : 0] trunc_fixed_pmf; #>   vector[delay_max_fixed] delays_fixed_pmf; #>  #>   if (gt_fixed[1]) { #>     gt_fixed_pmf = discretised_pmf(gt_mean_mean[1], gt_sd_mean[1], gt_max[1], gt_dist[1], 1); #>   } #>   if (truncation && trunc_fixed[1]) { #>     trunc_fixed_pmf = discretised_pmf( #>       trunc_mean_mean[1], trunc_sd_mean[1], trunc_max[1], trunc_dist[1], 0 #>     ); #>   } #>   if (n_fixed_delays) { #>     delays_fixed_pmf = combine_pmfs( #>       to_vector([ 1 ]), delay_mean_mean[fixed_delays], #>       delay_sd_mean[fixed_delays], delay_max[fixed_delays],  #>       delay_dist[fixed_delays], delay_max_fixed, 0, 0 #>     ); #>   } #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<upper = gt_max[1]> gt_mean[estimate_r && gt_mean_sd[1] > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd[1] > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[n_uncertain_mean_delays];         // mean of delays #>   real<lower = 0> delay_sd[n_uncertain_sd_delays];  // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0, upper = 1> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real trunc_mean[truncation && !trunc_fixed[1]];        // mean of truncation #>   real<lower = 0> trunc_sd[truncation && !trunc_fixed[1]]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     vector[gt_max[1]] gt_rev_pmf; #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean, gt_sd, gt_max, gt_dist, gt_max[1], 1, 1 #>     ); #>     R = update_Rt( #>       ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary #>     ); #>     infections = generate_infections( #>       R, seeding_time, gt_rev_pmf, initial_infections, initial_growth, pop, #>       future_time #>     ); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections( #>       shifted_cases, noise, fixed, backcalc_prior #>     ); #>   } #>   // convolve from latent infections to mean of observations #>   { #>     vector[delay_max_total] delay_rev_pmf; #>     delay_rev_pmf = combine_pmfs( #>       delays_fixed_pmf, delay_mean, delay_sd, delay_max, delay_dist, delay_max_total, 0, 1 #>     ); #>     reports = convolve_to_report(infections, delay_rev_pmf, seeding_time); #>   } #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    vector[trunc_max[1]] trunc_rev_cmf; #>    trunc_rev_cmf = reverse_mf(cumulative_sum(combine_pmfs( #>      trunc_fixed_pmf, trunc_mean, trunc_sd, trunc_max, trunc_dist, trunc_max[1], 0, 0 #>    ))); #>    obs_reports = truncate(reports[1:ot], trunc_rev_cmf, 0); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean[uncertain_mean_delays], #>     delay_mean_sd[uncertain_mean_delays], #>     delay_sd, delay_sd_mean[uncertain_sd_delays], #>     delay_sd_sd[uncertain_sd_delays], delay_dist[uncertain_mean_delays], t #>   ); #>   // priors for truncation #>   delays_lp( #>     trunc_mean, trunc_sd, #>     trunc_mean_mean, trunc_mean_sd, #>     trunc_sd_mean, trunc_sd_sd, #>     trunc_dist, 1 #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     delays_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, gt_dist, gt_weight #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0, 1]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd[1] > 0 ? gt_mean[1] : gt_mean_mean[1]); #>     real set_gt_sd = (gt_sd_sd [1]> 0 ? gt_sd[1] : gt_sd_mean[1]); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   } else { #>     // sample generation time #>     real gt_mean_sample[1]; #>     real gt_sd_sample[1]; #>     vector[gt_max[1]] gt_rev_pmf; #>  #>     gt_mean_sample[1] = (gt_mean_sd[1] > 0 ? normal_rng(gt_mean_mean[1], gt_mean_sd[1]) : gt_mean_mean[1]); #>     gt_sd_sample[1] = (gt_sd_sd[1] > 0 ? normal_rng(gt_sd_mean[1], gt_sd_sd[1]) : gt_sd_mean[1]); #>     gt_rev_pmf = combine_pmfs( #>       gt_fixed_pmf, gt_mean_sample, gt_sd_sample, gt_max, gt_dist, gt_max[1], #>       1, 1 #>     ); #>  #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_rev_pmf, rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample[1], gt_sd_sample[1]); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"vb\" #>  #> $trials #> [1] 10 #>  #> $iter #> [1] 10000 #>  #> $output_samples #> [1] 2000 #>  #> $return_fit #> [1] TRUE #>"},{"path":"epiforecasts.io/EpiNow2/reference/summarise_key_measures.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise rt and cases — summarise_key_measures","title":"Summarise rt and cases — summarise_key_measures","text":"Produces summarised data frames output across regions. Used internally regional_summary.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summarise_key_measures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise rt and cases — summarise_key_measures","text":"","code":"summarise_key_measures(   regional_results = NULL,   results_dir = NULL,   summary_dir = NULL,   type = \"region\",   date = \"latest\" )"},{"path":"epiforecasts.io/EpiNow2/reference/summarise_key_measures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise rt and cases — summarise_key_measures","text":"regional_results list dataframes produced get_regional_results results_dir Character string indicating directory extract results. summary_dir Character string directory save results csv. type Character string, region identifier apply (defaults region). date Character string (format \"yyyy-mm-dd\") indicating date extract data . Defaults \"latest\" finds latest results available.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summarise_key_measures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise rt and cases — summarise_key_measures","text":"list summarised Rt, cases date infection cases date report","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/summarise_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise Real-time Results — summarise_results","title":"Summarise Real-time Results — summarise_results","text":"Used internally regional_summary produce summary table results. May streamlined later releases.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summarise_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise Real-time Results — summarise_results","text":"","code":"summarise_results(   regions,   summaries = NULL,   results_dir = NULL,   target_date = NULL,   region_scale = \"Region\" )"},{"path":"epiforecasts.io/EpiNow2/reference/summarise_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise Real-time Results — summarise_results","text":"regions character string containing list regions extract results (must results target date). summaries list summary data frames output epinow results_dir optional character string indicating location results directory extract results . target_date character string indicating target date extract results . regions must results date. region_scale character string indicating name give regions summarised.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summarise_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise Real-time Results — summarise_results","text":"list summary data","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.epinow.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary output from epinow — summary.epinow","title":"Summary output from epinow — summary.epinow","text":"summary method class \"epinow\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.epinow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary output from epinow — summary.epinow","text":"","code":"# S3 method for epinow summary(object, output = \"estimates\", date = NULL, params = NULL, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/summary.epinow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary output from epinow — summary.epinow","text":"object list output produced \"epinow\". output character string output summarise. Defaults \"estimates\" also supports \"forecast\", \"estimated_reported_cases\". date date form \"yyyy-mm-dd\" inspect estimates . params character vector parameters filter . ... Pass additional summary arguments lower level methods","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.epinow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary output from epinow — summary.epinow","text":"Returns data frame summary output","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/summary.estimate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary output from estimate_infections — summary.estimate_infections","title":"Summary output from estimate_infections — summary.estimate_infections","text":"summary method class \"estimate_infections\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.estimate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary output from estimate_infections — summary.estimate_infections","text":"","code":"# S3 method for estimate_infections summary(object, type = \"snapshot\", date = NULL, params = NULL, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/summary.estimate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary output from estimate_infections — summary.estimate_infections","text":"object list output produced \"estimate_infections\". type character vector data types return. Defaults \"snapshot\" also supports \"parameters\", \"samples\". \"snapshot\" returns summary given date (default latest date informed data). \"parameters\" returns summarised parameter estimates can filtered using params show just parameters interest date. \"samples\" similarly returns posterior samples. date date form \"yyyy-mm-dd\" inspect estimates . params character vector parameters filter . ... Pass additional arguments report_summary","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.estimate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary output from estimate_infections — summary.estimate_infections","text":"Returns data frame summary output","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Truncation Distribution Options — trunc_opts","title":"Truncation Distribution Options — trunc_opts","text":"Returns truncation distribution formatted usage downstream functions. See estimate_truncation() approach estimate distribution.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Truncation Distribution Options — trunc_opts","text":"","code":"trunc_opts(dist = list())"},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Truncation Distribution Options — trunc_opts","text":"dist Parameters discretised (upper-)truncated lognormal truncation distribution list parameters passed dist_spec.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Truncation Distribution Options — trunc_opts","text":"list summarising input truncation distribution.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Truncation Distribution Options — trunc_opts","text":"","code":"# no truncation trunc_opts() #> $trunc_mean_mean #> numeric(0) #>  #> $trunc_mean_sd #> numeric(0) #>  #> $trunc_sd_mean #> numeric(0) #>  #> $trunc_sd_sd #> numeric(0) #>  #> $trunc_fixed #> integer(0) #>  #> $trunc_dist #> integer(0) #>  #> $trunc_max #> integer(0) #>  #> $truncation #> [1] 0 #>   # truncation dist trunc_opts(dist = list(mean = 3, sd = 2)) #> $trunc_mean_mean #> [1] 3 #>  #> $trunc_mean_sd #> [1] 0 #>  #> $trunc_sd_mean #> [1] 2 #>  #> $trunc_sd_sd #> [1] 0 #>  #> $trunc_fixed #> [1] 1 #>  #> $trunc_dist #> [1] 0 #>  #> $truncation #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"Allows inverse gamma distribution . tuned less 0.01 probability mass function falls outside specified bounds. required using inverse gamma prior, example Gaussian process. inverse gamma priors currently use function stability issues may deprecated later date.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"","code":"tune_inv_gamma(lower = 2, upper = 21)"},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"lower Numeric, defaults 2. Lower truncation bound. upper Numeric, defaults 21. Upper truncation bound.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"list alpha beta values describe inverse gamma distribution achieves target truncation.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"","code":"tune_inv_gamma(lower = 2, upper = 21) #> $alpha #> [1] 4.5 #>  #> $beta #> [1] 21.5 #>"},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":null,"dir":"Reference","previous_headings":"","what":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"Makes sure forecast returned user specified time period beyond target date.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"","code":"update_horizon(horizon, target_date, reported_cases)"},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"horizon Numeric, defaults 7. Number days future forecast. target_date Date, defaults maximum found data specified. reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"Numeric forecast horizon adjusted users intention","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Update a List — update_list","title":"Update a List — update_list","text":"Used handle updating settings list. example making changes opts_list output.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update a List — update_list","text":"","code":"update_list(defaults = list(), optional = list())"},{"path":"epiforecasts.io/EpiNow2/reference/update_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update a List — update_list","text":"defaults list default settings optional list optional settings override defaults","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update a List — update_list","text":"list","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_secondary_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Update estimate_secondary default priors — update_secondary_args","title":"Update estimate_secondary default priors — update_secondary_args","text":"functions allows user easily specify data driven model based priors estimate_secondary() example previous model fits using data.frame overwrite default settings. Note default settings still required.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_secondary_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update estimate_secondary default priors — update_secondary_args","text":"","code":"update_secondary_args(data, priors, verbose = TRUE)"},{"path":"epiforecasts.io/EpiNow2/reference/update_secondary_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update estimate_secondary default priors — update_secondary_args","text":"data list data arguments returned create_stan_data(). priors data.frame named priors used model fitting rather defaults supplied arguments. typically useful wanting inform estimate posterior another model fit. Priors currently use update defaults scaling fraction (\"frac_obs\"), mean delay (\"delay_mean\"), standard deviation delay (\"delay_sd\"). data.frame following variables: variable, mean, sd. verbose Logical, defaults FALSE. verbose progress messages returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_secondary_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update estimate_secondary default priors — update_secondary_args","text":"list produced create_stan_data().","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_secondary_args.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Update estimate_secondary default priors — update_secondary_args","text":"Sam Abbott","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_secondary_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update estimate_secondary default priors — update_secondary_args","text":"","code":"priors <- data.frame(variable = \"frac_obs\", mean = 3, sd = 1) data <- list(obs_scale_mean = 4, obs_scale_sd = 3) update_secondary_args(data, priors) #> Replacing specified priors with those from the passed in prior dataframe #> $obs_scale_mean #> [1] 3 #>  #> $obs_scale_sd #> [1] 1 #>"},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-134","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.3.4","title":"EpiNow2 1.3.4","text":"release focusses bug fixes package infrastructure updates along quality life improvements enabling use fixed delays generation times. Thanks @seabbs, @sbfnk SACEMA hosting @seabbs whilst development work release done.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"breaking-changes-1-3-4","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"EpiNow2 1.3.4","text":"enable enhance functionality trunc_opts() now takes single argument (dist) defines truncation delay rather arbitary list arguments (previously used define distribution. Updated handling generation times renewal equation left truncation adjusted zeroth day. accurately typical approach taken estimate generation times may slightly impact estimates vs produced using previous versions. ## Features Adds new function simulate_secondary() simulating secondary observations generative process model assumed estimate_secondary. Adds support fixed delays (mean fixed lognormal distributed) truncations (fixed lognormal distributed), pre-computing delays well generation times fixed. @sbfnk @seabbs. range frac_obs parameter restricted upper bound 1 reflect name description. @sbfnk #340. Support gamma distributed delays log-normal distributed generation times.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"package-1-3-4","dir":"Changelog","previous_headings":"","what":"Package","title":"EpiNow2 1.3.4","text":"Update GitHub Action files new versions. Switched using seq_along() rather 1:length() package code. Fixed broken example documentation regional_runtimes(). Add compatibility changes latest version rstan rstantools. Remove legacy use pkgnet package dependency visualisation. Restyled code using styler. Dropped dependency RcppParallel. Updated report_cases work new delay_opts helper function. Added test coverage report_cases though note function likely deprecated future releases. Switched linewidth plot_CrIs rather size avoid issues ggplot2 3.4.0. Set validation synthetic data run CI check. Added tests internal stan convolution functions. Update get_ distribution functions return distribution well summary parameters.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"documentation-1-3-4","dir":"Changelog","previous_headings":"","what":"Documentation","title":"EpiNow2 1.3.4","text":"Slight edits model outline estimate_infections(). Updated examples make use fixed distributions improve run-times appropriate.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"bugs-1-3-4","dir":"Changelog","previous_headings":"","what":"Bugs","title":"EpiNow2 1.3.4","text":"Fixed bug simulate_infections() passing custom number samples cause input vector R values replicated column-wise fashion meaning intended R trajectory simulated. Fixed bug estimate_infections() deconvolution model generation time correctly reversed.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-133","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.3.3","title":"EpiNow2 1.3.3","text":"release adds range new minor features, squashes bugs, enhances documentation, expands unit testing, implements minor run-time optimisations, removes obsolete features. Thanks @Bisaloo, @hsbadr, @LloydChapman, @medewitt, @sbfnk contributing release. Thanks @sbfnk, @pearsonca, @nicholasdavies regression testing release 1.3.2.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"new-features-1-3-3","dir":"Changelog","previous_headings":"","what":"New features","title":"EpiNow2 1.3.3","text":"Added supported simulate_infections data.frame R samples can passed instead vector R values. @seabbs. Added extraction posterior samples summary method estimate_infections. @seabbs. Exposed zero_threshold users allowing control zeros NAs count data treated true zeros versus reporting errors require smoothing. @seabbs. Added support varying length day week effect (see obs_opts()). allows, example, fitting data cases reported every 3 days. @seabbs. Adds option plot_estimates() higher level functions choose estimate type plot. @seabbs. Adds support fixed generation times (either mean fixed gamma distributed). @sbfnk. Adds support optionally using inverse gamma prior lengthscale gaussian process. scaled prior tested short long simulations default prior may make model unstable. new prior stable long simulations adaptively change distribution based simulation length (total number days) without relying user inputs fixed defaults. can tested setting ls_sd = 0 gp_opts(). @hsbadr. Updated prior magnitude gaussian process 0.05 vs 0.1 leading slightly stable estimates. @hsbadr. Added argument (plot) regional_summary allow plotting optional. Closes #250. @seabbs #317","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"model-changes-1-3-3","dir":"Changelog","previous_headings":"","what":"Model changes","title":"EpiNow2 1.3.3","text":"Added support varying length day week effect (see obs_opts()). allows, example, fitting data cases reported every 3 days. Minor optimisations observation model using target likelihood definition approach required use fmax fmin using statements. @seabbs. Added support users setting overdispersion (parameterised one square root phi) reporting process. accessible via phi argument obs_opts default normal distribution mean 0 standard deviation 1 truncated 0 remaining unchanged. @seabbs. Added additive noise term estimate_truncation model deal zeroes. @sbfnk. Switched using optimised versions discretised distributions supported reporting delay generation time. based implementation epinowcast Adrian Lison Sam Abbott. @seabbs #320.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"documentation-1-3-3","dir":"Changelog","previous_headings":"","what":"Documentation","title":"EpiNow2 1.3.3","text":"Updates synthetic delays reduce runtime examples. @seabbs. Additional statements make clear users examples used real world analysis. @seabbs. Additional context README package functionality. @seabbs. Added work progress model definitions resource list case studies using package. @seabbs.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"package-changes-1-3-3","dir":"Changelog","previous_headings":"","what":"Package changes","title":"EpiNow2 1.3.3","text":"Added contributing.md guide contributors added pre-commit support check new contributions styling. @seabbs. Better test skipping thanks @Bisaloo. Switched cowplot::theme_cowplot() ggplot2::theme_bw(). allows removal cowplot dependency well making plots visible users saving pngs using dark theme. @seabbs. default epinow downstream functions remove leading zeros. Now optional new filter_leading_zeros option. Thanks @LloydChapman #285. Basic tests added cover estimate_secondary(), forecast_secondary(), estimate_truncation(). @seabbs #315. Add basic snapshot tests adjust_infection_to_report. @seabbs #316. Update use rstantools manage compiler flags. Update Dockerfile work better vscode.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"other-changes-1-3-3","dir":"Changelog","previous_headings":"","what":"Other changes","title":"EpiNow2 1.3.3","text":"Updated classification growth use stable rather unsure Rt approximately 1. @seabbs. default parallisation changed future::multisession() future::multiprocess() latter depreciated future package. @seabbs @sbfnk. Ensure seeding time least maximum generation time (@sbfnk).","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"deprecated-features-1-3-3","dir":"Changelog","previous_headings":"","what":"Deprecated features","title":"EpiNow2 1.3.3","text":"simulate_cases() forecast_infections() deprecated removed. functions depend EpiSoon archived near equivalent functionality available within EpiNow2 packages (@seabbs). Functions supporting secondary forecasting using forecast_infections() (.e `epinow()) removed along arguments supported (@seabbs). global_map(), country_map(), theme_map() deprecated removed. functions used support reporting reproduction number estimates considered scope EpiNow2. finding useful contacting EpiNow2 developers (@seabbs).","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"bug-fixes-1-3-3","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"EpiNow2 1.3.3","text":"Fixed bug deconvolution Rt estimation method mean generation time used standard deviation. default package generation time close impact limited cases standard deviation << mean result accurate Rt estimates. @seabbs. Fixed bug number threads used data.table package set one global environment. Now number threads used data.table set whatever used specified exit. @medewitt. Fixed bug simulate_infections forecast_secondary meant Poisson observation model used estimation lead error. @seabbs. Fixed bug use_rt = FALSE properly cancel user settings. @sbfnk. Fixed bug estimate_truncation phi initialised. @sbfnk. Fixed bug zero_threshold ignored post-processing happening. maintain backwards compatibility default changed Inf (.e. zero threshold). @LloydChapman #285. Fixed bug setting obs_opts(return_likelihood = TRUE) fails. @sbfnk #333.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-132","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.3.2","title":"EpiNow2 1.3.2","text":"CRAN release: 2020-12-14 release model run times reduced using combination code optimisation testing reduce likelihood long running edge cases. Model flexibility also increased, particularly back calculation approach now supports increased range prior choices. significant development release edition experimental estimate_secondary model (supporting forecast plot functions). allows downstream target forecast observation. Example use cases include forecasting deaths test positive cases hospital bed usage hospital admissions. approach intended provide alternative models multiple targets estimated jointly.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"new-features-1-3-2","dir":"Changelog","previous_headings":"","what":"New features","title":"EpiNow2 1.3.2","text":"Added new argument, prior, backcalc_opts(). allows use different priors underlying latent infections estimating using deconvolution/back-calculation rather package default using generated Rt model (enable option setting rt = NULL). default prior remains smoothed mean delay shifted reported cases optionally prior can now also used (scenarios data untrustworthy likely perform extremely poorly real time).addition, previously estimated infections can used (.e infections[t] = infections[t-1] * exp(GP)) approximate version generative Rt model weight previous infections using generation time. Updates smoothing applied mean shifted reported cases used prior back calculation prior = \"reports\" partial centred moving average rather right aligned moving average. choice means increasing prior window alter location epidemic peaks using right alighted moving average. Updates default smoothing applied mean shifted reported cases 14 days rather 7 usage indicates provided much weight small scale changes. remains user set able. Adds new argument init_fit stan_opts() enables user pass stanfit use initialise model fit estimate_infections(). Optionally init_fit = \"cumulative\" can also passed first fits cumulative data uses result initialise full fit incidence data. approach based approach used epidemia authored James Scott. Currently stan warnings initial fit broadcast user may cause concern short run time approximate settings often lead poor convergence. Adds estimate_secondary forecast_secondary along plot method new option function (secondary_opts()). functions implement generic model forecasting secondary observation (hospital bed usage, deaths hospital) entirely depends primary observation (hospital admissions) via combination convolving delay adding/subtracting current observations. share observation model optional features used estimate_infections support data truncation, scaling (primary secondary observations), multiple log normal delays, day week effect, various error models. stationary_opts() allows easy specification common use cases (incidence prevalence variables). See documentation examples model details.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"other-changes-1-3-2","dir":"Changelog","previous_headings":"","what":"Other changes","title":"EpiNow2 1.3.2","text":"Updates discretised_gamma_pmf (discretised truncated Gamma PMF) discretised_lognormal_pmf (discretised truncated lognormal PMF) limit/clip values parameters prespecified lower upper bounds. Tightens initialisation fitting estimate_infections reducing standard deviations used scaling factor 0.1 create_initial_conditions. Adds boundary checking gt_mean (mean generation time) reject samples mean greater gt_max (maximum allowed generation time). Adds boundary checking reject standard deviations negative. Adds boundary check R values reject 10 times greater mean initial prior. scenarios require users supply prior completely misspecified (.e prior mean 1 posterior mean 50). Refactor update_rt (internal stan function found inst/stan/functions/rt.stan) vectorised. change reduces run times approximately 1- ~ 20% (though tested small subset examples) opens way future model extensions (additive rather multiplicative random walks, introducing covariates). Switched reporting two significant figures summary tables Reduced minimum default Gaussian process length scale 3 days 7 based experience running model scale.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-131","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.3.1","title":"EpiNow2 1.3.1","text":"CRAN release: 2020-11-22 release focusses model stability, functional rewrite model implementation, finalising interface across package, introducing additional tooling. additional tooling includes: support adjusting estimating data truncation, multiple approaches estimating Rt (including default generative Rt approach, de-convolution coupled Rt calculation, EpiEstim like estimation observed cases robust observation model), optional scaling observed data, optional adjustment future forecasts based population susceptibility. examples also expanded links Covid-19 specific work flows may interest users. implementation model options now considered maturing next release planned contain documentation underlying approach, case studies, validation, evaluation various supported options, tools dealing secondary reports dependent primary report (.e hospital admissions hospital bed usage). interested contributing features please contact package authors submit PR. User contributions warmly welcomed.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"new-features-1-3-1","dir":"Changelog","previous_headings":"","what":"New features","title":"EpiNow2 1.3.1","text":"Rewritten interface estimate_infections divided calls _opts() functions. Options now divided type delays (delay_opts()), Rt (rt_opts()), backcalculation (backcalc_opts()), Gaussian process (gp_opts()), stan arguments (stan_opts()). resulted larger number arguments estimate_infections folded related _opts() function. Please see function documentation examples details. Added support region specific settings arguments take _opts() function regional_epinow using helper functions opts_list update_list alternatively constructing named list entry region estimated. Extended functionality back calculation model Rt can produced via calculation. estimates potentially less reliable produced using generative model model can estimated fraction time. essence similar using back projection method estimating Rt using EpiEstim (default window 1 can updated using backcalc_opts(rt_window)) approaches incorporates uncertainty inputs single estimate. Reduced default maximum generation time incubation period allowed truncated distribution (30 days 15). decreases model run time substantially marginal accuracy cost. new default suitable longer generation times modified user used. Adds basic S3 plot summary measures epinow estimate_infections. Updates initialisation generative Rt model (default) initial infections occur unobserved time (.e first reported case) generated using exponential growth model priors based fitting model first week data. replaces previous approach use delay shifted reported cases multiplied independent noise terms. reduces degrees freedom fitting time cost model flexibility. Alternatives using generative Rt model considered ultimately approaches used introduced spurious variation gaussian process result unreliable Rt estimates due lack historic infections. New simulate_infections function @sbfnk allows simulation different Rt traces combined estimates produced estimate_infections. function likely form basis moving forecasting estimate_infections may improve model stability. Updates implementation Gaussian process support Matern 3/2 Kernel (set default) addition squared exponential kernel. Updates handling Gaussian process arguments overridden settings need passed user making changes. Settings now defined, documented, gp_opts(). length scale now defined using log normal truncated prior mean 21 days standard deviation 7 days truncated 3 days length data default. prior area active research may change future releases. Updates dispersion prior 1 / sqrt(half_normal(0, rho_prior)) based advice dispersion measured reports infections hence priori strong evidence dispersion (may case infections) previous prior overly weighted towards . Updates interface observation model arguments now passed using obs_opts(). removes week_effect family main argument list allow future extensions. Also adds new argument scale controls uncertain fraction cases eventually observed (defined normally distributed). Setting parameter impact Rt estimates. Updates interface Rt settings arguments passed via rt, using rt_opts(), includes initial prior,use_breakpoints, future. Adds new helper argument rw enables easy parameterisation fixed length random walk. changes also help make clear arguments impact Rt generative model back calculation model. Adds adjustment population susceptibility based used {epidemia} Rt fixed future (set passing population rt_opts(pop = initial susceptible population). Note impacts case forecasts output Rt estimates impacts estimates beyond forecast horizon based data already account population susceptibility definition. impact assumption can explored using simulate_infections (updating est$arg$pop example). Adds truncation new argument estimate_infections higher level functions. takes output trunc_opts() allows internally adjusting observed cases truncation. new method estimate_truncation also added support estimating log normal truncation distribution archived versions data set though method currently experimental. Adds estimate_delay user friendly wrapper around bootstrapped_dist_fit.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"other-changes-1-3-1","dir":"Changelog","previous_headings":"","what":"Other changes","title":"EpiNow2 1.3.1","text":"Recoded core stan model functional aim making code modular extendable. Added unit tests internal stan update_rt function. Reworked package logging system improve reporting issues epinow regional_epinow large batch runs. Fix @hsbadr prevent overflow overdispersion larger (switching Poisson approximation). Hitting issue may indicate bug model code need work explore. Moved default verbosity functions (excepting regional_epinow) based whether usage interactive. Removed burn_in argument estimate_infections updates model initialisation mean feature likely longer needed. Please contact developers feel use case argument. Adds utility functions map mean standard deviation log mean log standard deviation log normal distribution (convert_to_logmean convert_to_logsd). Optimised discrete probability mass functions vectorised possible. Updated Gaussian process internally unit scale. Added new function, expose_stan_fns exposes internal stan functions R. enables unit testing, exploration stan functionality potentially within R use cases functions. Updates default warmup 250 samples default adapt_delta 0.98. Adds pooling parameter standard deviation breakpoint effects. Updated documentation added lifecycle badges functions indicate development stage.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-121","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.2.1","title":"EpiNow2 1.2.1","text":"CRAN release: 2020-10-20 release introduces multiple breaking interface changes. Please see README examples new interface. adds range quality life improvements including updating stan interface support fitting chain independently offering variational inference alternative, experimental, fitting option. Notably also adds support nesting logging parallel enabled progress bar via progressr package. Minor bugs fixed core model implementation focussing stability several already implemented features extended. Major model developments planned next release EpiNow2.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"new-features-1-2-1","dir":"Changelog","previous_headings":"","what":"New features","title":"EpiNow2 1.2.1","text":"Added support either NUTs sampling (method = \"exact\") Variational inference (method = \"approximate\"). Update prior initial Rt estimate lognormal rather gamma distributed. users interface remains unchanged parameterisation numerically stable. Added get_dist, get_generation_time, get_incubation_period based ideas @pearsonca. (leads breaking changes removal covid_generation_times covid_incubation_periods). Added setup_logging enable users specify level location logging (wrapping functionality futile.logger). Also added setup_default_logging give users sensible defaults embedded function regional_epinow epinow. Added setup_future making using nested futures easier (required using future = TRUE). Implemented progress bar support using progressr. Added timeout timing option regional_epinow Improved logging warnings regional_epinow Enabled user specify credible intervals desired 20%, 50% 90% calculated default. Also switched high density regions quantiles. Custom credible intervals now supported reporting plotting functions. Added mean sd reporting summaries. Added summary growth rate doubling time. Added new function regional_runtimes summarises run time across regions. Updated estimate_infections interface expanded range options future_rt argument. Users can now choose set Rt time point referenced forecast date.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"bug-fixes-1-2-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"EpiNow2 1.2.1","text":"Fixed y axis max plot_summary. Fix normalisation delay generation time distributions @sbfnk. impact nowcast infections reproduction number estimate. Updated discretised_gamma_pmf (discretised truncated Gamma PMF) constrain gamma shape (inverse) scale parameters positive finite (alpha > 0 beta > 0). Fixed readLines incomplete final line warnings. Fix @medewitt internal fit_chain function interaction rstan timing may introduced exception caused whole regions fail. show current unit tests exploration using examples indicating gap testing.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"other-changes-1-2-1","dir":"Changelog","previous_headings":"","what":"Other changes","title":"EpiNow2 1.2.1","text":"Updates interface specifying output returned. Moved inherited stan arguments create_stan_args option override using stan_args. leads breaking changes - see examples details new interface. Updated example documentation reflect new interface. Added samples argument get_regional_results make loading samples optional. also allows samples dropped using regional_epinow reduces RAM usage. Cleaned wrapper functions move individual jobs functions. Adds testing high level functions low level unit testing. Adds csv download button interactive table regional summary table. Makevars updated remove dependency GNU Make @hsbadr","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-110","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.1.0","title":"EpiNow2 1.1.0","text":"CRAN release: 2020-09-01 Implemented reporting templates Bug fix estimate reporting Added additional reporting runtime errors Examples global_map country_map expanded @ellisp Improved ISO code matching global_map @ellisp Improvements data frames tibbles supported inputs. Updated reporting templates Updated reporting estimates clearly summarise cases infection report date. Made region summary plots optional. Made reporting decimal places standardised across metrics. README updated @kathsherratt Logging added @joeHickson Updated plotting limited scaling reported data (prevents upper CIs skewing plot). Added uncertainty plot bounds control y axis plots clarity purposes. regional_summary now saves input reported cases data reported_cases.csv. Added optional delay model Rt estimated directly data. option supported using backcalculation .","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-100","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.0.0","title":"EpiNow2 1.0.0","text":"Rebased package EpiNow Implemented backcalculation, estimation, forecasting, bootstrapped distribution fitting. Added options estimate time-varying reproduction number using Gaussian process (stationary non-stationary), combined optional user supplied breakpoints. Alternatively static reproduction number can assumed combined breakpoints becomes piecewise linear.","code":""}]
