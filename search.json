[{"path":[]},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement [INSERT CONTACT METHOD]. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"epiforecasts.io/EpiNow2/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https:// www.contributor-covenant.org/translations.","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to EpiNow2","title":"Contributing to EpiNow2","text":"outlines propose change EpiNow2.","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to EpiNow2","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to EpiNow2","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to EpiNow2","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"epiforecasts/EpiNow2\", fork = TRUE). Install development dependences devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). use pre-commit check changes match package standards. optional can enabled using following steps. Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":"# if python is not installed on your system install.packages(\"reticulate\") reticulate::install_miniconda() # install precommit if not already installed precommit::install_precommit() # set up precommit for use precommit::use_precommit()"},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to EpiNow2","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"epiforecasts.io/EpiNow2/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to EpiNow2","text":"Please note EpiNow2 project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"epiforecasts.io/EpiNow2/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 EpiForecasts Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/case-studies.html","id":"case-studies","dir":"Articles","previous_headings":"","what":"Case studies","title":"External case studies and use in the literature","text":"Estimating reporting delays nowcasting/forecasting infections EpiNow2 Sebastian Funk Sam Abbott. Forecast Covid-19 reported deaths Covid-19 reported cases (observed forecast) country ECDC Sam Abbott. Explore Covid-19 data truncation England Sam Abbott. Estimate effective reproduction number Covid-19 last 3 months country Sam Abbott.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/case-studies.html","id":"public-health-surveillance","dir":"Articles","previous_headings":"","what":"Public health surveillance","title":"External case studies and use in the literature","text":"CDC. 2022. “Technical Report 3: Multi-National Monkeypox Outbreak, United States, 2022.” Centers Disease Control Prevention. October 3, 2022. https://www.cdc.gov/poxvirus/monkeypox/cases-data/technical-report/report-3.html.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/articles/case-studies.html","id":"by-package-authors","dir":"Articles","previous_headings":"Literature","what":"By package authors","title":"External case studies and use in the literature","text":"Abbott, Sam, Joel Hellewell, Robin N. Thompson, Katharine Sherratt, Hamish P. Gibbs, Nikos . Bosse, James D. Munday, et al. 2020. “Estimating Time-Varying Reproduction Number SARS-CoV-2 Using National Subnational Case Counts.” Wellcome Open Research 5 (December): 112. http://dx.doi.org/10.12688/wellcomeopenres.16006.2 Sherratt, Katharine, Sam Abbott, Sophie R. Meakin, Joel Hellewell, James D. Munday, Nikos Bosse, Null Null, Mark Jit, Sebastian Funk. 2021. “Exploring Surveillance Data Biases Estimating Reproduction Number: Insights Subpopulation Transmission COVID-19 England.” Philosophical Transactions Royal Society London. Series B, Biological Sciences 376 (1829): 20200283. http://dx.doi.org/10.1098/rstb.2020.0283 Bosse, Nikos ., Sam Abbott, Johannes Bracher, Habakuk Hain, Billy J. Quilty, Mark Jit, Centre Mathematical Modelling Infectious Diseases COVID-19 Working Group, Edwin van Leeuwen, Anne Cori, Sebastian Funk. 2022. “Comparing Human Model-Based Forecasts COVID-19 Germany Poland.” PLoS Computational Biology 18 (9): e1010405. http://dx.doi.org/10.1371/journal.pcbi.1010405 Davies, Nicholas G., Sam Abbott, Rosanna C. Barnard, Christopher . Jarvis, Adam J. Kucharski, James D. Munday, Carl . B. Pearson, et al. 2021. “Estimated Transmissibility Impact SARS-CoV-2 Lineage B.1.1.7 England.” Science 372 (6538). https://doi.org/10.1126/science.abg3055. Meakin, Sophie, Sam Abbott, Nikos Bosse, James Munday, Hugo Gruson, Joel Hellewell, Katharine Sherratt, CMMID COVID-19 Working Group, Sebastian Funk. 2022. “Comparative Assessment Methods Short-Term Forecasts COVID-19 Hospital Admissions England Local Level.” BMC Medicine 20 (1): 86. http://dx.doi.org/10.1186/s12916-022-02271-x","code":""},{"path":"epiforecasts.io/EpiNow2/articles/case-studies.html","id":"by-others","dir":"Articles","previous_headings":"Literature","what":"By others","title":"External case studies and use in the literature","text":"Hay, James ., Lee Kennedy-Shaffer, Sanjat Kanjilal, Niall J. Lennon, Stacey B. Gabriel, Marc Lipsitch, Michael J. Mina. 2021. “Estimating Epidemiologic Dynamics Cross-Sectional Viral Load Distributions.” Science 373 (6552). https://doi.org/10.1126/science.abh0635.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/estimate_infections.html","id":"renewal-equation-model","dir":"Articles","previous_headings":"","what":"Renewal equation model","title":"Model definition: estimate_infections()","text":"default model used rt != NULL.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/estimate_infections.html","id":"initialisation","dir":"Articles","previous_headings":"Renewal equation model","what":"Initialisation","title":"Model definition: estimate_infections()","text":"model initialised prior first observed data point assuming constant exponential growth mean assumed delays infection case report. \\[\\begin{align}   I_{t} &= I_0 \\exp  \\left(r t \\right)  \\\\   I_0 &\\sim \\mathcal{LN}(\\log I_{obs}, 0.2) \\\\   r &\\sim \\mathcal{LN}(r_{obs}, 0.2) \\end{align}\\]","code":""},{"path":"epiforecasts.io/EpiNow2/articles/estimate_infections.html","id":"within-the-range-of-observations","dir":"Articles","previous_headings":"Renewal equation model","what":"Within the range of observations","title":"Model definition: estimate_infections()","text":"\\(I_{obs}\\) \\(r_{obs}\\) estimated first week observed data. time window observed data infections modelled weighting previous infections generation time scaling instantaneous reproduction number. infections convolved cases onset date (\\(O_t\\)) cases date report (\\(D_t\\)) using log-normal delay distributions (though arbitrary delay distributions can used common formulation). model can defined mathematically follows, \\[\\begin{align}   \\log R_{t} &= \\log R_{t-1} + \\mathrm{GP}_t \\\\   I_t &= R_t \\sum_{\\tau = 1}^{T_I} w(\\tau | \\mu_{w}, \\sigma_{w}) I_{t - \\tau} \\\\   O_t &= \\sum_{\\tau = 0}^{T_O} \\xi_{O}(\\tau | \\mu_{\\xi_{O}}, \\sigma_{\\xi_{O}}) I_{t-\\tau} \\\\   D_t &= \\alpha \\sum_{\\tau = 0}^{T_D} \\xi_{D}(\\tau | \\mu_{\\xi_{D}}, \\sigma_{\\xi_{D}}) O_{t-\\tau} \\\\   C_t &\\sim \\mathrm{NB}\\left(\\omega_{(t \\mod 7)}D_t, \\phi\\right) \\end{align}\\] \\(T_I\\) maximum generation time, \\(T_O\\) maximum delay infection case onset, \\(T_D\\) maximum delay case onset report, \\(\\alpha\\) proportion cases ultimately reported (note optional arbitrary). delay distributions defined follows, \\[\\begin{align}      w &\\sim \\mathcal{Gamma}(\\mu_{w}, \\sigma_{w}) \\\\     \\xi_{O} &\\sim \\mathcal{LogNormal}(\\mu_{\\xi_{O}}, \\sigma_{\\xi_{O}}) \\\\     \\xi_{D} &\\sim \\mathcal{LogNormal}(\\mu_{\\xi_{D}}, \\sigma_{\\xi_{D}}) \\end{align}\\] model used following priors observation model \\[\\begin{align}     \\frac{\\omega}{7} &\\sim \\mathrm{Dirichlet}(1, 1, 1, 1, 1, 1, 1) \\\\     \\phi &\\sim \\frac{1}{\\sqrt{\\mathcal{N}(0, 1)}} \\end{align}\\] \\(\\phi\\) truncated greater 0 \\(\\xi\\), \\(w\\) normalised sum 1. priors set user. \\(GP_t\\) approximate Hilbert space Gaussian process defined [1] using Matern 3/2 kernel default boundary factor 1.5 basis functions scaled 20% number days fitted. length scale Gaussian process given log-normal prior mean 21 days, standard deviation 7 days truncated greater 3 days less length time-series. standard deviation magnitude Gaussian process assumed 0.1. settings changeable user. addition user can opt make use different generative process instead remove dependency previous value \\(R_t\\) options impacts run-time may alter best use-case model.","code":""},{"path":"epiforecasts.io/EpiNow2/articles/estimate_infections.html","id":"beyond-the-forecast-horizon","dir":"Articles","previous_headings":"Renewal equation model","what":"Beyond the forecast horizon","title":"Model definition: estimate_infections()","text":"Beyond forecast horizon (\\(T\\)), default, Gaussian process assumed continue. However, range options. included fixing transmission dynamics, scaling \\(R_t\\) based proportion population remain susceptible. defined followed, \\[\\begin{equation}     I_t = (N - ^c_{t-1}) \\left(1 - \\exp \\left(\\frac{-'_t}{N - ^c_{T}}\\right)\\right), \\end{equation}\\] \\(^c_t = \\sum_{s< t} I_s\\) cumulative infections \\(t-1\\) \\('_t\\) unadjusted infections defined . adjustment based one implemented epidemia R package[2].","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sam Abbott. Author, maintainer. Joel Hellewell. Author. Katharine Sherratt. Author. Katelyn Gostic. Author. Joe Hickson. Author. Hamada S. Badr. Author. Michael DeWitt. Author. Robin Thompson. Contributor. Sophie Meakin. Contributor. James Munday. Contributor. Nikos Bosse. Contributor. Paul Mee. Contributor. Peter Ellis. Contributor. Pietro Monticone. Contributor. Lloyd Chapman. Contributor. EpiForecasts. Author. Sebastian Funk. Author.","code":""},{"path":"epiforecasts.io/EpiNow2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sam Abbott, Joel Hellewell, Katharine Sherratt, Katelyn Gostic,           Joe Hickson, Hamada S. Badr, Michael DeWitt, Robin Thompson, EpiForecasts,          Sebastian Funk (2020). EpiNow2: Estimate Real-Time Case Counts Time-Varying Epidemiological Parameters,  DOI: 10.5281/zenodo.3957489","code":"@Manual{,   title = {EpiNow2: Estimate Real-Time Case Counts and Time-Varying Epidemiological Parameters},   author = {Sam Abbott and Joel Hellewell and Katharine Sherratt and Katelyn Gostic and Joe Hickson and Hamada S. Badr and Michael DeWitt and Robin Thompson and {EpiForecasts} and Sebastian Funk},   year = {2020},   doi = {10.5281/zenodo.3957489}, }"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"epinow2-estimate-real-time-case-counts-and-time-varying-epidemiological-parameters","dir":"","previous_headings":"","what":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"package estimates time-varying reproduction number, growth rate, doubling time using range open-source tools (Abbott et al.), current best practices (Gostic et al.). aims help users avoid limitations naive implementations framework informed community feedback actively supported. estimates time-varying reproduction number cases date infection (using similar approach implemented {EpiEstim}). Imputed infections mapped observed data (example cases date report) via series uncertain delay distributions (examples package documentation incubation period reporting delay) reporting model can include weekly periodicity. Uncertainty propagated inputs final parameter estimates, helping mitigate spurious findings. handled internally. time-varying reproduction estimates uncertain generation time also give time-varying estimates rate growth. default model uses non-stationary Gaussian process estimate time-varying reproduction number infer infections. options include: stationary Gaussian process (faster estimate currently gives reduced performance real time estimates). User specified breakpoints. fixed reproduction number. piecewise constant combining fixed reproduction number breakpoints. random walk (combining fixed reproduction number regularly spaced breakpoints (.e weekly)). Inferring infections using back-calculation calculating time-varying reproduction number. Adjustment remaining susceptible population beyond forecast horizon. options generally reduce runtimes cost granularity estimates cost real-time performance. documentation estimate_infections provides examples implementation different options available. Forecasting also supported time-varying reproduction number, infections reported cases using generative process approach used estimation. simple example using package estimate national Rt Covid-19 can found . EpiNow2 also supports adjustment truncated data via estimate_truncation() (though users may interested flexibility check epinowcast package), estimating dependent observations (.e deaths based hospital admissions) using estimate_secondary().","code":""},{"path":"epiforecasts.io/EpiNow2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"Install stable version package: Install stable development version package : Install unstable development version package (users need ): Windows users need working installation Rtools order build package source. See guide installing Rtools use Stan (statistical modelling platform used underlying model). simple deployment/development prebuilt docker image also available (see documentation ).","code":"install.packages(\"EpiNow2\") install.packages(\"EpiNow2\", repos = \"https://epiforecasts.r-universe.dev\") remotes::install_github(\"epiforecasts/EpiNow2\")"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"EpiNow2 designed used single function call used ad-hoc fashion via individual function calls. core functions EpiNow2 two single-call functions epinow(), regional_epinow(), plus functions estimate_infections(), estimate_secondary() estimate_truncation(). following section give overview simple use case epinow regional_epinow. estimate_infections() can used infer underlying infection case curve reported cases estimate Rt. Estimating underlying infection case curve via back-calculation (calculating Rt) substantially less computationally demanding generating using default settings may result less reliable estimates Rt. details using function see function documentation. first step using package load follows.","code":"library(EpiNow2)"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"reporting-delays-incubation-period-and-generation-time","dir":"","previous_headings":"Quick start","what":"Reporting delays, incubation period and generation time","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"Distributions can either fitted using package functionality determined elsewhere defined uncertainty use EpiNow2. data supplied subsampled bootstrapped lognormal fit (account uncertainty observed data without biased changes incidence). arbitrary number delay distributions supported common use case likely incubation period followed reporting delay. example data delay onset infection available fit distribution appropriate uncertainty follows (note synthetic example), data available instead make informed estimate likely delay (note synthetic example applicable real world use cases), define incubation period generation time based literature estimates Covid-19 (see code generates estimates). Note distributions may applicable use case.","code":"reporting_delay <- estimate_delay(   rlnorm(1000, log(2), 1), max_value = 15, bootstraps = 1 ) reporting_delay <- list(   mean = convert_to_logmean(2, 1), mean_sd = 0.1,   sd = convert_to_logsd(2, 1), sd_sd = 0.1,   max = 10 ) generation_time <- get_generation_time(   disease = \"SARS-CoV-2\", source = \"ganyani\" ) incubation_period <- get_incubation_period(   disease = \"SARS-CoV-2\", source = \"lauer\" )"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"epinow","dir":"","previous_headings":"Quick start","what":"epinow()","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"function represents core functionality package includes results reporting, plotting optional saving. requires data frame cases date report distributions defined . Load example case data EpiNow2. Estimate cases date infection, time-varying reproduction number, rate growth forecast estimates future 7 days. Summarise posterior return summary table plots reporting purposes. target_folder supplied results can internally saved (option also turn explicit returning results). use default model parameterisation priorities real-time performance run-time considerations. formulations see documentation estimate_infections(). summary measures posterior samples returned parameters easily explored format can accessed using summary. default return summary table estimates key parameters latest date partially supported data. Summarised parameter estimates can also easily returned, either filtered single parameter parameters. Reported cases returned separate data frame order streamline reporting forecasts model evaluation. range plots returned (single summary plot shown ). plots can also generated using following plot method.","code":"reported_cases <- example_confirmed[1:60] head(reported_cases) #>          date confirm #>        <Date>   <num> #> 1: 2020-02-22      14 #> 2: 2020-02-23      62 #> 3: 2020-02-24      53 #> 4: 2020-02-25      97 #> 5: 2020-02-26      93 #> 6: 2020-02-27      78 estimates <- epinow(   reported_cases = reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.2)),   stan = stan_opts(cores = 4),   verbose = interactive() ) #> WARN [2022-10-17 14:32:32] epinow: There were 7 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. -  #> WARN [2022-10-17 14:32:32] epinow: Examine the pairs() plot to diagnose sampling problems #>  - names(estimates) #> [1] \"estimates\"                \"estimated_reported_cases\" #> [3] \"summary\"                  \"plots\"                    #> [5] \"timing\" knitr::kable(summary(estimates)) head(summary(estimates, type = \"parameters\", params = \"R\")) #>          date variable  strat     type   median     mean         sd lower_90 #>        <Date>   <char> <char>   <char>    <num>    <num>      <num>    <num> #> 1: 2020-03-01        R   <NA> estimate 2.032944 2.034600 0.12263909 1.835007 #> 2: 2020-03-02        R   <NA> estimate 1.985030 1.984939 0.09867913 1.822082 #> 3: 2020-03-03        R   <NA> estimate 1.934373 1.933439 0.07997513 1.802737 #> 4: 2020-03-04        R   <NA> estimate 1.880721 1.880345 0.06627518 1.774494 #> 5: 2020-03-05        R   <NA> estimate 1.825444 1.825928 0.05691746 1.736169 #> 6: 2020-03-06        R   <NA> estimate 1.769794 1.770473 0.05090067 1.690933 #>    lower_50 lower_20 upper_20 upper_50 upper_90 #>       <num>    <num>    <num>    <num>    <num> #> 1: 1.950837 2.002272 2.064961 2.114401 2.234420 #> 2: 1.917444 1.960005 2.010231 2.048900 2.145482 #> 3: 1.877844 1.913317 1.954001 1.986164 2.065259 #> 4: 1.834894 1.863750 1.895996 1.923908 1.990647 #> 5: 1.786278 1.811667 1.837823 1.863695 1.917388 #> 6: 1.735544 1.756891 1.780755 1.805549 1.853105 head(summary(estimates, output = \"estimated_reported_cases\")) #>          date   type median     mean        sd lower_90 lower_50 lower_20 #>        <Date> <char>  <num>    <num>     <num>    <num>    <num>    <num> #> 1: 2020-03-01  gp_rt    475 483.0345  97.82515   344.00   412.00      449 #> 2: 2020-03-02  gp_rt    459 468.1570  91.35410   336.00   405.00      437 #> 3: 2020-03-03  gp_rt    404 409.2815  80.80733   289.00   351.00      383 #> 4: 2020-03-04  gp_rt    389 397.9765  80.98656   281.95   342.00      372 #> 5: 2020-03-05  gp_rt    533 543.8765 109.13966   380.95   470.00      509 #> 6: 2020-03-06  gp_rt    749 759.3375 146.37409   535.95   652.75      714 #>    upper_20 upper_50 upper_90 #>       <num>    <num>    <num> #> 1:      500   538.00   652.00 #> 2:      483   521.00   629.10 #> 3:      425   459.00   551.05 #> 4:      409   446.00   548.05 #> 5:      560   611.00   734.00 #> 6:      788   852.25  1008.05 plot(estimates)"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"regional_epinow","dir":"","previous_headings":"Quick start","what":"regional_epinow()","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"regional_epinow() function runs epinow() function across multiple regions efficient manner. Define cases multiple regions delineated region variable. Calling regional_epinow() runs epinow() region turn (parallel depending settings used). switch using weekly random walk rather full Gaussian process model giving us piecewise constant estimates week. Results region stored regional list across region summary measures plots stored summary list. results can set internally saved setting target_folder summary_dir arguments. region can estimated parallel using future package (scenarios cores set 1). routine use MCMC chain can also run parallel (future = TRUE) time (max_execution_time) allowing partial results returned subset chains running longer expected. See documentation future package details nested futures. Summary measures returned include table formatted reporting (along raw results processing). Futures updated extend S3 methods used smooth access output. range plots returned (single summary plot shown ).","code":"reported_cases <- data.table::rbindlist(list(    data.table::copy(reported_cases)[, region := \"testland\"],    reported_cases[, region := \"realland\"])) head(reported_cases) #>          date confirm   region #>        <Date>   <num>   <char> #> 1: 2020-02-22      14 testland #> 2: 2020-02-23      62 testland #> 3: 2020-02-24      53 testland #> 4: 2020-02-25      97 testland #> 5: 2020-02-26      93 testland #> 6: 2020-02-27      78 testland estimates <- regional_epinow(   reported_cases = reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.2), rw = 7),   gp = NULL,   stan = stan_opts(cores = 4, warmup = 250, samples = 1000) ) #> INFO [2022-10-17 14:32:38] Producing following optional outputs: regions, summary, samples, plots, latest #> INFO [2022-10-17 14:32:38] Reporting estimates using data up to: 2020-04-21 #> INFO [2022-10-17 14:32:38] No target directory specified so returning output #> INFO [2022-10-17 14:32:38] Producing estimates for: testland, realland #> INFO [2022-10-17 14:32:38] Regions excluded: none #> INFO [2022-10-17 14:46:01] Completed estimates for: testland #> INFO [2022-10-17 14:54:19] Completed estimates for: realland #> INFO [2022-10-17 14:54:19] Completed regional estimates #> INFO [2022-10-17 14:54:19] Regions with estimates: 2 #> INFO [2022-10-17 14:54:19] Regions with runtime errors: 0 #> INFO [2022-10-17 14:54:19] Producing summary #> INFO [2022-10-17 14:54:19] No summary directory specified so returning summary output #> INFO [2022-10-17 14:54:20] No target directory specified so returning timings knitr::kable(estimates$summary$summarised_results$table) estimates$summary$summary_plot"},{"path":"epiforecasts.io/EpiNow2/index.html","id":"reporting-templates","dir":"","previous_headings":"Quick start","what":"Reporting templates","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"Rmarkdown templates provided package (templates) semi-automated reporting estimates. using templates report results please highlight limitations key understanding results EpiNow2 .","code":""},{"path":"epiforecasts.io/EpiNow2/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Estimate Real-Time Case Counts and Time-Varying\n    Epidemiological Parameters","text":"File issue identified issue package. Please note due operational constraints priority given users informing government policy offering methodological insights. welcome contributions, particular improve approach robustness code base. also welcome additions extensions underlying model either form options improvements.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/EpiNow2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"EpiNow2: Estimate Real-Time Case Counts and Time-Varying Epidemiological Parameters — EpiNow2-package","title":"EpiNow2: Estimate Real-Time Case Counts and Time-Varying Epidemiological Parameters — EpiNow2-package","text":"Estimates time-varying reproduction number, rate spread, doubling time using range open-source tools (Abbott et al. (2020) doi:10.12688/wellcomeopenres.16006.1 ), current best practices (Gostic et al. (2020) doi:10.1101/2020.06.18.20134858 ). aims help users avoid limitations naive implementations framework informed community feedback actively supported.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/EpiNow2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"EpiNow2: Estimate Real-Time Case Counts and Time-Varying Epidemiological Parameters — EpiNow2-package","text":"Maintainer: Sam Abbott sam.abbott@lshtm.ac.uk (ORCID) Authors: Joel Hellewell joel.hellewell@lshtm.ac.uk (ORCID) Katharine Sherratt katharine.sherratt@lshtm.ac.uk Katelyn Gostic kgostic@uchicago.edu Joe Hickson joseph.hickson@metoffice.gov.uk Hamada S. Badr badr@jhu.edu (ORCID) Michael DeWitt .dewitt.jr@gmail.com (ORCID) EpiForecasts Sebastian Funk sebastian.funk@lshtm.ac.uk contributors: Robin Thompson robin.thompson@lshtm.ac.uk [contributor] Sophie Meakin sophie.meaking@lshtm.ac.uk [contributor] James Munday james.munday@lshtm.ac.uk [contributor] Nikos Bosse [contributor] Paul Mee paul.mee@lshtm.ac.uk [contributor] Peter Ellis peter.ellis2013nz@gmail.com [contributor] Pietro Monticone pietro.monticone@edu.unito.[contributor] Lloyd Chapman lloyd.chapman1@lshtm.ac.uk  [contributor]","code":""},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Reproduction Numbers to Growth Rates — R_to_growth","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"See justification. Now handled internally stan may removed future updates user demand.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"","code":"R_to_growth(R, gamma_mean, gamma_sd)"},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"R Numeric, Reproduction number estimates gamma_mean Numeric, mean gamma distribution gamma_sd Numeric, standard deviation gamma distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"Numeric vector reproduction number estimates","code":""},{"path":"epiforecasts.io/EpiNow2/reference/R_to_growth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Reproduction Numbers to Growth Rates — R_to_growth","text":"","code":"R_to_growth(2.18, 4, 1) #> [1] 0.1996541"},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":null,"dir":"Reference","previous_headings":"","what":"Adds a day of the week vector — add_day_of_week","title":"Adds a day of the week vector — add_day_of_week","text":"Adds day week vector","code":""},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adds a day of the week vector — add_day_of_week","text":"","code":"add_day_of_week(dates, week_effect = 7)"},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adds a day of the week vector — add_day_of_week","text":"dates Vector dates week_effect Numeric 1 7 defaults 7","code":""},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adds a day of the week vector — add_day_of_week","text":"numeric vector containing period day week index","code":""},{"path":"epiforecasts.io/EpiNow2/reference/add_day_of_week.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adds a day of the week vector — add_day_of_week","text":"","code":"dates <- seq(as.Date(\"2020-03-15\"), by = \"days\", length.out = 15) # Add date based day of week add_day_of_week(dates, 7) #>  [1] 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7  # Add shorter week add_day_of_week(dates, 4) #>  [1] 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2"},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"Maps cases date infection date report via date onset.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"","code":"adjust_infection_to_report(   infections,   delay_defs,   reporting_model,   reporting_effect,   type = \"sample\",   truncate_future = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"infections data.table containing date variable numeric cases variable. delay_defs list single row data.tables  defines delay distribution (model, parameters maximum delay model). See lognorm_dist_def example structure. reporting_model function takes single numeric vector argument returns single numeric vector. Can used apply stochastic reporting effects. See examples details. reporting_effect numeric vector length 7 allows scaling reported cases day report (1 = Monday, 7 = Sunday). default scaling occurs. type Character string indicating method use transform counts. Supports either \"sample\" approximates sampling \"median\" shift median distribution. truncate_future Logical, cases truncated occur first date reported data. Defaults TRUE.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"data.table containing date variable (date report) cases variable. return_onset = TRUE third variable reference indicates date variable refers .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/adjust_infection_to_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adjust from Case Counts by Infection Date to Date of Report — adjust_infection_to_report","text":"","code":"# \\donttest{ # define example cases cases <- data.table::copy(example_confirmed)[, cases := as.integer(confirm)]  # define a single report delay distribution delay_def <- lognorm_dist_def(   mean = 5, mean_sd = 1, sd = 3, sd_sd = 1,   max_value = 30, samples = 1, to_log = TRUE )  # define a single incubation period incubation_def <- lognorm_dist_def(   mean = incubation_periods[1, ]$mean,   mean_sd = incubation_periods[1, ]$mean_sd,   sd = incubation_periods[1, ]$sd,   sd_sd = incubation_periods[1, ]$sd_sd,   max_value = 30, samples = 1 )  # simple mapping report <- adjust_infection_to_report(cases, delay_defs = list(incubation_def, delay_def)) print(report) #>            date cases #>   1: 2020-02-26     3 #>   2: 2020-02-27    10 #>   3: 2020-02-28    25 #>   4: 2020-02-29    27 #>   5: 2020-03-01    39 #>  ---                  #> 122: 2020-06-26   241 #> 123: 2020-06-27   222 #> 124: 2020-06-28   223 #> 125: 2020-06-29   227 #> 126: 2020-06-30   251  # mapping with a weekly reporting effect report_weekly <- adjust_infection_to_report(   cases,   delay_defs = list(incubation_def, delay_def),   reporting_effect = c(1.1, rep(1, 4), 0.95, 0.95) ) print(report_weekly) #>            date cases #>   1: 2020-02-23     0 #>   2: 2020-02-24     0 #>   3: 2020-02-25     1 #>   4: 2020-02-26     2 #>   5: 2020-02-27    10 #>  ---                  #> 125: 2020-06-26   256 #> 126: 2020-06-27   212 #> 127: 2020-06-28   218 #> 128: 2020-06-29   286 #> 129: 2020-06-30   248  # map using a deterministic median shift for both delays report_median <- adjust_infection_to_report(cases,   delay_defs = list(incubation_def, delay_def),   type = \"median\" ) print(report_median) #>            date confirm cases #>   1: 2020-03-03      14    14 #>   2: 2020-03-04      62    62 #>   3: 2020-03-05      53    53 #>   4: 2020-03-06      97    97 #>   5: 2020-03-07      93    93 #>  ---                          #> 126: 2020-07-06     296   296 #> 127: 2020-07-07     255   255 #> 128: 2020-07-08     175   175 #> 129: 2020-07-09     174   174 #> 130: 2020-07-10     126   126  # map with a weekly reporting effect and stochastic reporting model report_stochastic <- adjust_infection_to_report(   cases,   delay_defs = list(incubation_def, delay_def),   reporting_effect = c(1.1, rep(1, 4), 0.95, 0.95),   reporting_model = function(n) {     out <- suppressWarnings(rnbinom(length(n), as.integer(n), 0.5))     out <- ifelse(is.na(out), 0, out)   } ) print(report_stochastic) #>            date cases #>   1: 2020-02-25     0 #>   2: 2020-02-26     3 #>   3: 2020-02-27    10 #>   4: 2020-02-28     9 #>   5: 2020-02-29    29 #>  ---                  #> 123: 2020-06-26   248 #> 124: 2020-06-27   275 #> 125: 2020-06-28   223 #> 126: 2020-06-29   271 #> 127: 2020-06-30   199 # }"},{"path":"epiforecasts.io/EpiNow2/reference/allocate_delays.html","id":null,"dir":"Reference","previous_headings":"","what":"Allocate Delays into Required Stan Format — allocate_delays","title":"Allocate Delays into Required Stan Format — allocate_delays","text":"Allocate delays stan. Used delay_opts().","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_delays.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allocate Delays into Required Stan Format — allocate_delays","text":"","code":"allocate_delays(delay_var, no_delays)"},{"path":"epiforecasts.io/EpiNow2/reference/allocate_delays.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Allocate Delays into Required Stan Format — allocate_delays","text":"delay_var List numeric delays no_delays Numeric, number delays","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_delays.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Allocate Delays into Required Stan Format — allocate_delays","text":"numeric array","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Allocate Empty Parameters to a List — allocate_empty","title":"Allocate Empty Parameters to a List — allocate_empty","text":"Allocate missing parameters empty two dimensional arrays. Used internally simulate_infections.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allocate Empty Parameters to a List — allocate_empty","text":"","code":"allocate_empty(data, params, n = 0)"},{"path":"epiforecasts.io/EpiNow2/reference/allocate_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Allocate Empty Parameters to a List — allocate_empty","text":"data list parameters params character vector parameters allocate empty missing. n Numeric, number samples assign empty array","code":""},{"path":"epiforecasts.io/EpiNow2/reference/allocate_empty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Allocate Empty Parameters to a List — allocate_empty","text":"list parameters allocated empty","code":""},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Back Calculation Options — backcalc_opts","title":"Back Calculation Options — backcalc_opts","text":"Defines list specifying optional arguments back calculation cases. used rt = NULL.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Back Calculation Options — backcalc_opts","text":"","code":"backcalc_opts(prior = \"reports\", prior_window = 14, rt_window = 1)"},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Back Calculation Options — backcalc_opts","text":"prior character string defaulting \"reports\". Defines prior use deconvolving. Currently implemented options use smoothed mean delay shifted reported cases (\"reports\"), use estimated infections previous time step seeded first time step using mean shifted reported cases (\"infections\"), prior (\"none\"). Using prior result poor real time performance. prior using infections supported Gaussian process present. observed data reliable sensible first step explore increasing prior_window sensible second step longer use reported cases prior (.e set prior = \"none\"). prior_window Integer, defaults 14 days. mean centred smoothing window apply mean shifted reports (used prior back calculation). 7 days minimum recommended settings smooths day week effects depending quality data amount information users wish use prior (higher values equalling less informative prior). rt_window Integer, defaults 1. size centred rolling average use estimating Rt. must odd central estimate included.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Back Calculation Options — backcalc_opts","text":"list back calculation settings","code":""},{"path":"epiforecasts.io/EpiNow2/reference/backcalc_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Back Calculation Options — backcalc_opts","text":"","code":"# default settings backcalc_opts() #> $prior #> [1] \"reports\" #>  #> $prior_window #> [1] 14 #>  #> $rt_window #> [1] 1 #>"},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"Fits integer adjusted distribution subsampled bootstrap data integrates posterior samples single set summary statistics. Can used generate robust reporting delay accounts fact underlying delay likely varies time size available reporting delay sample may representative current case load.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"","code":"bootstrapped_dist_fit(   values,   dist = \"lognormal\",   samples = 2000,   bootstraps = 10,   bootstrap_samples = 250,   max_value,   verbose = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"values Integer vector values. dist Character string, distribution fit. Defaults lognormal (\"lognormal\") gamma (\"gamma\") also supported. samples Numeric, number samples take overall bootstrapped posteriors. bootstraps Numeric, defaults 1. number bootstrap samples (replacement) delay distribution take. bootstrap_samples Numeric, defaults 100. number samples take bootstrap. sample size supplied delay distribution less 100 used instead. max_value Numeric, defaults  maximum value observed data. Maximum delay allow (added output impact fitting). verbose Logical, defaults FALSE. progress messages printed","code":""},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"list summarising bootstrapped distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/bootstrapped_dist_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Subsampled Bootstrap to Integer Values and Summarise Distribution Parameters — bootstrapped_dist_fit","text":"","code":"# \\donttest{ # lognormal delays <- rlnorm(500, log(5), 1) out <- bootstrapped_dist_fit(delays,   samples = 1000, bootstraps = 10,   dist = \"lognormal\" ) out #> $mean #> [1] 1.480063 #>  #> $mean_sd #> [1] 0.1242098 #>  #> $sd #> [1] 1.085863 #>  #> $sd_sd #> [1] 0.07667653 #>  #> $max #> [1] 129 #>  # }"},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Credible Interval — calc_CrI","title":"Calculate Credible Interval — calc_CrI","text":"Adds symmetric credible interval based quantiles.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Credible Interval — calc_CrI","text":"","code":"calc_CrI(samples, summarise_by = c(), CrI = 0.9)"},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Credible Interval — calc_CrI","text":"samples data.table containing least value variable summarise_by character vector variables group . CrI Numeric 0 1. credible interval return values. Defaults 0.9.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Credible Interval — calc_CrI","text":"data.table containing upper lower bounds specified credible interval","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Credible Interval — calc_CrI","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") # add 90% credible interval calc_CrI(samples) #>    value      CrI #> 1:  1.45 lower_90 #> 2:  9.55 upper_90 # add 90% credible interval grouped by type calc_CrI(samples, summarise_by = \"type\") #>    type value      CrI #> 1:  car  1.45 lower_90 #> 2:  car  9.55 upper_90"},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Credible Intervals — calc_CrIs","title":"Calculate Credible Intervals — calc_CrIs","text":"Adds symmetric credible intervals based quantiles.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Credible Intervals — calc_CrIs","text":"","code":"calc_CrIs(samples, summarise_by = c(), CrIs = c(0.2, 0.5, 0.9))"},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Credible Intervals — calc_CrIs","text":"samples data.table containing least value variable summarise_by character vector variables group . CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Credible Intervals — calc_CrIs","text":"data.table containing summarise_by variables specified lower upper credible intervals","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_CrIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Credible Intervals — calc_CrIs","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") # add credible intervals calc_CrIs(samples) #>    . lower_90 lower_50 lower_20 upper_20 upper_50 upper_90 #> 1: .     1.45     3.25      4.6      6.4     7.75     9.55 # add 90% credible interval grouped by type calc_CrIs(samples, summarise_by = \"type\") #>    type lower_90 lower_50 lower_20 upper_20 upper_50 upper_90 #> 1:  car     1.45     3.25      4.6      6.4     7.75     9.55"},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate All Summary Measures — calc_summary_measures","title":"Calculate All Summary Measures — calc_summary_measures","text":"Calculate summary statistics credible intervals data frame group.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate All Summary Measures — calc_summary_measures","text":"","code":"calc_summary_measures(   samples,   summarise_by = NULL,   order_by = NULL,   CrIs = c(0.2, 0.5, 0.9) )"},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate All Summary Measures — calc_summary_measures","text":"samples data.table containing least value variable summarise_by character vector variables group . order_by character vector parameters order , defaults summarise_by variables. CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate All Summary Measures — calc_summary_measures","text":"data.table containing summary statistics group.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_measures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate All Summary Measures — calc_summary_measures","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") # default calc_summary_measures(samples) #>    type median mean      sd lower_90 lower_50 lower_20 upper_20 upper_50 #> 1:  car    5.5  5.5 3.02765     1.45     3.25      4.6      6.4     7.75 #>    upper_90 #> 1:     9.55 #  by type calc_summary_measures(samples, summarise_by = \"type\") #>    type median mean      sd lower_90 lower_50 lower_20 upper_20 upper_50 #> 1:  car    5.5  5.5 3.02765     1.45     3.25      4.6      6.4     7.75 #>    upper_90 #> 1:     9.55"},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Summary Statistics — calc_summary_stats","title":"Calculate Summary Statistics — calc_summary_stats","text":"Calculate summary statistics data frame group. Currently supports mean, median standard deviation.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Summary Statistics — calc_summary_stats","text":"","code":"calc_summary_stats(samples, summarise_by = c())"},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Summary Statistics — calc_summary_stats","text":"samples data.table containing least value variable summarise_by character vector variables group .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Summary Statistics — calc_summary_stats","text":"data.table containing upper lower bounds specified credible interval","code":""},{"path":"epiforecasts.io/EpiNow2/reference/calc_summary_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Summary Statistics — calc_summary_stats","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") # default calc_summary_stats(samples) #>    median mean      sd #> 1:    5.5  5.5 3.02765 #  by type calc_summary_stats(samples, summarise_by = \"type\") #>    type median mean      sd #> 1:  car    5.5  5.5 3.02765"},{"path":"epiforecasts.io/EpiNow2/reference/clean_nowcasts.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean Nowcasts for a Supplied Date — clean_nowcasts","title":"Clean Nowcasts for a Supplied Date — clean_nowcasts","text":"function removes nowcasts format produced EpiNow2 target directory date supplied.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_nowcasts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean Nowcasts for a Supplied Date — clean_nowcasts","text":"","code":"clean_nowcasts(date = NULL, nowcast_dir = \".\")"},{"path":"epiforecasts.io/EpiNow2/reference/clean_nowcasts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean Nowcasts for a Supplied Date — clean_nowcasts","text":"date Date object. Defaults today's date nowcast_dir Character string giving filepath nowcast results directory. Defaults current directory.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_nowcasts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean Nowcasts for a Supplied Date — clean_nowcasts","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean Regions — clean_regions","title":"Clean Regions — clean_regions","text":"Removes regions insufficient time points, provides logging information input.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean Regions — clean_regions","text":"","code":"clean_regions(reported_cases, non_zero_points)"},{"path":"epiforecasts.io/EpiNow2/reference/clean_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean Regions — clean_regions","text":"reported_cases data frame confirmed cases (confirm) date (date), region (region). non_zero_points Numeric, minimum number time points non-zero cases region required region evaluated. Defaults 7.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/clean_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean Regions — clean_regions","text":"dataframe cleaned regional data","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Output — construct_output","title":"Construct Output — construct_output","text":"Combines output produced internally epinow single list.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Output — construct_output","text":"","code":"construct_output(   estimates,   estimated_reported_cases,   plots = NULL,   summary = NULL,   samples = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Output — construct_output","text":"estimates List data frames output estimate_infections estimated_reported_cases list dataframes produced estimates_by_report_date. plots list plots produced report_plots summary list summary output produced report_summary samples Logical, defaults TRUE. samples saved","code":""},{"path":"epiforecasts.io/EpiNow2/reference/construct_output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Output — construct_output","text":"list output returned epinow","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"Convert mean standard deviation log mean lognormal distribution. Useful defining distributions supported estimate_infections, epinow, regional_epinow.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"","code":"convert_to_logmean(mean, sd)"},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"mean Numeric, mean distribution sd Numeric, standard deviation distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"log mean lognormal distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logmean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert mean and sd to log mean for a log normal distribution — convert_to_logmean","text":"","code":"convert_to_logmean(2, 1) #> [1] 0.5815754"},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"Convert mean standard deviation log standard deviation lognormal distribution. Useful defining distributions supported estimate_infections, epinow, regional_epinow.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"","code":"convert_to_logsd(mean, sd)"},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"mean Numeric, mean distribution sd Numeric, standard deviation distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"log standard deviation lognormal distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/convert_to_logsd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert mean and sd to log standard deviation for a log normal distribution — convert_to_logsd","text":"","code":"convert_to_logsd(2, 1) #> [1] 0.4723807"},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":null,"dir":"Reference","previous_headings":"","what":"Copy Results From Dated Folder to Latest — copy_results_to_latest","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"Copies output dated folder latest folder. May undergo changes later releases.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"","code":"copy_results_to_latest(target_folder = NULL, latest_folder = NULL)"},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"target_folder Character string specifying save results (create present). latest_folder Character string containing path latest target folder. produced setup_target_folder.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/copy_results_to_latest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copy Results From Dated Folder to Latest — copy_results_to_latest","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Back Calculation Data — create_backcalc_data","title":"Create Back Calculation Data — create_backcalc_data","text":"Takes output backcalc_opts() converts list understood stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Back Calculation Data — create_backcalc_data","text":"","code":"create_backcalc_data(backcalc = backcalc_opts)"},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Back Calculation Data — create_backcalc_data","text":"backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts().","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Back Calculation Data — create_backcalc_data","text":"list settings defining Gaussian process","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/create_backcalc_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Back Calculation Data — create_backcalc_data","text":"","code":"# define input data required data <- list(   t = 30,   seeding_time = 7,   horizon = 7 )  # default gaussian process data create_gp_data(data = data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $fixed #> [1] 0 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.991842 #>  #> $ls_sdlog #> [1] 0.3245928 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>   # settings when no gaussian process is desired create_gp_data(NULL, data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $stationary #> [1] 1 #>  #> $fixed #> [1] 1 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.991842 #>  #> $ls_sdlog #> [1] 0.3245928 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>   # custom lengthscale create_gp_data(gp_opts(ls_mean = 14), data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $fixed #> [1] 0 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.527486 #>  #> $ls_sdlog #> [1] 0.4723807 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Clean Reported Cases — create_clean_reported_cases","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"Cleans data frame reported cases replacing missing dates 0 cases applies optional threshold point 0 cases replaced moving average observed cases. See zero_threshold details.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"","code":"create_clean_reported_cases(   reported_cases,   horizon,   filter_leading_zeros = TRUE,   zero_threshold = Inf )"},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. horizon Numeric, defaults 7. Number days future forecast. filter_leading_zeros Logical, defaults TRUE. zeros start time series filtered . zero_threshold Numeric defaults Inf. Indicates detected zero cases meaningful using threshold number cases based 7 day average. average threshold zero replaced backwards looking rolling average. set infinity changes made.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_clean_reported_cases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Clean Reported Cases — create_clean_reported_cases","text":"cleaned data frame reported cases","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct the Required Future Rt assumption — create_future_rt","title":"Construct the Required Future Rt assumption — create_future_rt","text":"Converts future argument rt_opts() arguments can passed stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct the Required Future Rt assumption — create_future_rt","text":"","code":"create_future_rt(future = \"latest\", delay = 0)"},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct the Required Future Rt assumption — create_future_rt","text":"future character string integer. argument indicates set future Rt values. Supported options project using Rt model (\"project\"), use latest estimate based partial data (\"latest\"), use latest estimate based data 50% complete (\"estimate\"). integer supplied Rt estimate many days future (past negative) past used forwards time. delay Numeric mean delay","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_future_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct the Required Future Rt assumption — create_future_rt","text":"list containing logical called fixed integer called ","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Gaussian Process Data — create_gp_data","title":"Create Gaussian Process Data — create_gp_data","text":"Takes output gp_opts() converts list understood stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Gaussian Process Data — create_gp_data","text":"","code":"create_gp_data(gp = gp_opts(), data)"},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Gaussian Process Data — create_gp_data","text":"gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. data list containing following numeric values: t, seeding_time, horizon.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Gaussian Process Data — create_gp_data","text":"list settings defining Gaussian process","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/create_gp_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Gaussian Process Data — create_gp_data","text":"","code":"# define input data required data <- list(   t = 30,   seeding_time = 7,   horizon = 7 )  # default gaussian process data create_gp_data(data = data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $fixed #> [1] 0 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.991842 #>  #> $ls_sdlog #> [1] 0.3245928 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>   # settings when no gaussian process is desired create_gp_data(NULL, data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $stationary #> [1] 1 #>  #> $fixed #> [1] 1 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.991842 #>  #> $ls_sdlog #> [1] 0.3245928 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>   # custom lengthscale create_gp_data(gp_opts(ls_mean = 14), data) #> $t #> [1] 30 #>  #> $seeding_time #> [1] 7 #>  #> $horizon #> [1] 7 #>  #> $fixed #> [1] 0 #>  #> $M #> numeric(0) #>  #> $L #> [1] 1.5 #>  #> $ls_meanlog #> [1] 2.527486 #>  #> $ls_sdlog #> [1] 0.4723807 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 16 #>  #> $alpha_sd #> [1] 0.05 #>  #> $gp_type #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_initial_conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Initial Conditions Generating Function — create_initial_conditions","title":"Create Initial Conditions Generating Function — create_initial_conditions","text":"Uses output create_stan_data create function can used sample prior distributions (close possible) parameters. Used order initialise stan chain within range plausible values.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_initial_conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Initial Conditions Generating Function — create_initial_conditions","text":"","code":"create_initial_conditions(data)"},{"path":"epiforecasts.io/EpiNow2/reference/create_initial_conditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Initial Conditions Generating Function — create_initial_conditions","text":"data list data produced create_stan_data.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_initial_conditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Initial Conditions Generating Function — create_initial_conditions","text":"initial condition generating function","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Observation Model Settings — create_obs_model","title":"Create Observation Model Settings — create_obs_model","text":"Takes output obs_opts() converts list understood stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Observation Model Settings — create_obs_model","text":"","code":"create_obs_model(obs = obs_opts(), dates)"},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Observation Model Settings — create_obs_model","text":"obs list options generated obs_opts() defining observation model. Defaults obs_opts(). dates vector dates used calculate day week.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Observation Model Settings — create_obs_model","text":"list settings ready passed stan defining Observation Model","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/create_obs_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Observation Model Settings — create_obs_model","text":"","code":"dates <- seq(as.Date(\"2020-03-15\"), by = \"days\", length.out = 15) # default observation model data create_obs_model(dates = dates) #> $model_type #> [1] 1 #>  #> $phi_mean #> [1] 0 #>  #> $phi_sd #> [1] 1 #>  #> $week_effect #> [1] 7 #>  #> $obs_weight #> [1] 1 #>  #> $obs_scale #> [1] 0 #>  #> $likelihood #> [1] 1 #>  #> $return_likelihood #> [1] 0 #>  #> $day_of_week #>  [1] 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 #>  #> $obs_scale_mean #> [1] 0 #>  #> $obs_scale_sd #> [1] 0 #>   # Poisson observation model create_obs_model(obs_opts(family = \"poisson\"), dates = dates) #> $model_type #> [1] 0 #>  #> $phi_mean #> [1] 0 #>  #> $phi_sd #> [1] 1 #>  #> $week_effect #> [1] 7 #>  #> $obs_weight #> [1] 1 #>  #> $obs_scale #> [1] 0 #>  #> $likelihood #> [1] 1 #>  #> $return_likelihood #> [1] 0 #>  #> $day_of_week #>  [1] 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 #>  #> $obs_scale_mean #> [1] 0 #>  #> $obs_scale_sd #> [1] 0 #>   # Applying a observation scaling to the data create_obs_model(obs_opts(scale = list(mean = 0.4, sd = 0.01)), dates = dates) #> $model_type #> [1] 1 #>  #> $phi_mean #> [1] 0 #>  #> $phi_sd #> [1] 1 #>  #> $week_effect #> [1] 7 #>  #> $obs_weight #> [1] 1 #>  #> $obs_scale #> [1] 1 #>  #> $likelihood #> [1] 1 #>  #> $return_likelihood #> [1] 0 #>  #> $day_of_week #>  [1] 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 #>  #> $obs_scale_mean #> [1] 0.4 #>  #> $obs_scale_sd #> [1] 0.01 #>   # Apply a custom week week length create_obs_model(obs_opts(week_length = 3), dates = dates) #> $model_type #> [1] 1 #>  #> $phi_mean #> [1] 0 #>  #> $phi_sd #> [1] 1 #>  #> $week_effect #> [1] 3 #>  #> $obs_weight #> [1] 1 #>  #> $obs_scale #> [1] 0 #>  #> $likelihood #> [1] 1 #>  #> $return_likelihood #> [1] 0 #>  #> $day_of_week #>  [1] 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 #>  #> $obs_scale_mean #> [1] 0 #>  #> $obs_scale_sd #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Time-varying Reproduction Number Data — create_rt_data","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"Takes output rt_opts() converts list understood stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"","code":"create_rt_data(rt = rt_opts(), breakpoints = NULL, delay = 0, horizon = 0)"},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. breakpoints integer vector (binary) indicating location breakpoints. delay Numeric mean delay horizon Numeric, forecast horizon.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"list settings defining time-varying reproduction number","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/create_rt_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Time-varying Reproduction Number Data — create_rt_data","text":"","code":"# default Rt data create_rt_data() #> $r_mean #> [1] 1 #>  #> $r_sd #> [1] 1 #>  #> $estimate_r #> [1] 1 #>  #> $bp_n #> [1] 0 #>  #> $breakpoints #> NULL #>  #> $future_fixed #> [1] 1 #>  #> $fixed_from #> [1] 0 #>  #> $pop #> [1] 0 #>  #> $stationary #> [1] 0 #>  #> $future_time #> [1] 0 #>   # settings when no Rt is desired create_rt_data(rt = NULL) #> $r_mean #> [1] 1 #>  #> $r_sd #> [1] 1 #>  #> $estimate_r #> [1] 0 #>  #> $bp_n #> [1] 0 #>  #> $breakpoints #> NULL #>  #> $future_fixed #> [1] 0 #>  #> $fixed_from #> [1] 0 #>  #> $pop #> [1] 0 #>  #> $stationary #> [1] 1 #>  #> $future_time #> [1] 0 #>   # using breakpoints create_rt_data(rt_opts(use_breakpoints = TRUE), breakpoints = rep(1, 10)) #> $r_mean #> [1] 1 #>  #> $r_sd #> [1] 1 #>  #> $estimate_r #> [1] 1 #>  #> $bp_n #> [1] 10 #>  #> $breakpoints #>  [1] 1 1 1 1 1 1 1 1 1 1 #>  #> $future_fixed #> [1] 1 #>  #> $fixed_from #> [1] 0 #>  #> $pop #> [1] 0 #>  #> $stationary #> [1] 0 #>  #> $future_time #> [1] 0 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Delay Shifted Cases — create_shifted_cases","title":"Create Delay Shifted Cases — create_shifted_cases","text":"functions creates data frame reported cases smoothed using centred partial rolling average (period set smoothing_window) shifted back time delay. used estimate_infections generate mean shifted prior back calculation method (see backcalc_opts()) based.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Delay Shifted Cases — create_shifted_cases","text":"","code":"create_shifted_cases(reported_cases, shift, smoothing_window, horizon)"},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Delay Shifted Cases — create_shifted_cases","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. shift Numeric, mean delay shift apply. smoothing_window Numeric, rolling average smoothing window apply. Must odd order defined centred average. horizon Numeric, defaults 7. Number days future forecast.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Delay Shifted Cases — create_shifted_cases","text":"data frame shifted reported cases","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_shifted_cases.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Delay Shifted Cases — create_shifted_cases","text":"","code":"create_shifted_cases(example_confirmed, 7, 14, 7) #>            date confirm #>   1: 2020-03-07    3028 #>   2: 2020-03-08    3407 #>   3: 2020-03-09    3698 #>   4: 2020-03-10    3912 #>   5: 2020-03-11    4217 #>  ---                    #> 112: 2020-06-26     224 #> 113: 2020-06-27     222 #> 114: 2020-06-28     219 #> 115: 2020-06-29     217 #> 116: 2020-06-30     215"},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a List of Stan Arguments — create_stan_args","title":"Create a List of Stan Arguments — create_stan_args","text":"Generates list arguments required rstan::sampling rstan::vb combining required options, data, type initialisation. Initialisation defaults random expected create_initial_conditions used.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a List of Stan Arguments — create_stan_args","text":"","code":"create_stan_args(   stan = stan_opts(),   data = NULL,   init = \"random\",   verbose = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a List of Stan Arguments — create_stan_args","text":"stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. data list stan data created create_stan_data init Initial conditions passed rstan. Defaults \"random\" can also function ( supplied create_intitial_conditions). verbose Logical, defaults FALSE. verbose progress messages returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a List of Stan Arguments — create_stan_args","text":"list stan arguments","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a List of Stan Arguments — create_stan_args","text":"","code":"# default settings create_stan_args() #> $data #> NULL #>  #> $init #> [1] \"random\" #>  #> $refresh #> [1] 0 #>  #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // discretised truncated gamma pmf #> vector discretised_gamma_pmf(real mu, real sigma, int max_val) { #>   int n = max_val; #>   vector[n+1] upper_cdf; #>   vector[n] pmf; #>   // calculate alpha and beta for gamma distribution #>   real small = 1e-5; #>   real large = 1e8; #>   real c_sigma = fmax(small, sigma); #>   real c_mu = fmax(small, mu); #>   real alpha = ((c_mu) / c_sigma)^2; #>   real beta = (c_mu) / (c_sigma^2); #>   // account for numerical issues #>   alpha = fmax(small, alpha); #>   alpha = fmin(large, alpha); #>   beta = fmax(small, beta); #>   beta = fmin(large, beta); #>   // calculate pmf #>   for (i in 1:(n+1)) { #>     upper_cdf[i] = gamma_cdf(i,  alpha, beta); #>   } #>   // discretise #>   for (i in 1:n) { #>     pmf[n+1-i] = upper_cdf[i+1] - upper_cdf[i]; #>   } #>   pmf = pmf / (upper_cdf[n+1] - upper_cdf[1]); #>   return(pmf); #> } #>  #> // discretised truncated lognormal pmf #> vector discretised_lognormal_pmf(real mu, real sigma, int max_val, int rev) { #>   int n = max_val; #>   vector[n] upper_cdf; #>   vector[n] pmf; #>   for (i in 1:n) { #>     upper_cdf[i] = lognormal_cdf(i,  mu, sigma); #>   } #>   // discretise #>   if (rev) { #>     pmf[n] = upper_cdf[1]; #>     for (i in 2:n) { #>       pmf[n+1-i] = upper_cdf[i] - upper_cdf[i-1]; #>     } #>   }else{ #>     pmf[1] = upper_cdf[1]; #>     pmf[2:n] = upper_cdf[2:n] - upper_cdf[1:(n-1)]; #>   } #>   // normalize #>   pmf = pmf / upper_cdf[n]; #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // discretised truncated gamma pmf #> vector discretised_delta_pmf(int n) { #>   vector[n] pmf = rep_vector(0, n); #>   pmf[n] = 1; #>   return(pmf); #> } #>  #> // convolve a pdf and case vector #> vector convolve(vector cases, vector rev_pmf) { #>     int t = num_elements(cases); #>     int max_pmf = num_elements(rev_pmf); #>     vector[t] conv_cases = rep_vector(1e-5, t); #>     for (s in 1:t) { #>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s], #>                                      tail(rev_pmf, min(max_pmf, s))); #>     } #>    return(conv_cases); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           real[] delay_mean, #>                           real[] delay_sd, #>                           int[] max_delay, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_mean); #>   if (delays) { #>     for (s in 1:delays) { #>       vector[max_delay[s]] pmf; #>       pmf = discretised_lognormal_pmf( #>         delay_mean[s], delay_sd[s], max_delay[s], 1 #>       ); #>       unobs_reports = convolve(unobs_reports, pmf); #>     } #>     reports = unobs_reports[(seeding_time + 1):t]; #>   }else{ #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){ #>     int delays = num_elements(delay_mean); #>     if (delays) { #>       for (s in 1:delays) { #>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_pmf, #>                            int seeding_time, int max_gt, int index){ #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - max_gt)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(max_gt, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed)); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, #>                            real gt_mean, real gt_sd, int max_gt, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // generation time pmf #>   vector[max_gt] gt_pmf; #>   if (gt_sd > 0) { #>     // SD > 0: use discretised gamma #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     // SD == 0: use discretised delta #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #> // Update the log density for the generation time distribution mean and sd #> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, #>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) { #>   if (gt_mean_sd > 0) { #>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight; #>   } #>   if (gt_sd_sd > 0) { #>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight; #>   } #> } #>  #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Calculate a truncation CMF #> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) { #>     int  trunc_indexes[trunc_max]; #>     vector[trunc_max] cmf; #>     cmf = discretised_lognormal_pmf(trunc_mean, trunc_sd, trunc_max, 0); #>     cmf[1] = cmf[1] + 1e-8; #>     cmf = cumulative_sum(cmf); #>     cmf = reverse_mf(cmf); #>     return(cmf); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, real truncation_mean, real truncation_sd, #>                 int truncation_max, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = truncation_max > t ? t : truncation_max; #>   vector[trunc_max] cmf; #>   int first_t = t - trunc_max + 1; #>   cmf = truncation_cmf(truncation_mean, truncation_sd, trunc_max); #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     real gt_mean, real gt_sd, int max_gt, #>                     int smooth) { #>   vector[max_gt] gt_pmf; #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate PMF of the generation time #>   if (gt_sd > 0) { #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   gt_pmf = reverse_mf(gt_pmf); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_pmf, seeding_time, max_gt, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int max_delay[delays];       // maximum incubation period #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd;                   // prior sd of mean generation time #>   real gt_mean_mean;                 // prior mean of mean generation time #>   real gt_sd_mean;                   // prior mean of sd of generation time #>   real gt_sd_sd;                     // prior sd of sd of generation time #>   int max_gt;                        // maximum generation time #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int max_truncation[truncation];    // maximum truncation supported #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<lower = 0, upper = max_gt> gt_mean[estimate_r && gt_mean_sd > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[delays];                 // mean of delays #>   real<lower = 0> delay_sd[delays];        // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real truncation_mean[truncation];        // mean of truncation #>   real<lower = 0> truncation_sd[truncation]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     R = update_Rt(ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary); #>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt, #>                                      initial_infections, initial_growth, #>                                      pop, future_time); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior); #>   } #>   // convolve from latent infections to mean of observations #>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time); #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    obs_reports = truncate( #>     reports[1:ot], truncation_mean[1], truncation_sd[1], max_truncation[1], 0 #>   ); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, #>     delay_sd_sd, t #>   ); #>   // priors for truncation #>   truncation_lp( #>     truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd,  #>     trunc_sd_mean, trunc_sd_sd #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     generation_time_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   }else{ #>     // sample generation time #>     real gt_mean_sample = (gt_mean_sd > 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean); #>     real gt_sd_sample = (gt_sd_sd > 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean); #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_mean_sample, gt_sd_sample, max_gt, #>       rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"sampling\" #>  #> $cores #> [1] 1 #>  #> $warmup #> [1] 250 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 65455235 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 750 #>   # increasing warmup create_stan_args(stan = stan_opts(warmup = 1000)) #> $data #> NULL #>  #> $init #> [1] \"random\" #>  #> $refresh #> [1] 0 #>  #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // discretised truncated gamma pmf #> vector discretised_gamma_pmf(real mu, real sigma, int max_val) { #>   int n = max_val; #>   vector[n+1] upper_cdf; #>   vector[n] pmf; #>   // calculate alpha and beta for gamma distribution #>   real small = 1e-5; #>   real large = 1e8; #>   real c_sigma = fmax(small, sigma); #>   real c_mu = fmax(small, mu); #>   real alpha = ((c_mu) / c_sigma)^2; #>   real beta = (c_mu) / (c_sigma^2); #>   // account for numerical issues #>   alpha = fmax(small, alpha); #>   alpha = fmin(large, alpha); #>   beta = fmax(small, beta); #>   beta = fmin(large, beta); #>   // calculate pmf #>   for (i in 1:(n+1)) { #>     upper_cdf[i] = gamma_cdf(i,  alpha, beta); #>   } #>   // discretise #>   for (i in 1:n) { #>     pmf[n+1-i] = upper_cdf[i+1] - upper_cdf[i]; #>   } #>   pmf = pmf / (upper_cdf[n+1] - upper_cdf[1]); #>   return(pmf); #> } #>  #> // discretised truncated lognormal pmf #> vector discretised_lognormal_pmf(real mu, real sigma, int max_val, int rev) { #>   int n = max_val; #>   vector[n] upper_cdf; #>   vector[n] pmf; #>   for (i in 1:n) { #>     upper_cdf[i] = lognormal_cdf(i,  mu, sigma); #>   } #>   // discretise #>   if (rev) { #>     pmf[n] = upper_cdf[1]; #>     for (i in 2:n) { #>       pmf[n+1-i] = upper_cdf[i] - upper_cdf[i-1]; #>     } #>   }else{ #>     pmf[1] = upper_cdf[1]; #>     pmf[2:n] = upper_cdf[2:n] - upper_cdf[1:(n-1)]; #>   } #>   // normalize #>   pmf = pmf / upper_cdf[n]; #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // discretised truncated gamma pmf #> vector discretised_delta_pmf(int n) { #>   vector[n] pmf = rep_vector(0, n); #>   pmf[n] = 1; #>   return(pmf); #> } #>  #> // convolve a pdf and case vector #> vector convolve(vector cases, vector rev_pmf) { #>     int t = num_elements(cases); #>     int max_pmf = num_elements(rev_pmf); #>     vector[t] conv_cases = rep_vector(1e-5, t); #>     for (s in 1:t) { #>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s], #>                                      tail(rev_pmf, min(max_pmf, s))); #>     } #>    return(conv_cases); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           real[] delay_mean, #>                           real[] delay_sd, #>                           int[] max_delay, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_mean); #>   if (delays) { #>     for (s in 1:delays) { #>       vector[max_delay[s]] pmf; #>       pmf = discretised_lognormal_pmf( #>         delay_mean[s], delay_sd[s], max_delay[s], 1 #>       ); #>       unobs_reports = convolve(unobs_reports, pmf); #>     } #>     reports = unobs_reports[(seeding_time + 1):t]; #>   }else{ #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){ #>     int delays = num_elements(delay_mean); #>     if (delays) { #>       for (s in 1:delays) { #>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_pmf, #>                            int seeding_time, int max_gt, int index){ #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - max_gt)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(max_gt, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed)); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, #>                            real gt_mean, real gt_sd, int max_gt, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // generation time pmf #>   vector[max_gt] gt_pmf; #>   if (gt_sd > 0) { #>     // SD > 0: use discretised gamma #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     // SD == 0: use discretised delta #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #> // Update the log density for the generation time distribution mean and sd #> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, #>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) { #>   if (gt_mean_sd > 0) { #>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight; #>   } #>   if (gt_sd_sd > 0) { #>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight; #>   } #> } #>  #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Calculate a truncation CMF #> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) { #>     int  trunc_indexes[trunc_max]; #>     vector[trunc_max] cmf; #>     cmf = discretised_lognormal_pmf(trunc_mean, trunc_sd, trunc_max, 0); #>     cmf[1] = cmf[1] + 1e-8; #>     cmf = cumulative_sum(cmf); #>     cmf = reverse_mf(cmf); #>     return(cmf); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, real truncation_mean, real truncation_sd, #>                 int truncation_max, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = truncation_max > t ? t : truncation_max; #>   vector[trunc_max] cmf; #>   int first_t = t - trunc_max + 1; #>   cmf = truncation_cmf(truncation_mean, truncation_sd, trunc_max); #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     real gt_mean, real gt_sd, int max_gt, #>                     int smooth) { #>   vector[max_gt] gt_pmf; #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate PMF of the generation time #>   if (gt_sd > 0) { #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   gt_pmf = reverse_mf(gt_pmf); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_pmf, seeding_time, max_gt, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int max_delay[delays];       // maximum incubation period #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd;                   // prior sd of mean generation time #>   real gt_mean_mean;                 // prior mean of mean generation time #>   real gt_sd_mean;                   // prior mean of sd of generation time #>   real gt_sd_sd;                     // prior sd of sd of generation time #>   int max_gt;                        // maximum generation time #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int max_truncation[truncation];    // maximum truncation supported #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<lower = 0, upper = max_gt> gt_mean[estimate_r && gt_mean_sd > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[delays];                 // mean of delays #>   real<lower = 0> delay_sd[delays];        // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real truncation_mean[truncation];        // mean of truncation #>   real<lower = 0> truncation_sd[truncation]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     R = update_Rt(ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary); #>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt, #>                                      initial_infections, initial_growth, #>                                      pop, future_time); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior); #>   } #>   // convolve from latent infections to mean of observations #>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time); #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    obs_reports = truncate( #>     reports[1:ot], truncation_mean[1], truncation_sd[1], max_truncation[1], 0 #>   ); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, #>     delay_sd_sd, t #>   ); #>   // priors for truncation #>   truncation_lp( #>     truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd,  #>     trunc_sd_mean, trunc_sd_sd #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     generation_time_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   }else{ #>     // sample generation time #>     real gt_mean_sample = (gt_mean_sd > 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean); #>     real gt_sd_sample = (gt_sd_sd > 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean); #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_mean_sample, gt_sd_sample, max_gt, #>       rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"sampling\" #>  #> $cores #> [1] 1 #>  #> $warmup #> [1] 1000 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 95170847 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 1500 #>"},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Stan Data Required for estimate_infections — create_stan_data","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"Takes output stan_opts() converts list understood stan. Internally calls create_ family functions construct single list input stan data required present.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"","code":"create_stan_data(   reported_cases,   generation_time,   rt,   gp,   obs,   delays,   horizon,   backcalc,   shifted_cases,   truncation )"},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. generation_time list containing mean, standard deviation mean (mean_sd), standard deviation (sd), standard deviation standard deviation maximum allowed value generation time (assuming gamma distribution). rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. horizon Numeric, forecast horizon. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). shifted_cases dataframe delay shifted cases truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/create_stan_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Stan Data Required for estimate_infections — create_stan_data","text":"list stan data","code":""},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Delay Distribution Options — delay_opts","title":"Delay Distribution Options — delay_opts","text":"Returns delay distributions formatted usage downstream functions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delay Distribution Options — delay_opts","text":"","code":"delay_opts(...)"},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delay Distribution Options — delay_opts","text":"... Delay distributions list following parameters: \"mean\", \"mean_sd\", \"sd_mean\", \"sd_sd\", \"max\" defining truncated log normal (parameters except max defined logged form).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delay Distribution Options — delay_opts","text":"list summarising input delay distributions.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/delay_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delay Distribution Options — delay_opts","text":"","code":"# no delays delay_opts() #> $delays #> [1] 0 #>  #> $seeding_time #> [1] 1 #>  #> $delay_mean_mean #> numeric(0) #>  #> $delay_mean_sd #> numeric(0) #>  #> $delay_sd_mean #> numeric(0) #>  #> $delay_sd_sd #> numeric(0) #>  #> $max_delay #> numeric(0) #>"},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"Fits integer adjusted exponential, gamma lognormal distribution using stan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"","code":"dist_fit(   values = NULL,   samples = NULL,   cores = 1,   chains = 2,   dist = \"exp\",   verbose = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"values Numeric vector values samples Numeric, number samples take cores Numeric, defaults 1. Number CPU cores use (effect greater number chains). chains Numeric, defaults 2. Number MCMC chains use. better minimum two. dist Character string, distribution fit. Defaults exponential (\"exp\") gamma (\"gamma\") lognormal (\"lognormal\") also supported. verbose Logical, defaults FALSE. verbose progress messages printed.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"stan fit interval censored distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an Integer Adjusted Exponential, Gamma or Lognormal distributions — dist_fit","text":"","code":"# \\donttest{ # integer adjusted exponential model dist_fit(rexp(1:100, 2),   samples = 1000, dist = \"exp\",   cores = ifelse(interactive(), 4, 1), verbose = TRUE ) #>  #> SAMPLING FOR MODEL 'exp' NOW (CHAIN 1). #> Chain 1: Rejecting initial value: #> Chain 1:   Log probability evaluates to log(0), i.e. negative infinity. #> Chain 1:   Stan can't start sampling from this initial value. #> Chain 1:  #> Chain 1: Gradient evaluation took 2.6e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.26 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 1: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 1: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 1: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 1: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 1: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 1: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 1: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 1: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 1: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 1: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 1: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 1: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 1: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 1: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 1: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 1: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 1: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 1: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.069361 seconds (Warm-up) #> Chain 1:                0.073902 seconds (Sampling) #> Chain 1:                0.143263 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'exp' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 2.3e-05 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.23 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 2: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 2: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 2: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 2: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 2: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 2: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 2: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 2: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 2: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 2: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 2: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 2: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 2: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 2: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 2: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 2: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 2: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 2: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 0.071308 seconds (Warm-up) #> Chain 2:                0.060663 seconds (Sampling) #> Chain 2:                0.131971 seconds (Total) #> Chain 2:  #> Inference for Stan model: exp. #> 2 chains, each with iter=2000; warmup=1000; thin=1;  #> post-warmup draws per chain=1000, total post-warmup draws=2000. #>  #>          mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat #> lambda   2.48    0.01 0.38   1.83   2.20   2.44   2.72   3.29   755    1 #> lp__   -17.67    0.02 0.67 -19.53 -17.85 -17.42 -17.23 -17.18   785    1 #>  #> Samples were drawn using NUTS(diag_e) at Wed Jan 18 01:28:56 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1).   # integer adjusted gamma model dist_fit(rgamma(1:100, 5, 5),   samples = 1000, dist = \"gamma\",   cores = ifelse(interactive(), 4, 1), verbose = TRUE ) #>  #> SAMPLING FOR MODEL 'gamma' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000205 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 2.05 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 1: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 1: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 1: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 1: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 1: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 1: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 1: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 1: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 1: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 1: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 1: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 1: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 1: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 1: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 1: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 1: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 1: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 1: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 1.71273 seconds (Warm-up) #> Chain 1:                2.07997 seconds (Sampling) #> Chain 1:                3.7927 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'gamma' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 0.000195 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 1.95 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 2: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 2: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 2: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 2: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 2: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 2: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 2: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 2: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 2: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 2: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 2: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 2: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 2: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 2: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 2: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 2: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 2: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 2: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 1.74208 seconds (Warm-up) #> Chain 2:                1.95416 seconds (Sampling) #> Chain 2:                3.69624 seconds (Total) #> Chain 2:  #> Inference for Stan model: gamma. #> 2 chains, each with iter=2000; warmup=1000; thin=1;  #> post-warmup draws per chain=1000, total post-warmup draws=2000. #>  #>             mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat #> alpha_raw   0.84    0.03 0.53   0.04   0.43   0.77   1.19   2.02   258 1.01 #> beta_raw    0.93    0.03 0.54   0.09   0.52   0.88   1.28   2.12   405 1.00 #> alpha       6.09    0.03 0.53   5.29   5.68   6.02   6.44   7.27   258 1.01 #> beta        6.08    0.03 0.54   5.24   5.67   6.03   6.44   7.27   405 1.00 #> mu          1.01    0.00 0.07   0.86   0.95   1.00   1.06   1.16   856 1.00 #> sigma       0.41    0.00 0.03   0.36   0.39   0.41   0.43   0.46   596 1.00 #> lp__      -15.03    0.11 1.56 -19.33 -15.64 -14.56 -13.91 -13.48   218 1.00 #>  #> Samples were drawn using NUTS(diag_e) at Wed Jan 18 01:29:04 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1).  # integer adjusted lognormal model dist_fit(rlnorm(1:100, log(5), 0.2),   samples = 1000, dist = \"lognormal\",   cores = ifelse(interactive(), 4, 1), verbose = TRUE ) #>  #> SAMPLING FOR MODEL 'lnorm' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 3.5e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.35 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 1: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 1: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 1: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 1: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 1: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 1: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 1: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 1: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 1: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 1: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 1: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 1: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 1: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 1: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 1: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 1: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 1: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 1: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.150952 seconds (Warm-up) #> Chain 1:                0.144868 seconds (Sampling) #> Chain 1:                0.29582 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'lnorm' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 2.9e-05 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.29 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:   50 / 2000 [  2%]  (Warmup) #> Chain 2: Iteration:  100 / 2000 [  5%]  (Warmup) #> Chain 2: Iteration:  150 / 2000 [  7%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  250 / 2000 [ 12%]  (Warmup) #> Chain 2: Iteration:  300 / 2000 [ 15%]  (Warmup) #> Chain 2: Iteration:  350 / 2000 [ 17%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  450 / 2000 [ 22%]  (Warmup) #> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup) #> Chain 2: Iteration:  550 / 2000 [ 27%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  650 / 2000 [ 32%]  (Warmup) #> Chain 2: Iteration:  700 / 2000 [ 35%]  (Warmup) #> Chain 2: Iteration:  750 / 2000 [ 37%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration:  850 / 2000 [ 42%]  (Warmup) #> Chain 2: Iteration:  900 / 2000 [ 45%]  (Warmup) #> Chain 2: Iteration:  950 / 2000 [ 47%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1050 / 2000 [ 52%]  (Sampling) #> Chain 2: Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Chain 2: Iteration: 1150 / 2000 [ 57%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1250 / 2000 [ 62%]  (Sampling) #> Chain 2: Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Chain 2: Iteration: 1350 / 2000 [ 67%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1450 / 2000 [ 72%]  (Sampling) #> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Chain 2: Iteration: 1550 / 2000 [ 77%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1650 / 2000 [ 82%]  (Sampling) #> Chain 2: Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Chain 2: Iteration: 1750 / 2000 [ 87%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 1850 / 2000 [ 92%]  (Sampling) #> Chain 2: Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Chain 2: Iteration: 1950 / 2000 [ 97%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 0.138014 seconds (Warm-up) #> Chain 2:                0.127151 seconds (Sampling) #> Chain 2:                0.265165 seconds (Total) #> Chain 2:  #> Inference for Stan model: lnorm. #> 2 chains, each with iter=2000; warmup=1000; thin=1;  #> post-warmup draws per chain=1000, total post-warmup draws=2000. #>  #>         mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat #> mu      1.58    0.00 0.02   1.54   1.57   1.59   1.60   1.62  1229    1 #> sigma   0.15    0.00 0.02   0.12   0.14   0.15   0.16   0.18  1267    1 #> lp__  -64.26    0.04 1.01 -66.94 -64.63 -63.96 -63.55 -63.29   823    1 #>  #> Samples were drawn using NUTS(diag_e) at Wed Jan 18 01:29:05 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1). # }"},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":null,"dir":"Reference","previous_headings":"","what":"Distribution Skeleton — dist_skel","title":"Distribution Skeleton — dist_skel","text":"function acts skeleton truncated distribution defined model type, maximum value model parameters. designed used output get_dist.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distribution Skeleton — dist_skel","text":"","code":"dist_skel(n, dist = FALSE, cum = TRUE, model, params, max_value = 120)"},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distribution Skeleton — dist_skel","text":"n Numeric vector, number samples take (days probability density). dist Logical, defaults FALSE. probability density returned rather number samples. cum Logical, defaults TRUE. dist = TRUE returned distribution cumulative. model Character string, defining model used. Supported options exponential (\"exp\"), gamma (\"gamma\"), log normal (\"lognorm\") params list parameters values (name) required model. exponential model rate parameter gamma model alpha beta. max_value Numeric, maximum value allow. Defaults 120. Samples outside range resampled.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distribution Skeleton — dist_skel","text":"vector samples probability distribution.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/dist_skel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distribution Skeleton — dist_skel","text":"","code":"## Exponential model # sample dist_skel(10, model = \"exp\", params = list(rate = 1)) #>  [1] 2 0 0 2 0 2 0 1 0 1  # cumulative prob density dist_skel(1:10, model = \"exp\", dist = TRUE, params = list(rate = 1)) #>  [1] 0.6321206 0.8646647 0.9502129 0.9816844 0.9932621 0.9975212 0.9990881 #>  [8] 0.9996645 0.9998766 0.9999546  # probability density dist_skel(1:10,   model = \"exp\", dist = TRUE,   cum = FALSE, params = list(rate = 1) ) #>  [1] 2.325442e-01 8.554821e-02 3.147143e-02 1.157769e-02 4.259195e-03 #>  [6] 1.566870e-03 5.764193e-04 2.120528e-04 7.800987e-05 2.869823e-05  ## Gamma model # sample dist_skel(10, model = \"gamma\", params = list(alpha = 1, beta = 2)) #>  [1] 2 0 0 0 0 1 0 0 0 0  # cumulative prob density dist_skel(0:10,   model = \"gamma\", dist = TRUE,   params = list(alpha = 1, beta = 2) ) #>  [1] 0.0000000 0.8646647 0.9816844 0.9975212 0.9996645 0.9999546 0.9999939 #>  [8] 0.9999992 0.9999999 1.0000000 1.0000000  # probability density dist_skel(0:10,   model = \"gamma\", dist = TRUE,   cum = FALSE, params = list(alpha = 2, beta = 2) ) #>  [1] 5.939942e-01 3.144277e-01 7.422693e-02 1.433210e-02 2.519764e-03 #>  [6] 4.195245e-04 6.740183e-05 1.055983e-05 1.623728e-06 2.460854e-07 #> [11] 3.686845e-08  ## Log normal model # sample dist_skel(10, model = \"lognorm\", params = list(mean = log(5), sd = log(2))) #>  [1]  1  6 12  6  1  4  8  7  3  2  # cumulative prob density dist_skel(0:10,   model = \"lognorm\", dist = TRUE,   params = list(mean = log(5), sd = log(2)) ) #>  [1] 0.00000000 0.01011843 0.09309626 0.23057216 0.37375443 0.50000114 #>  [7] 0.60373934 0.68631476 0.75113865 0.80178197 0.84134666  # probability density dist_skel(0:10,   model = \"lognorm\", dist = TRUE, cum = FALSE,   params = list(mean = log(5), sd = log(2)) ) #>  [1] 0.01011843 0.08297783 0.13747590 0.14318227 0.12624670 0.10373821 #>  [7] 0.08257541 0.06482390 0.05064332 0.03956468 0.03099140"},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":null,"dir":"Reference","previous_headings":"","what":"Real-time Rt Estimation, Forecasting and Reporting — epinow","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"function wraps functionality estimate_infections() forecast_infections() order estimate Rt cases date infection, forecast infections future. also contains additional functionality convert forecasts date report produce summary output useful reporting results interpreting . See example using epinow estimate Rt Covid-19 country ECDC data source.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"","code":"epinow(   reported_cases,   generation_time = NULL,   delays = delay_opts(),   truncation = trunc_opts(),   rt = rt_opts(),   backcalc = backcalc_opts(),   gp = gp_opts(),   obs = obs_opts(),   stan = stan_opts(),   horizon = 7,   CrIs = c(0.2, 0.5, 0.9),   filter_leading_zeros = TRUE,   zero_threshold = Inf,   return_output = FALSE,   output = c(\"samples\", \"plots\", \"latest\", \"fit\", \"timing\"),   plot_args = list(),   target_folder = NULL,   target_date,   logs = tempdir(),   id = \"epinow\",   verbose = interactive() )"},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. generation_time list containing mean, standard deviation mean (mean_sd), standard deviation (sd), standard deviation standard deviation maximum allowed value generation time (assuming gamma distribution). delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. horizon Numeric, defaults 7. Number days future forecast. CrIs Numeric vector credible intervals calculate. filter_leading_zeros Logical, defaults TRUE. zeros start time series filtered . zero_threshold Numeric defaults Inf. Indicates detected zero cases meaningful using threshold number cases based 7 day average. average threshold zero replaced backwards looking rolling average. set infinity changes made. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. output character vector optional output return. Supported options samples (\"samples\"), plots (\"plots\"), run time (\"timing\"), copying dated folder latest folder (target_folder null, set using \"latest\"), stan fit (\"fit\"). default return options. argument uses partial matching example passing \"sam\" lead samples reported. plot_args list optional arguments passed plot.epinow(). target_folder Character string specifying save results (create present). target_date Date, defaults maximum found data specified. logs Character path indicating target folder store log information. Defaults temporary directory specified. Default logging can disabled logs set NULL. specifying custom logging setup code setup_default_logging setup_logging function sensible place start. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching. verbose Logical, defaults TRUE used interactively otherwise FALSE. verbose debug progress messages printed. Corresponds \"DEBUG\" level futile.logger. See setup_logging detailed logging options.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"list output estimate_infections, forecast_infections,  report_cases, report_summary.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/epinow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Real-time Rt Estimation, Forecasting and Reporting — epinow","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1)) # construct example distributions generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1),   mean_sd = 0.1,   sd = convert_to_logsd(2, 1),   sd_sd = 0.1,   max = 10 )  # example case data reported_cases <- example_confirmed[1:40]  # estimate Rt and nowcast/forecast cases by date of infection out <- epinow(   reported_cases = reported_cases, generation_time = generation_time,   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   delays = delay_opts(incubation_period, reporting_delay) ) #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpjXBiR6/regional-epinow/2020-04-01.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to the console and: /tmp/RtmpjXBiR6/epinow/2020-04-01.log #> WARN [2023-01-18 01:31:03] epinow: There were 5 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. -  #> WARN [2023-01-18 01:31:03] epinow: Examine the pairs() plot to diagnose sampling problems #>  -  # summary of the latest estimates summary(out) #>                                  measure                estimate #> 1: New confirmed cases by infection date     3224 (1495 -- 6554) #> 2:        Expected change in daily cases       Likely decreasing #> 3:            Effective reproduction no.      0.78 (0.51 -- 1.1) #> 4:                        Rate of growth -0.063 (-0.15 -- 0.024) #> 5:          Doubling/halving time (days)        -11 (29 -- -4.8) # plot estimates plot(out)   # summary of R estimates summary(out, type = \"parameters\", params = \"R\") #>           date variable strat                           type    median #>  1: 2020-03-01        R  <NA>                       estimate 2.0049191 #>  2: 2020-03-02        R  <NA>                       estimate 1.9615941 #>  3: 2020-03-03        R  <NA>                       estimate 1.9160126 #>  4: 2020-03-04        R  <NA>                       estimate 1.8674178 #>  5: 2020-03-05        R  <NA>                       estimate 1.8164752 #>  6: 2020-03-06        R  <NA>                       estimate 1.7645630 #>  7: 2020-03-07        R  <NA>                       estimate 1.7115746 #>  8: 2020-03-08        R  <NA>                       estimate 1.6582478 #>  9: 2020-03-09        R  <NA>                       estimate 1.6036229 #> 10: 2020-03-10        R  <NA>                       estimate 1.5506200 #> 11: 2020-03-11        R  <NA>                       estimate 1.4951902 #> 12: 2020-03-12        R  <NA>                       estimate 1.4426090 #> 13: 2020-03-13        R  <NA>                       estimate 1.3897717 #> 14: 2020-03-14        R  <NA>                       estimate 1.3392644 #> 15: 2020-03-15        R  <NA>                       estimate 1.2891307 #> 16: 2020-03-16        R  <NA>                       estimate 1.2410140 #> 17: 2020-03-17        R  <NA>                       estimate 1.1947533 #> 18: 2020-03-18        R  <NA> estimate based on partial data 1.1507868 #> 19: 2020-03-19        R  <NA> estimate based on partial data 1.1086448 #> 20: 2020-03-20        R  <NA> estimate based on partial data 1.0692912 #> 21: 2020-03-21        R  <NA> estimate based on partial data 1.0316723 #> 22: 2020-03-22        R  <NA> estimate based on partial data 0.9966429 #> 23: 2020-03-23        R  <NA> estimate based on partial data 0.9643401 #> 24: 2020-03-24        R  <NA> estimate based on partial data 0.9340168 #> 25: 2020-03-25        R  <NA> estimate based on partial data 0.9055139 #> 26: 2020-03-26        R  <NA> estimate based on partial data 0.8808687 #> 27: 2020-03-27        R  <NA> estimate based on partial data 0.8573704 #> 28: 2020-03-28        R  <NA> estimate based on partial data 0.8374011 #> 29: 2020-03-29        R  <NA> estimate based on partial data 0.8182820 #> 30: 2020-03-30        R  <NA> estimate based on partial data 0.8020627 #> 31: 2020-03-31        R  <NA> estimate based on partial data 0.7889042 #> 32: 2020-04-01        R  <NA> estimate based on partial data 0.7790587 #> 33: 2020-04-02        R  <NA>                       forecast 0.7790587 #> 34: 2020-04-03        R  <NA>                       forecast 0.7790587 #> 35: 2020-04-04        R  <NA>                       forecast 0.7790587 #> 36: 2020-04-05        R  <NA>                       forecast 0.7790587 #> 37: 2020-04-06        R  <NA>                       forecast 0.7790587 #> 38: 2020-04-07        R  <NA>                       forecast 0.7790587 #> 39: 2020-04-08        R  <NA>                       forecast 0.7790587 #>           date variable strat                           type    median #>          mean         sd  lower_90  lower_50  lower_20  upper_20  upper_50 #>  1: 2.0071839 0.08993836 1.8612169 1.9446407 1.9849550 2.0264717 2.0651184 #>  2: 1.9636138 0.07580933 1.8376223 1.9145667 1.9434896 1.9804004 2.0121062 #>  3: 1.9172030 0.06705131 1.8038362 1.8736981 1.9002286 1.9317495 1.9612636 #>  4: 1.8683987 0.06258714 1.7668927 1.8273415 1.8538895 1.8826060 1.9080070 #>  5: 1.8176582 0.06058729 1.7192736 1.7797346 1.8046286 1.8318985 1.8561229 #>  6: 1.7654387 0.05939290 1.6730275 1.7290321 1.7515618 1.7785837 1.8020201 #>  7: 1.7121855 0.05803265 1.6222711 1.6752564 1.6984300 1.7256204 1.7482461 #>  8: 1.6583193 0.05619365 1.5686174 1.6227252 1.6443521 1.6706913 1.6924427 #>  9: 1.6042253 0.05397574 1.5171084 1.5691143 1.5914025 1.6164731 1.6373928 #> 10: 1.5502471 0.05164698 1.4653350 1.5173072 1.5375276 1.5618874 1.5825165 #> 11: 1.4966858 0.04946870 1.4141924 1.4647669 1.4844077 1.5068991 1.5284203 #> 12: 1.4438046 0.04760363 1.3658325 1.4132243 1.4309716 1.4536752 1.4742165 #> 13: 1.3918374 0.04610009 1.3167583 1.3610017 1.3798758 1.4013299 1.4216121 #> 14: 1.3409982 0.04492802 1.2704438 1.3101156 1.3288160 1.3500073 1.3704794 #> 15: 1.2914875 0.04403109 1.2235070 1.2605638 1.2797070 1.2999643 1.3203649 #> 16: 1.2434964 0.04337023 1.1767236 1.2137897 1.2314607 1.2525930 1.2711161 #> 17: 1.1972068 0.04295815 1.1304499 1.1687351 1.1853116 1.2050819 1.2232437 #> 18: 1.1527898 0.04289588 1.0873026 1.1253524 1.1408881 1.1606746 1.1785983 #> 19: 1.1104040 0.04340631 1.0432963 1.0834883 1.0981176 1.1192806 1.1375737 #> 20: 1.0701948 0.04483658 1.0010034 1.0404477 1.0578775 1.0803620 1.0974226 #> 21: 1.0322929 0.04760066 0.9579105 1.0006738 1.0203024 1.0444668 1.0617612 #> 22: 0.9968145 0.05207073 0.9144684 0.9632943 0.9836322 1.0093936 1.0303347 #> 23: 0.9638604 0.05847569 0.8690305 0.9242168 0.9490720 0.9784742 1.0002065 #> 24: 0.9335164 0.06686560 0.8273740 0.8877918 0.9160066 0.9496264 0.9745413 #> 25: 0.9058520 0.07714159 0.7843977 0.8536040 0.8847923 0.9249779 0.9548963 #> 26: 0.8809180 0.08910872 0.7378667 0.8199070 0.8569037 0.9016035 0.9379320 #> 27: 0.8587425 0.10252114 0.6953730 0.7884931 0.8312963 0.8807185 0.9248874 #> 28: 0.8393248 0.11711379 0.6557618 0.7590807 0.8077928 0.8641969 0.9141568 #> 29: 0.8226295 0.13262280 0.6145980 0.7345662 0.7866103 0.8498291 0.9047179 #> 30: 0.8085803 0.14879391 0.5749023 0.7109511 0.7695794 0.8366555 0.8988184 #> 31: 0.7970563 0.16537619 0.5454733 0.6878176 0.7535943 0.8266163 0.8934175 #> 32: 0.7878895 0.18209971 0.5137768 0.6667308 0.7394034 0.8188295 0.8920505 #> 33: 0.7878895 0.18209971 0.5137768 0.6667308 0.7394034 0.8188295 0.8920505 #> 34: 0.7878895 0.18209971 0.5137768 0.6667308 0.7394034 0.8188295 0.8920505 #> 35: 0.7878895 0.18209971 0.5137768 0.6667308 0.7394034 0.8188295 0.8920505 #> 36: 0.7878895 0.18209971 0.5137768 0.6667308 0.7394034 0.8188295 0.8920505 #> 37: 0.7878895 0.18209971 0.5137768 0.6667308 0.7394034 0.8188295 0.8920505 #> 38: 0.7878895 0.18209971 0.5137768 0.6667308 0.7394034 0.8188295 0.8920505 #> 39: 0.7878895 0.18209971 0.5137768 0.6667308 0.7394034 0.8188295 0.8920505 #>          mean         sd  lower_90  lower_50  lower_20  upper_20  upper_50 #>     upper_90 #>  1: 2.156893 #>  2: 2.089711 #>  3: 2.027318 #>  4: 1.971152 #>  5: 1.915090 #>  6: 1.861842 #>  7: 1.805759 #>  8: 1.749834 #>  9: 1.693396 #> 10: 1.636312 #> 11: 1.580103 #> 12: 1.523244 #> 13: 1.468892 #> 14: 1.416919 #> 15: 1.366631 #> 16: 1.318958 #> 17: 1.269129 #> 18: 1.222700 #> 19: 1.182427 #> 20: 1.143887 #> 21: 1.111245 #> 22: 1.081610 #> 23: 1.058952 #> 24: 1.043626 #> 25: 1.033205 #> 26: 1.027711 #> 27: 1.028338 #> 28: 1.035790 #> 29: 1.045408 #> 30: 1.060718 #> 31: 1.077537 #> 32: 1.090759 #> 33: 1.090759 #> 34: 1.090759 #> 35: 1.090759 #> 36: 1.090759 #> 37: 1.090759 #> 38: 1.090759 #> 39: 1.090759 #>     upper_90  options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate a Delay Distribution — estimate_delay","title":"Estimate a Delay Distribution — estimate_delay","text":"Estimate log normal delay distribution vector integer delays. Currently function simple wrapper bootstrapped_dist_fit.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate a Delay Distribution — estimate_delay","text":"","code":"estimate_delay(delays, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate a Delay Distribution — estimate_delay","text":"delays Integer vector delays ... Arguments pass internal methods.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate a Delay Distribution — estimate_delay","text":"list summarising bootstrapped distribution","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/estimate_delay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate a Delay Distribution — estimate_delay","text":"","code":"# \\donttest{ delays <- rlnorm(500, log(5), 1) estimate_delay(delays, samples = 1000, bootstraps = 10) #> $mean #> [1] 1.402709 #>  #> $mean_sd #> [1] 0.1001665 #>  #> $sd #> [1] 1.070696 #>  #> $sd_sd #> [1] 0.06900613 #>  #> $max #> [1] 87 #>  # }"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"Uses non-parametric approach reconstruct cases date infection reported cases. uses either generative Rt model non-parametric back calculation estimate underlying latent infections maps infections observed cases via uncertain reporting delays flexible observation model. See examples function arguments th details options. default settings may sufficient use case number warmup samples (stan_args = list(warmup)) may need increased may overall number samples. Follow links provided warnings messages diagnose issues MCMC fit. recommended explore several Rt estimation approaches supported may suited users use cases. See example using estimate_infections within epinow wrapper estimate Rt Covid-19 country ECDC data source.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"","code":"estimate_infections(   reported_cases,   generation_time,   delays = delay_opts(),   truncation = trunc_opts(),   rt = rt_opts(),   backcalc = backcalc_opts(),   gp = gp_opts(),   obs = obs_opts(),   stan = stan_opts(),   horizon = 7,   CrIs = c(0.2, 0.5, 0.9),   filter_leading_zeros = TRUE,   zero_threshold = Inf,   id = \"estimate_infections\",   verbose = interactive() )"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. generation_time list containing mean, standard deviation mean (mean_sd), standard deviation (sd), standard deviation standard deviation maximum allowed value generation time (assuming gamma distribution). delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. horizon Numeric, defaults 7. Number days future forecast. CrIs Numeric vector credible intervals calculate. filter_leading_zeros Logical, defaults TRUE. zeros start time series filtered . zero_threshold Numeric defaults Inf. Indicates detected zero cases meaningful using threshold number cases based 7 day average. average threshold zero replaced backwards looking rolling average. set infinity changes made. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching. verbose Logical, defaults TRUE used interactively otherwise FALSE. verbose debug progress messages printed. Corresponds \"DEBUG\" level futile.logger. See setup_logging detailed logging options.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"list output including: posterior samples, summarised posterior samples, data used fit model, fit object .","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/estimate_infections.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Infections, the Time-Varying Reproduction Number and the Rate of\nGrowth — estimate_infections","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # get example case counts reported_cases <- example_confirmed[1:60]  # set up example generation time generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") # set delays between infection and case report incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1), mean_sd = 0.1,   sd = convert_to_logsd(2, 1), sd_sd = 0.1, max = 10 )  # default setting # here we assume that the observed data is truncated by the same delay as def <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   stan = stan_opts(control = list(adapt_delta = 0.95)) ) #> Warning: There were 5 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems # real time estimates summary(def) #>                                  measure                estimate #> 1: New confirmed cases by infection date     2174 (1110 -- 3950) #> 2:        Expected change in daily cases       Likely decreasing #> 3:            Effective reproduction no.      0.85 (0.59 -- 1.1) #> 4:                        Rate of growth -0.042 (-0.12 -- 0.036) #> 5:          Doubling/halving time (days)        -17 (19 -- -5.7) # summary plot plot(def)   # decreasing the accuracy of the approximate Gaussian to speed up computation. # These settings are an area of active research. See ?gp_opts for details. agp <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   gp = gp_opts(ls_min = 10, basis_prop = 0.1),   stan = stan_opts(control = list(adapt_delta = 0.95)) ) #> Warning: There were 12 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems summary(agp) #>                                  measure                estimate #> 1: New confirmed cases by infection date     2136 (1057 -- 3834) #> 2:        Expected change in daily cases       Likely decreasing #> 3:            Effective reproduction no.      0.84 (0.56 -- 1.1) #> 4:                        Rate of growth -0.044 (-0.13 -- 0.031) #> 5:          Doubling/halving time (days)        -16 (22 -- -5.4) plot(agp)   # Adjusting for future susceptible depletion dep <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(     prior = list(mean = 2, sd = 0.1),     pop = 1000000, future = \"latest\"   ),   gp = gp_opts(ls_min = 10, basis_prop = 0.1), horizon = 21,   stan = stan_opts(control = list(adapt_delta = 0.95)) ) #> Warning: There were 7 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems plot(dep)   # Adjusting for truncation of the most recent data # See estimate_truncation for an approach to estimating this from data trunc_dist <- list(   mean = convert_to_logmean(0.5, 0.5), mean_sd = 0.1,   sd = convert_to_logsd(0.5, 0.5), sd_sd = 0.1,   max = 3 ) trunc <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   truncation = trunc_opts(trunc_dist),   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   gp = gp_opts(ls_min = 10, basis_prop = 0.1),   stan = stan_opts(control = list(adapt_delta = 0.95)) ) #> Warning: There were 1 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems plot(trunc)   # using back calculation (combined here with under reporting) # this model is in the order of 10 ~ 100 faster than the gaussian process method # it is likely robust for retrospective Rt but less reliable for real time estimates # the width of the prior window controls the reliance on observed data and can be # optionally switched off using backcalc_opts(prior = \"none\"), see ?backcalc_opts for # other options backcalc <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = NULL, backcalc = backcalc_opts(),   obs = obs_opts(scale = list(mean = 0.4, sd = 0.05)),   horizon = 0 ) plot(backcalc)   # Rt projected into the future using the Gaussian process project_rt <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(     prior = list(mean = 2, sd = 0.1),     future = \"project\"   ) ) #> Warning: There were 4 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems plot(project_rt)   # default settings on a later snapshot of data snapshot_cases <- example_confirmed[80:130] snapshot <- estimate_infections(snapshot_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 1, sd = 0.1)) ) #> Warning: There were 55 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess plot(snapshot)   # stationary Rt assumption (likely to provide biased real-time estimates) stat <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1), gp_on = \"R0\") ) plot(stat)   # no gaussian process (i.e fixed Rt assuming no breakpoints) fixed <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   gp = NULL ) plot(fixed)   # no delays no_delay <- estimate_infections(reported_cases, generation_time = generation_time) #> Warning: There were 4 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems plot(no_delay)   # break point but otherwise static Rt bp_cases <- data.table::copy(reported_cases) bp_cases <- bp_cases[, breakpoint := ifelse(date == as.Date(\"2020-03-16\"), 1, 0)] bkp <- estimate_infections(bp_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   gp = NULL ) # break point effect summary(bkp, type = \"parameters\", params = \"breakpoints\") #>    date    variable strat type     median       mean         sd   lower_90 #> 1: <NA> breakpoints     1 <NA> -0.6308174 -0.6305196 0.02708018 -0.6765938 #>      lower_50   lower_20   upper_20   upper_50   upper_90 #> 1: -0.6476117 -0.6365681 -0.6238506 -0.6129184 -0.5865171 plot(bkp)   # weekly random walk rw <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1), rw = 7),   gp = NULL )  # random walk effects summary(rw, type = \"parameters\", params = \"breakpoints\") #>    date    variable strat type      median        mean         sd    lower_90 #> 1: <NA> breakpoints     1 <NA> -0.25904515 -0.26026102 0.06497142 -0.36744312 #> 2: <NA> breakpoints     2 <NA> -0.22418548 -0.22284919 0.08150588 -0.34997371 #> 3: <NA> breakpoints     3 <NA> -0.28270228 -0.28305679 0.09240665 -0.43832272 #> 4: <NA> breakpoints     4 <NA> -0.02053600 -0.02114853 0.09264538 -0.17297965 #> 5: <NA> breakpoints     5 <NA>  0.04683493  0.04682188 0.09051309 -0.09833196 #> 6: <NA> breakpoints     6 <NA> -0.08396259 -0.08603127 0.11201164 -0.27237067 #> 7: <NA> breakpoints     7 <NA> -0.01644382 -0.01820561 0.18819212 -0.33851969 #>       lower_50    lower_20     upper_20    upper_50    upper_90 #> 1: -0.30412262 -0.27637254 -0.242220735 -0.21545384 -0.15283832 #> 2: -0.27761942 -0.24554441 -0.204251121 -0.17187776 -0.08096799 #> 3: -0.34031280 -0.30066619 -0.261425322 -0.22249953 -0.13450095 #> 4: -0.08474906 -0.04445618  0.001379891  0.03970846  0.13234937 #> 5: -0.01649523  0.02452051  0.066283967  0.10378182  0.20294337 #> 6: -0.15768244 -0.11350203 -0.056337246 -0.01195893  0.09301864 #> 7: -0.13442946 -0.06416921  0.032775672  0.10162171  0.28714819 plot(rw)   options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"Estimates relationship primary secondary observation, example hospital admissions deaths hospital admissions bed occupancy. See secondary_opts() model structure options. See parameter documentation model defaults options. See examples case studies using synthetic data example forecasting Covid-19 deaths Covid-19 cases. See prototype function may used estimate forecast secondary observation primary across multiple regions application forecasting Covid-19 deaths Germany Poland.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"","code":"estimate_secondary(   reports,   secondary = secondary_opts(),   delays = delay_opts(list(mean = 2.5, mean_sd = 0.5, sd = 0.47, sd_sd = 0.25, max = 30)),   truncation = trunc_opts(),   obs = obs_opts(),   burn_in = 14,   CrIs = c(0.2, 0.5, 0.9),   model = NULL,   verbose = interactive(),   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"reports data frame containing date report primary secondary reports. secondary call secondary_opts() list containing following binary variables: cumulative, historic, primary_hist_additive, current, primary_current_additive. parameters control structure secondary model, see secondary_opts() details. delays call delay_opts() defining delay distributions primary secondary observations See documentation delay_opts() details. default diffuse prior  assumed mean 14 days standard deviation 7 days (standard deviation 0.5 0.25 respectively log scale). truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). burn_in Integer, defaults 14 days. number data points use estimation fit beginning time series. must less number observations. CrIs Numeric vector credible intervals calculate. model compiled stan model override default model. May useful package developers developing extensions. verbose Logical, model fitting progress returned. Defaults interactive(). ... Additional parameters pass rstan::sampling.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"list containing: predictions (data frame ordered date primary, secondary observations, summary model estimated secondary observations), data (list data used fit model), fit (stanfit object).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_secondary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate a Secondary Observation from a Primary Observation — estimate_secondary","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  #' # load data.table for manipulation library(data.table) # load lubridate for dates library(lubridate) #> Loading required package: timechange #>  #> Attaching package: ‘lubridate’ #> The following objects are masked from ‘package:data.table’: #>  #>     hour, isoweek, mday, minute, month, quarter, second, wday, week, #>     yday, year #> The following objects are masked from ‘package:base’: #>  #>     date, intersect, setdiff, union library(purrr) #>  #> Attaching package: ‘purrr’ #> The following object is masked from ‘package:data.table’: #>  #>     transpose #> The following object is masked from ‘package:EpiNow2’: #>  #>     update_list  #### Incidence data example ####  # make some example secondary incidence data cases <- example_confirmed cases <- as.data.table(cases)[, primary := confirm] # Assume that only 40 percent of cases are reported cases[, scaling := 0.4] #>            date confirm primary scaling #>   1: 2020-02-22      14      14     0.4 #>   2: 2020-02-23      62      62     0.4 #>   3: 2020-02-24      53      53     0.4 #>   4: 2020-02-25      97      97     0.4 #>   5: 2020-02-26      93      93     0.4 #>  ---                                    #> 126: 2020-06-26     296     296     0.4 #> 127: 2020-06-27     255     255     0.4 #> 128: 2020-06-28     175     175     0.4 #> 129: 2020-06-29     174     174     0.4 #> 130: 2020-06-30     126     126     0.4 # Parameters of the assumed log normal delay distribution cases[, meanlog := 1.8][, sdlog := 0.5] #>            date confirm primary scaling meanlog sdlog #>   1: 2020-02-22      14      14     0.4     1.8   0.5 #>   2: 2020-02-23      62      62     0.4     1.8   0.5 #>   3: 2020-02-24      53      53     0.4     1.8   0.5 #>   4: 2020-02-25      97      97     0.4     1.8   0.5 #>   5: 2020-02-26      93      93     0.4     1.8   0.5 #>  ---                                                  #> 126: 2020-06-26     296     296     0.4     1.8   0.5 #> 127: 2020-06-27     255     255     0.4     1.8   0.5 #> 128: 2020-06-28     175     175     0.4     1.8   0.5 #> 129: 2020-06-29     174     174     0.4     1.8   0.5 #> 130: 2020-06-30     126     126     0.4     1.8   0.5  # apply a convolution of a log normal to a vector of observations weight_cmf <- function(x, ...) {   set.seed(x[1])   meanlog <- rnorm(1, 1.6, 0.2)   sdlog <- rnorm(1, 0.8, 0.1)   cmf <- cumsum(dlnorm(seq_along(x), meanlog, sdlog)) -     cumsum(dlnorm(0:(length(x) - 1), meanlog, sdlog))   cmf <- cmf / plnorm(length(x), meanlog, sdlog)   conv <- sum(x * rev(cmf), na.rm = TRUE)   conv <- round(conv, 0)   return(conv) } # roll over observed cases to produce a convolution cases <- cases[, .(date, primary = confirm, secondary = confirm)] cases <- cases[, secondary := frollapply(secondary, 15, weight_cmf, align = \"right\")] cases <- cases[!is.na(secondary)] # add a day of the week effect and scale secondary observations at 40\\% of primary cases <- cases[lubridate::wday(date) == 1, secondary := round(0.5 * secondary, 0)] cases <- cases[, secondary := round(secondary * rnorm(.N, 0.4, 0.025), 0)] cases <- cases[secondary < 0, secondary := 0] cases <- cases[, secondary := map_dbl(secondary, ~ rpois(1, .))]  # fit model to example data assuming only a given fraction of primary observations # become secondary observations inc <- estimate_secondary(cases[1:60],   obs = obs_opts(scale = list(mean = 0.2, sd = 0.2)) ) plot(inc, primary = TRUE)   # forecast future secondary cases from primary inc_preds <- forecast_secondary(inc, cases[61:.N][, value := primary]) plot(inc_preds, new_obs = cases, from = \"2020-05-01\")   #### Prevalence data example ####  # make some example prevalence data cases <- example_confirmed cases <- as.data.table(cases) cases <- cases[, .(date,   primary = confirm,   scaled_primary = confirm * rnorm(.N, 0.4, 0.05) )] cases$secondary <- 0 cases$secondary[1] <- as.integer(cases$scaled_primary[1]) for (i in 2:nrow(cases)) {   meanlog <- rnorm(1, 1.6, 0.1)   sdlog <- rnorm(1, 0.8, 0.05)   cmf <- cumsum(dlnorm(1:min(i - 1, 20), meanlog, sdlog)) -     cumsum(dlnorm(0:min(19, i - 2), meanlog, sdlog))   cmf <- cmf / plnorm(min(i - 1, 20), meanlog, sdlog)   reducing_cases <- sum(cases$scaled_primary[(i - 1):max(1, i - 20)] * cmf)   reducing_cases <- ifelse(cases$secondary[i - 1] < reducing_cases,     cases$secondary[i - 1], reducing_cases   )   cases$secondary[i] <- as.integer(     cases$secondary[i - 1] + cases$scaled_primary[i] - reducing_cases   )   cases$secondary[i] <- ifelse(cases$secondary[i] < 0, 0,     cases$secondary[i]   ) } cases <- cases[, secondary := map_dbl(secondary, ~ rpois(1, .))]  # fit model to example prevalence data prev <- estimate_secondary(cases[1:100],   secondary = secondary_opts(type = \"prevalence\"),   obs = obs_opts(     week_effect = FALSE,     scale = list(mean = 0.3, sd = 0.1)   ) ) plot(prev, primary = TRUE)   # forecast future secondary cases from primary prev_preds <- forecast_secondary(prev, cases[101:.N][, value := primary]) plot(prev_preds, new_obs = cases, from = \"2020-06-01\")   options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Truncation of Observed Data — estimate_truncation","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"Estimates truncation distribution multiple snapshots data source time. distribution can used regional_epinow, epinow, estimate_infections adjust truncated data. See example using approach Covid-19 data England. functionality offered function now available principled manner epinowcast R package. model truncation follows: truncation distribution assumed discretised log normal mean standard deviation informed data. data set latest observations adjusted truncation using truncation distribution. Earlier data sets recreated applying truncation distribution adjusted latest observations time period earlier data set. data sets compared earlier observations assuming negative binomial observation model additive noise term deal zero observations. model fit using stan standard normal, half normal, prior mean, standard deviation, 1 square root dispersion additive noise term. approach assumes : Current truncation related past truncation. Truncation multiplicative scaling underlying reported cases. Truncation log normally distributed.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"","code":"estimate_truncation(   obs,   max_truncation = 10,   model = NULL,   CrIs = c(0.2, 0.5, 0.9),   verbose = TRUE,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"obs list data frames containing date variable confirm (integer) variable. data set snapshot reported data time. data sets must contain complete vector dates. max_truncation Integer, defaults 10. Maximum number days include truncation distribution. model compiled stan model override default model. May useful package developers developing extensions. CrIs Numeric vector credible intervals calculate. verbose Logical, model fitting progress returned. ... Additional parameters pass rstan::sampling.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"list containing: summary parameters truncation distribution (dist), estimated CMF truncation distribution (cmf, can used adjusted new data), data frame containing observed truncated data, latest observed data adjusted truncation observations (obs), data frame containing last observed data (last_obs, useful plotting validation), data used fitting (data) fit object (fit).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimate_truncation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Truncation of Observed Data — estimate_truncation","text":"","code":"# set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # get example case counts reported_cases <- example_confirmed[1:60]  # define example truncation distribution (note not integer adjusted) trunc_dist <- list(   mean = convert_to_logmean(3, 2),   mean_sd = 0.1,   sd = convert_to_logsd(3, 2),   sd_sd = 0.1,   max = 10 )  # apply truncation to example data construct_truncation <- function(index, cases, dist) {   set.seed(index)   cmf <- cumsum(     dlnorm(       1:(dist$max + 1),       rnorm(1, dist$mean, dist$mean_sd),       rnorm(1, dist$sd, dist$sd_sd)     )   )   cmf <- cmf / cmf[dist$max + 1]   cmf <- rev(cmf)[-1]   trunc_cases <- data.table::copy(cases)[1:(.N - index)]   trunc_cases[(.N - length(cmf) + 1):.N, confirm := as.integer(confirm * cmf)]   return(trunc_cases) } example_data <- purrr::map(c(20, 15, 10, 0),   construct_truncation,   cases = reported_cases,   dist = trunc_dist )  # fit model to example data est <- estimate_truncation(example_data,   verbose = interactive(),   chains = 2, iter = 2000 )  # summary of the distribution est$dist #> $mean #> [1] 0.743 #>  #> $mean_sd #> [1] 0.053 #>  #> $sd #> [1] 0.838 #>  #> $sd_sd #> [1] 0.063 #>  #> $max #> [1] 10 #>  # summary of the estimated truncation cmf (can be applied to new data) print(est$cmf) #>     index      mean      se_mean           sd  lower_90  lower_50  lower_20 #>  1:    10 1.0000000 1.226280e-16 1.229601e-16 1.0000000 1.0000000 1.0000000 #>  2:     9 0.9896889 1.075600e-04 2.799872e-03 0.9846574 0.9880227 0.9893294 #>  3:     8 0.9752521 2.348912e-04 6.136340e-03 0.9643087 0.9715124 0.9743944 #>  4:     7 0.9545625 3.831812e-04 1.004978e-02 0.9370735 0.9483097 0.9529824 #>  5:     6 0.9241144 5.497176e-04 1.448162e-02 0.8990795 0.9150072 0.9216233 #>  6:     5 0.8779323 7.217210e-04 1.911491e-02 0.8456177 0.8654845 0.8741544 #>  7:     4 0.8055017 8.623112e-04 2.301875e-02 0.7676057 0.7905808 0.8006204 #>  8:     3 0.6879926 8.816843e-04 2.397265e-02 0.6497516 0.6721271 0.6819925 #>  9:     2 0.4934859 6.087726e-04 1.832795e-02 0.4643281 0.4814682 0.4887787 #> 10:     1 0.1938950 2.846655e-04 1.246762e-02 0.1741613 0.1855408 0.1902387 #>        median  upper_20  upper_50  upper_90 #>  1: 1.0000000 1.0000000 1.0000000 1.0000000 #>  2: 0.9899884 0.9906112 0.9915584 0.9937713 #>  3: 0.9758309 0.9771882 0.9793840 0.9843765 #>  4: 0.9554146 0.9576076 0.9612910 0.9697580 #>  5: 0.9250576 0.9282695 0.9337107 0.9465805 #>  6: 0.8788326 0.8830355 0.8905221 0.9083125 #>  7: 0.8061657 0.8112569 0.8206704 0.8432278 #>  8: 0.6880524 0.6931894 0.7036707 0.7276760 #>  9: 0.4931686 0.4975191 0.5049966 0.5250352 #> 10: 0.1932473 0.1963757 0.2018688 0.2147995 # observations linked to truncation adjusted estimates print(est$obs) #>           date confirm last_confirm report_date mean se_mean  sd lower_90 #>  1: 2020-03-24    4751         4789  2020-04-01 4800       0  13     4780 #>  2: 2020-03-25    5163         5249  2020-04-01 5294       1  33     5244 #>  3: 2020-03-26    5049         5210  2020-04-01 5289       2  55     5206 #>  4: 2020-03-27    5804         6153  2020-04-01 6282       3  99     6131 #>  5: 2020-03-28    5345         5959  2020-04-01 6091       5 133     5884 #>  6: 2020-03-29    4860         5974  2020-04-01 6038       6 173     5763 #>  7: 2020-03-30    3474         5217  2020-04-01 5055       6 176     4774 #>  8: 2020-03-31    1721         4050  2020-04-01 3492       4 129     3277 #>  9: 2020-04-01     502         4053  2020-04-01 2599       3 165     2337 #> 10: 2020-03-29    5852         5974  2020-04-06 5913       0  16     5888 #> 11: 2020-03-30    5025         5217  2020-04-06 5152       1  32     5104 #> 12: 2020-03-31    3808         4050  2020-04-06 3989       1  42     3926 #> 13: 2020-04-01    3676         4053  2020-04-06 3978       2  62     3883 #> 14: 2020-04-02    4105         4782  2020-04-06 4677       3 102     4519 #> 15: 2020-04-03    3668         4668  2020-04-06 4557       4 130     4349 #> 16: 2020-04-04    3093         4585  2020-04-06 4501       5 157     4250 #> 17: 2020-04-05    2423         4805  2020-04-06 4916       6 182     4614 #> 18: 2020-04-06    1106         4316  2020-04-06 5727       8 365     5148 #> 19: 2020-04-03    4636         4668  2020-04-11 4684       0  13     4665 #> 20: 2020-04-04    4522         4585  2020-04-11 4636       1  29     4593 #> 21: 2020-04-05    4681         4805  2020-04-11 4904       1  51     4826 #> 22: 2020-04-06    4115         4316  2020-04-11 4454       2  70     4347 #> 23: 2020-04-07    3298         3599  2020-04-11 3758       3  82     3630 #> 24: 2020-04-08    2580         3039  2020-04-11 3205       3  92     3059 #> 25: 2020-04-09    2788         3836  2020-04-11 4057       5 141     3831 #> 26: 2020-04-10    2156         4204  2020-04-11 4374       5 162     4106 #> 27: 2020-04-11     789         3951  2020-04-11 4085       5 260     3673 #> 28: 2020-04-13    4050         4050  2020-04-21 4092       0  11     4075 #> 29: 2020-04-14    3089         3089  2020-04-21 3167       0  19     3138 #> 30: 2020-04-15    2861         2861  2020-04-21 2997       1  31     2950 #> 31: 2020-04-16    2491         2491  2020-04-21 2696       1  42     2631 #> 32: 2020-04-17    3350         3350  2020-04-21 3817       3  83     3688 #> 33: 2020-04-18    2793         2793  2020-04-21 3470       3  99     3312 #> 34: 2020-04-19    2284         2284  2020-04-21 3323       4 116     3138 #> 35: 2020-04-20    1291         1291  2020-04-21 2619       3  97     2458 #> 36: 2020-04-21     302          302  2020-04-21 1563       2  99     1405 #>           date confirm last_confirm report_date mean se_mean  sd lower_90 #>     lower_50 lower_20 median upper_20 upper_50 upper_90 #>  1:     4791     4796   4799     4802     4808     4825 #>  2:     5271     5283   5290     5298     5314     5354 #>  3:     5252     5272   5284     5298     5324     5388 #>  4:     6216     6252   6274     6297     6343     6455 #>  5:     6002     6052   6081     6114     6175     6320 #>  6:     5921     5990   6028     6070     6147     6331 #>  7:     4936     5011   5049     5093     5168     5346 #>  8:     3407     3459   3489     3521     3574     3706 #>  9:     2486     2556   2597     2638     2705     2882 #> 10:     5901     5907   5911     5915     5922     5943 #> 11:     5130     5142   5149     5157     5172     5210 #> 12:     3961     3976   3985     3995     4015     4063 #> 13:     3936     3960   3973     3988     4017     4088 #> 14:     4609     4648   4670     4695     4743     4854 #> 15:     4469     4521   4549     4581     4639     4778 #> 16:     4395     4461   4495     4535     4601     4760 #> 17:     4798     4870   4913     4957     5032     5218 #> 18:     5478     5632   5723     5813     5960     6350 #> 19:     4675     4679   4682     4686     4692     4708 #> 20:     4617     4627   4633     4640     4654     4689 #> 21:     4869     4888   4899     4911     4936     4995 #> 22:     4407     4432   4448     4464     4497     4576 #> 23:     3703     3734   3752     3772     3810     3900 #> 24:     3143     3180   3200     3222     3263     3361 #> 25:     3962     4021   4052     4088     4148     4290 #> 26:     4269     4333   4371     4410     4477     4643 #> 27:     3908     4017   4082     4147     4252     4530 #> 28:     4084     4088   4090     4093     4099     4113 #> 29:     3154     3161   3165     3170     3179     3203 #> 30:     2976     2987   2994     3002     3016     3053 #> 31:     2667     2683   2692     2702     2722     2770 #> 32:     3761     3793   3811     3832     3870     3961 #> 33:     3403     3442   3464     3488     3532     3638 #> 34:     3245     3294   3319     3349     3398     3515 #> 35:     2556     2594   2617     2641     2681     2780 #> 36:     1496     1537   1562     1587     1627     1734 #>     lower_50 lower_20 median upper_20 upper_50 upper_90 # validation plot of observations vs estimates plot(est)   options(old_opts)"},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Cases by Report Date — estimates_by_report_date","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"Either extracts converts reported cases input data table. output estimate_infections simple filtering step.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"","code":"estimates_by_report_date(   estimates,   CrIs = c(0.2, 0.5, 0.9),   target_folder = NULL,   samples = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"estimates List data frames output estimate_infections CrIs Numeric vector credible intervals calculate. target_folder Character string specifying save results (create present). samples Logical, defaults TRUE. samples saved","code":""},{"path":"epiforecasts.io/EpiNow2/reference/estimates_by_report_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Cases by Report Date — estimates_by_report_date","text":"list samples summarised estimates estimated cases date report","code":""},{"path":"epiforecasts.io/EpiNow2/reference/example_confirmed.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Confirmed Case Data Set — example_confirmed","title":"Example Confirmed Case Data Set — example_confirmed","text":"example data frame observed cases","code":""},{"path":"epiforecasts.io/EpiNow2/reference/example_confirmed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Confirmed Case Data Set — example_confirmed","text":"","code":"example_confirmed"},{"path":"epiforecasts.io/EpiNow2/reference/example_confirmed.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Confirmed Case Data Set — example_confirmed","text":"data frame containing cases reported date.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/expose_stan_fns.html","id":null,"dir":"Reference","previous_headings":"","what":"Expose internal package stan functions in R — expose_stan_fns","title":"Expose internal package stan functions in R — expose_stan_fns","text":"function exposes internal stan functions R user supplied list target files. Allows testing stan functions R potentially user use R code.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/expose_stan_fns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expose internal package stan functions in R — expose_stan_fns","text":"","code":"expose_stan_fns(files, target_dir, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/expose_stan_fns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expose internal package stan functions in R — expose_stan_fns","text":"files character vector indicating target files target_dir character string indicating target directory file ... Additional arguments passed rstan::expose_stan_functions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/expose_stan_fns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expose internal package stan functions in R — expose_stan_fns","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Credible Intervals Present — extract_CrIs","title":"Extract Credible Intervals Present — extract_CrIs","text":"Helper function extract credible intervals present data frame.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Credible Intervals Present — extract_CrIs","text":"","code":"extract_CrIs(summarised)"},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Credible Intervals Present — extract_CrIs","text":"summarised data frame processed calc_CrIs","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Credible Intervals Present — extract_CrIs","text":"numeric vector credible intervals detected data frame.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_CrIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Credible Intervals Present — extract_CrIs","text":"","code":"samples <- data.frame(value = 1:10, type = \"car\") summarised <- calc_CrIs(samples,   summarise_by = \"type\",   CrIs = c(seq(0.05, 0.95, 0.05)) ) extract_CrIs(summarised) #>  [1] 95 90 85 80 75 70 65 60 55 50 45 40 35 30 25 20 15 10  5"},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate initial conditions from a Stan fit — extract_inits","title":"Generate initial conditions from a Stan fit — extract_inits","text":"Extracts posterior samples use initialise full model fit. may useful certain data sets sampler gets stuck easily initialised. estimate_infections(), epinow() regional_epinow() option can engaged setting stan_opts(init_fit = <stanfit>). implementation based approach taken epidemia authored James Scott.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate initial conditions from a Stan fit — extract_inits","text":"","code":"extract_inits(fit, current_inits, exclude_list = NULL, samples = 50)"},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate initial conditions from a Stan fit — extract_inits","text":"fit stanfit object current_inits function returns list initial conditions (create_initial_conditions()). used exclude_list specified. exclude_list character vector parameters initialise fit object, defaulting NULL. samples Numeric, defaults 50. Number posterior samples.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_inits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate initial conditions from a Stan fit — extract_inits","text":"function called returns set initial conditions named list.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Samples for a Parameter from a Stan model — extract_parameter","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"Extracts single list stan output returns data.table.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"","code":"extract_parameter(param, samples, dates)"},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"param Character string indicating parameter extract samples Extracted stan model (using rstan::extract) dates vector identifying dimensionality parameter extract. Generally date","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Samples for a Parameter from a Stan model — extract_parameter","text":"data frame containing parameter name, date, sample id sample value","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"Extracts custom set parameters stan object adds stratification dates appropriate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"","code":"extract_parameter_samples(   stan_fit,   data,   reported_dates,   reported_inf_dates,   drop_length_1 = FALSE,   merge = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"stan_fit fit Stan model returned rstan:sampling data list data supplied rstan::sampling call. reported_dates vector dates report estimates . reported_inf_dates vector dates report infection estimates . drop_length_1 Logical; whether first dimension dropped length 1; necessary processing simulation results merge TRUE, merge samples data parameters can extracted data","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_parameter_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Parameter Samples from a Stan Model — extract_parameter_samples","text":"list dataframes containing posterior parameter","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a Parameter Summary from a Stan Object — extract_stan_param","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"Extracts summarised parameter posteriors stanfit object using rstan::summary format consistent summary functions EpiNow2.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"","code":"extract_stan_param(   fit,   params = NULL,   CrIs = c(0.2, 0.5, 0.9),   var_names = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"fit stanfit object params character vector parameters extract. Defaults parameters. CrIs Numeric vector credible intervals calculate. var_names Logical defaults FALSE. variables named. Automatically set TRUE multiple parameters extracted.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_stan_param.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a Parameter Summary from a Stan Object — extract_stan_param","text":"data.table summarising parameter posteriors. Contains following variables: variable, mean, mean_se, sd, median, lower_, upper_ followed credible interval labels indicating credible intervals present.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"Extract Samples Parameter Single Dimension","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"","code":"extract_static_parameter(param, samples)"},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"param Character string indicating parameter extract samples Extracted stan model (using rstan::extract)","code":""},{"path":"epiforecasts.io/EpiNow2/reference/extract_static_parameter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Samples from a Parameter with a Single Dimension — extract_static_parameter","text":"data frame containing parameter name, sample id sample value","code":""},{"path":"epiforecasts.io/EpiNow2/reference/filter_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter Options for a Target Region — filter_opts","title":"Filter Options for a Target Region — filter_opts","text":"helper function allows selection region specific settings present otherwise applies overarching settings","code":""},{"path":"epiforecasts.io/EpiNow2/reference/filter_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter Options for a Target Region — filter_opts","text":"","code":"filter_opts(opts, region)"},{"path":"epiforecasts.io/EpiNow2/reference/filter_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter Options for a Target Region — filter_opts","text":"opts Either list calls _opts() function single call _opts() function. region character string indicating region interest.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/filter_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter Options for a Target Region — filter_opts","text":"list options","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"Fits stan model using rstan::sampling. Provides optional ability run chains using future error catching, timeouts merging completed chains.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"","code":"fit_model_with_nuts(   args,   future = FALSE,   max_execution_time = Inf,   id = \"stan\" )"},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"args List stan arguments future Logical, defaults FALSE. future used run stan chains parallel. max_execution_time Numeric, defaults Inf. maximum execution time per chain seconds. Results still returned long least 2 chains complete successfully within timelimit. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_nuts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Stan Model using the NUTs sampler — fit_model_with_nuts","text":"stan model object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Stan Model using Variational Inference — fit_model_with_vb","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"Fits stan model using variational inference.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"","code":"fit_model_with_vb(args, future = FALSE, id = \"stan\")"},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"args List stan arguments future Logical, defaults FALSE. future used run stan chains parallel. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/fit_model_with_vb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Stan Model using Variational Inference — fit_model_with_vb","text":"stan model object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"function forecasts secondary observations using output estimate_secondary() either observed primary data forecast primary observations. See examples estimate_secondary() one use case. can also combined estimate_infections() produce forecast secondary observation forecast primary observation. See examples estimate_secondary() example use cases synthetic data. See example forecasting Covid-19 deaths Covid-19 cases.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"","code":"forecast_secondary(   estimate,   primary,   primary_variable = \"reported_cases\",   model = NULL,   samples = NULL,   all_dates = FALSE,   CrIs = c(0.2, 0.5, 0.9) )"},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"estimate object class \"estimate_secondary\" produced estimate_secondary(). primary data.frame containing least date value (integer) variables optionally sample. Used primary observation used forecast secondary observations. Alternatively, may object class \"estimate_infections\" produced estimate_infections(). primary class \"estimate_infections\" internal samples filtered minimum date ahead observed estimate object. primary_variable character string indicating primary variable, defaulting \"reported_cases\". used primary class \"estimate_infections\". model compiled stan model returned rstan::stan_model. samples Numeric, number posterior samples simulate . default use samples primary input present. present default use 1000 samples. all_dates Logical, defaults FALSE. forecast dates just forecast horizon returned. CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/forecast_secondary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecast Secondary Observations Given a Fit from estimate_secondary — forecast_secondary","text":"list containing: predictions (data frame ordered date primary, secondary observations, summary forecast secondary observations. primary observations forecast horizon uncertainty present median used), samples data frame forecast secondary observation posterior samples, forecast summary forecast secondary observation posterior.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Format Posterior Samples — format_fit","title":"Format Posterior Samples — format_fit","text":"Summaries posterior samples adds additional custom variables.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format Posterior Samples — format_fit","text":"","code":"format_fit(posterior_samples, horizon, shift, burn_in, start_date, CrIs)"},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format Posterior Samples — format_fit","text":"posterior_samples list posterior samples returned extract_parameter_samples horizon Numeric, forecast horizon shift Numeric, shift apply estimates burn_in Numeric, number days discard estimates start_date Date, earliest date data CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/format_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format Posterior Samples — format_fit","text":"list samples summarised posterior parameter estimates","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"Generates distribution definition parameter estimates available gamma distributed parameters. See rgamma distribution information.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"","code":"gamma_dist_def(   shape,   shape_sd,   scale,   scale_sd,   mean,   mean_sd,   sd,   sd_sd,   max_value,   samples )"},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"shape Numeric, shape parameter gamma distribution. shape_sd Numeric, standard deviation shape parameter. scale Numeric, scale parameter gamma distribution. scale_sd Numeric, standard deviation scale parameter. mean Numeric, log mean parameter gamma distribution. mean_sd Numeric, standard deviation log mean parameter. sd Numeric, log sd parameter gamma distribution. sd_sd Numeric, standard deviation log sd parameter. max_value Numeric, maximum value allow. Defaults 120. Samples outside range resampled. samples Numeric, number sample distributions generate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"data.table defining distribution used dist_skel","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gamma_dist_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Gamma Distribution Definition Based on Parameter Estimates — gamma_dist_def","text":"","code":"# using estimated shape and scale def <- gamma_dist_def(   shape = 5.807, shape_sd = 0.2,   scale = 0.9, scale_sd = 0.05,   max_value = 20, samples = 10 ) print(def) #>     model    params max_value #>  1: gamma <list[2]>        20 #>  2: gamma <list[2]>        20 #>  3: gamma <list[2]>        20 #>  4: gamma <list[2]>        20 #>  5: gamma <list[2]>        20 #>  6: gamma <list[2]>        20 #>  7: gamma <list[2]>        20 #>  8: gamma <list[2]>        20 #>  9: gamma <list[2]>        20 #> 10: gamma <list[2]>        20 def$params[[1]] #> $alpha #> [1] 5.720998 #>  #> $beta #> [1] 1.100175 #>   # using mean and sd def <- gamma_dist_def(   mean = 3, mean_sd = 0.5,   sd = 3, sd_sd = 0.1,   max_value = 20, samples = 10 ) print(def) #>     model    params max_value #>  1: gamma <list[2]>        20 #>  2: gamma <list[2]>        20 #>  3: gamma <list[2]>        20 #>  4: gamma <list[2]>        20 #>  5: gamma <list[2]>        20 #>  6: gamma <list[2]>        20 #>  7: gamma <list[2]>        20 #>  8: gamma <list[2]>        20 #>  9: gamma <list[2]>        20 #> 10: gamma <list[2]>        20 def$params[[1]] #> $alpha #> [1] 1.018861 #>  #> $beta #> [1] 0.3328072 #>"},{"path":"epiforecasts.io/EpiNow2/reference/generation_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Literature Estimates of Generation Times — generation_times","title":"Literature Estimates of Generation Times — generation_times","text":"Generation time estimates. See details: https://github.com/epiforecasts/EpiNow2/blob/main/data-raw/generation-time.R","code":""},{"path":"epiforecasts.io/EpiNow2/reference/generation_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Literature Estimates of Generation Times — generation_times","text":"","code":"generation_times"},{"path":"epiforecasts.io/EpiNow2/reference/generation_times.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Literature Estimates of Generation Times — generation_times","text":"data.table summarising distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a Literature Distribution — get_dist","title":"Get a Literature Distribution — get_dist","text":"Search data frame distribution return format expected delay_opts() generation_time argument epinow estimate_infections.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Literature Distribution — get_dist","text":"","code":"get_dist(data, disease, source, max_value = 15)"},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Literature Distribution — get_dist","text":"data data.table format generation_times. disease character string indicating disease interest. source character string indicating source interest. max_value Numeric, maximum value allow. Defaults 15 days.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Literature Distribution — get_dist","text":"list defining distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a Literature Distribution — get_dist","text":"","code":"get_dist(EpiNow2::generation_times, disease = \"SARS-CoV-2\", source = \"ganyani\") #> $mean #> [1] 3.635272 #>  #> $mean_sd #> [1] 0.7109351 #>  #> $sd #> [1] 3.075315 #>  #> $sd_sd #> [1] 0.7695178 #>  #> $max #> [1] 15 #>"},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a Literature Distribution for the Generation Time — get_generation_time","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"Extracts literature distribution generation_times","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"","code":"get_generation_time(disease, source, max_value = 15)"},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"disease character string indicating disease interest. source character string indicating source interest. max_value Numeric, maximum value allow. Defaults 15 days.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"list defining distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_generation_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a Literature Distribution for the Generation Time — get_generation_time","text":"","code":"get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") #> $mean #> [1] 3.635272 #>  #> $mean_sd #> [1] 0.7109351 #>  #> $sd #> [1] 3.075315 #>  #> $sd_sd #> [1] 0.7695178 #>  #> $max #> [1] 15 #>"},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a Literature Distribution for the Incubation Period — get_incubation_period","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"Extracts literature distribution incubation_periods","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"","code":"get_incubation_period(disease, source, max_value = 15)"},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"disease character string indicating disease interest. source character string indicating source interest. max_value Numeric, maximum value allow. Defaults 15 days.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"list defining distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_incubation_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a Literature Distribution for the Incubation Period — get_incubation_period","text":"","code":"get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") #> $mean #> [1] 1.621 #>  #> $mean_sd #> [1] 0.064 #>  #> $sd #> [1] 0.418 #>  #> $sd_sd #> [1] 0.0691 #>  #> $max #> [1] 15 #>"},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/get_raw_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Single Raw Result — get_raw_result","text":"","code":"get_raw_result(file, region, date, result_dir)"},{"path":"epiforecasts.io/EpiNow2/reference/get_raw_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Single Raw Result — get_raw_result","text":"file Character string giving result files name. region Character string giving region interest. date Target date (format \"yyyy-mm-dd). result_dir Character string giving location target directory","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_raw_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Single Raw Result — get_raw_result","text":"R object read targeted .rds file","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Combined Regional Results — get_regional_results","title":"Get Combined Regional Results — get_regional_results","text":"Summarises results across regions either input disk. See examples details.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Combined Regional Results — get_regional_results","text":"","code":"get_regional_results(   regional_output,   results_dir,   date,   samples = TRUE,   forecast = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Combined Regional Results — get_regional_results","text":"regional_output list output produced regional_epinow stored regional list. results_dir character string indicating folder containing EpiNow2 results extract. date Character string (format \"yyyy-mm-dd\") indicating date extract data . Defaults \"latest\" finds latest results available. samples Logical, defaults TRUE. samples returned. forecast Logical, defaults FALSE. forecast results returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Combined Regional Results — get_regional_results","text":"list estimates, forecasts estimated cases date report.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regional_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Combined Regional Results — get_regional_results","text":"","code":"# \\donttest{ # construct example distributions generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- estimate_delay(rlnorm(100, log(6), 1), max_value = 10)  # example case vector cases <- example_confirmed[1:30] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # save results to tmp folder dir <- file.path(tempdir(check = TRUE), \"results\") # run multiregion estimates regional_out <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(rw = 7), gp = NULL,   output = c(\"regions\", \"latest\"),   target_folder = dir,   return_output = TRUE ) #> INFO [2023-01-18 02:10:51] Producing following optional outputs: regions, latest #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpjXBiR6/regional-epinow/2020-03-22.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpjXBiR6/epinow/2020-03-22.log #> INFO [2023-01-18 02:10:51] Reporting estimates using data up to: 2020-03-22 #> INFO [2023-01-18 02:10:51] Saving estimates to : /tmp/RtmpjXBiR6/results #> INFO [2023-01-18 02:10:51] Producing estimates for: testland, realland #> INFO [2023-01-18 02:10:51] Regions excluded: none #> INFO [2023-01-18 02:11:20] Completed estimates for: testland #> INFO [2023-01-18 02:11:57] Completed estimates for: realland #> INFO [2023-01-18 02:11:57] Completed regional estimates #> INFO [2023-01-18 02:11:57] Regions with estimates: 2 #> INFO [2023-01-18 02:11:57] Regions with runtime errors: 0 #> INFO [2023-01-18 02:11:57] Saving timings information to : /tmp/RtmpjXBiR6/results # from output results <- get_regional_results(regional_out$regional, samples = FALSE) names(results) #> [1] \"estimates\"  # from a folder folder_results <- get_regional_results(results_dir = dir, samples = FALSE) names(folder_results) #> [1] \"estimates\" # }"},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/get_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Folders with Results — get_regions","text":"","code":"get_regions(results_dir)"},{"path":"epiforecasts.io/EpiNow2/reference/get_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Folders with Results — get_regions","text":"results_dir character string giving directory results stored (produced regional_rt_pipeline).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Folders with Results — get_regions","text":"named character vector containing results plot.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Regions with Most Reported Cases — get_regions_with_most_reports","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"Extract vector regions reported cases set time window.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"","code":"get_regions_with_most_reports(reported_cases, time_window = 7, no_regions = 6)"},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"reported_cases data frame confirmed cases (confirm) date (date), region (region). time_window Numeric, number days include latest date data. Defaults 7 days. no_regions Numeric, number regions return. Defaults 6.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/get_regions_with_most_reports.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Regions with Most Reported Cases — get_regions_with_most_reports","text":"character vector regions highest reported cases","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate Gaussian Process Settings — gp_opts","title":"Approximate Gaussian Process Settings — gp_opts","text":"Defines list specifying structure approximate Gaussian process. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate Gaussian Process Settings — gp_opts","text":"","code":"gp_opts(   basis_prop = 0.2,   boundary_scale = 1.5,   ls_mean = 21,   ls_sd = 7,   ls_min = 0,   ls_max = 60,   alpha_sd = 0.05,   kernel = \"matern\",   matern_type = 3/2 )"},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate Gaussian Process Settings — gp_opts","text":"basis_prop Numeric, proportion time points use basis functions. Defaults 0.1. Decreasing value results decrease accuracy faster compute time (increasing first effect). general smaller posterior length scales require higher proportion basis functions. See (Riutort-Mayol et al. 2020 https://arxiv.org/abs/2004.11408) advice updating default. setting area active research. boundary_scale Numeric, defaults 1.5. Boundary scale approximate Gaussian process. See (Riutort-Mayol et al. 2020 https://arxiv.org/abs/2004.11408) advice updating default. ls_mean Numeric, defaults 21 days. mean lognormal length scale. ls_sd Numeric, defaults 7 days. standard deviation log normal length scale. ls_sd = 0, inverse-gamma prior Gaussian process length scale used recommended parameters inv_gamma(1.499007, 0.057277 * ls_max). ls_min Numeric, defaults 0. minimum value length scale. ls_max Numeric, defaults 60. maximum value length scale. Updated create_gp_data length input data smaller. alpha_sd Numeric, defaults 0.05. standard deviation magnitude parameter Gaussian process kernel. approximately expected standard deviation logged Rt. kernel Character string, type kernel required. Currently supporting squared exponential kernel (\"se\") 3 2 Matern kernel (\"matern\", matern_type = 3/2). Defaulting Matern 3 2 kernel discontinuities expected Rt infections. matern_type Numeric, defaults 3/2. Type Matern Kernel use. Currently Matern 3/2 kernel supported.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate Gaussian Process Settings — gp_opts","text":"list settings defining Gaussian process","code":""},{"path":"epiforecasts.io/EpiNow2/reference/gp_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate Gaussian Process Settings — gp_opts","text":"","code":"# default settings gp_opts() #> $basis_prop #> [1] 0.2 #>  #> $boundary_scale #> [1] 1.5 #>  #> $ls_mean #> [1] 21 #>  #> $ls_sd #> [1] 7 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 60 #>  #> $alpha_sd #> [1] 0.05 #>  #> $kernel #> [1] \"matern_3/2\" #>  #> $matern_type #> [1] 1.5 #>   # add a custom length scale gp_opts(ls_mean = 4) #> $basis_prop #> [1] 0.2 #>  #> $boundary_scale #> [1] 1.5 #>  #> $ls_mean #> [1] 4 #>  #> $ls_sd #> [1] 7 #>  #> $ls_min #> [1] 0 #>  #> $ls_max #> [1] 60 #>  #> $alpha_sd #> [1] 0.05 #>  #> $kernel #> [1] \"matern_3/2\" #>  #> $matern_type #> [1] 1.5 #>"},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Growth Rates to Reproduction numbers. — growth_to_R","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"See justification. Now handled internally stan may removed future updates user demand.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"","code":"growth_to_R(r, gamma_mean, gamma_sd)"},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"r Numeric, rate growth estimates gamma_mean Numeric, mean gamma distribution gamma_sd Numeric, standard deviation gamma distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"Numeric vector reproduction number estimates","code":""},{"path":"epiforecasts.io/EpiNow2/reference/growth_to_R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Growth Rates to Reproduction numbers. — growth_to_R","text":"","code":"growth_to_R(0.2, 4, 1) #> [1] 2.182875"},{"path":"epiforecasts.io/EpiNow2/reference/incubation_periods.html","id":null,"dir":"Reference","previous_headings":"","what":"Literature Estimates of Incubation Periods — incubation_periods","title":"Literature Estimates of Incubation Periods — incubation_periods","text":"Incubation period estimates. See details: https://github.com/epiforecasts/EpiNow2/blob/main/data-raw/incubation-period.R","code":""},{"path":"epiforecasts.io/EpiNow2/reference/incubation_periods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Literature Estimates of Incubation Periods — incubation_periods","text":"","code":"incubation_periods"},{"path":"epiforecasts.io/EpiNow2/reference/incubation_periods.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Literature Estimates of Incubation Periods — incubation_periods","text":"data.table summarising distribution","code":""},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"Fits model cumulative cases. may useful approach initialising full model fit certain data sets sampler gets stuck easily initialised fitting cumulative cases changes shape posterior distribution. estimate_infections(), epinow() regional_epinow() option can engaged setting stan_opts(init_fit = \"cumulative\"). implementation based approach taken epidemia authored James Scott.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"","code":"init_cumulative_fit(   args,   samples = 50,   warmup = 50,   id = \"init\",   verbose = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"args List stan arguments samples Numeric, defaults 50. Number posterior samples. warmup Numeric, defaults 50. Number warmup samples. id character string used assign logging information error. Used regional_epinow assign errors regions. Alter default run error catching. verbose Logical, fitting progress returned. Defaults FALSE.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/init_cumulative_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate initial conditions by fitting to cumulative cases — init_cumulative_fit","text":"stanfit object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"Generates distribution definition parameter estimates available log normal distributed parameters. See rlnorm distribution information.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"","code":"lognorm_dist_def(mean, mean_sd, sd, sd_sd, max_value, samples, to_log = FALSE)"},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"mean Numeric, log mean parameter gamma distribution. mean_sd Numeric, standard deviation log mean parameter. sd Numeric, log sd parameter gamma distribution. sd_sd Numeric, standard deviation log sd parameter. max_value Numeric, maximum value allow. Defaults 120. Samples outside range resampled. samples Numeric, number sample distributions generate. to_log Logical, parameters logged use.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"data.table defining distribution used dist_skel","code":""},{"path":"epiforecasts.io/EpiNow2/reference/lognorm_dist_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Log Normal Distribution Definition Based on Parameter Estimates — lognorm_dist_def","text":"","code":"def <- lognorm_dist_def(   mean = 1.621, mean_sd = 0.0640,   sd = 0.418, sd_sd = 0.0691,   max_value = 20, samples = 10 ) print(def) #>       model    params max_value #>  1: lognorm <list[2]>        20 #>  2: lognorm <list[2]>        20 #>  3: lognorm <list[2]>        20 #>  4: lognorm <list[2]>        20 #>  5: lognorm <list[2]>        20 #>  6: lognorm <list[2]>        20 #>  7: lognorm <list[2]>        20 #>  8: lognorm <list[2]>        20 #>  9: lognorm <list[2]>        20 #> 10: lognorm <list[2]>        20 def$params[[1]] #> $mean #> [1] 1.693223 #>  #> $sd #> [1] 0.319885 #>   def <- lognorm_dist_def(   mean = 5, mean_sd = 1,   sd = 3, sd_sd = 1,   max_value = 20, samples = 10,   to_log = TRUE ) print(def) #>       model    params max_value #>  1: lognorm <list[2]>        20 #>  2: lognorm <list[2]>        20 #>  3: lognorm <list[2]>        20 #>  4: lognorm <list[2]>        20 #>  5: lognorm <list[2]>        20 #>  6: lognorm <list[2]>        20 #>  7: lognorm <list[2]>        20 #>  8: lognorm <list[2]>        20 #>  9: lognorm <list[2]>        20 #> 10: lognorm <list[2]>        20 def$params[[1]] #> $mean #> [1] 1.475956 #>  #> $sd #> [1] 0.6237088 #>"},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":null,"dir":"Reference","previous_headings":"","what":"Format Credible Intervals — make_conf","title":"Format Credible Intervals — make_conf","text":"Combines list values formatted credible intervals.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format Credible Intervals — make_conf","text":"","code":"make_conf(value, CrI = 90, reverse = FALSE)"},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format Credible Intervals — make_conf","text":"value List value map string. Requires, point, lower, upper. CrI Numeric, credible interval report. Defaults 90 reverse Logical, defaults FALSE. reported credible interval switched.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format Credible Intervals — make_conf","text":"character vector formatted reporting","code":""},{"path":"epiforecasts.io/EpiNow2/reference/make_conf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format Credible Intervals — make_conf","text":"","code":"value <- list(median = 2, lower_90 = 1, upper_90 = 3) make_conf(value) #> [1] \"2 (1 -- 3)\""},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Categorise the Probability of Change for Rt — map_prob_change","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"Categorises numeric variable \"Increasing\" (< 0.05), \"Likely increasing\" (<0.4), \"Stable\" (< 0.6), \"Likely decreasing\" (< 0.95), \"Decreasing\" (<= 1)","code":""},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"","code":"map_prob_change(var)"},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"var Numeric variable categorised","code":""},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"character variable.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/map_prob_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Categorise the Probability of Change for Rt — map_prob_change","text":"","code":"var <- seq(0.01, 1, 0.01) var #>   [1] 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 #>  [16] 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 #>  [31] 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 #>  [46] 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 #>  [61] 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 #>  [76] 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 #>  [91] 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00  map_prob_change(var) #>   [1] Increasing        Increasing        Increasing        Increasing        #>   [5] Likely increasing Likely increasing Likely increasing Likely increasing #>   [9] Likely increasing Likely increasing Likely increasing Likely increasing #>  [13] Likely increasing Likely increasing Likely increasing Likely increasing #>  [17] Likely increasing Likely increasing Likely increasing Likely increasing #>  [21] Likely increasing Likely increasing Likely increasing Likely increasing #>  [25] Likely increasing Likely increasing Likely increasing Likely increasing #>  [29] Likely increasing Likely increasing Likely increasing Likely increasing #>  [33] Likely increasing Likely increasing Likely increasing Likely increasing #>  [37] Likely increasing Likely increasing Likely increasing Stable            #>  [41] Stable            Stable            Stable            Stable            #>  [45] Stable            Stable            Stable            Stable            #>  [49] Stable            Stable            Stable            Stable            #>  [53] Stable            Stable            Stable            Stable            #>  [57] Stable            Stable            Stable            Likely decreasing #>  [61] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [65] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [69] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [73] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [77] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [81] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [85] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [89] Likely decreasing Likely decreasing Likely decreasing Likely decreasing #>  [93] Likely decreasing Likely decreasing Decreasing        Decreasing        #>  [97] Decreasing        Decreasing        Decreasing        Decreasing        #> Levels: Increasing Likely increasing Stable Likely decreasing Decreasing"},{"path":"epiforecasts.io/EpiNow2/reference/match_output_arguments.html","id":null,"dir":"Reference","previous_headings":"","what":"Match User Supplied Arguments with Supported Options — match_output_arguments","title":"Match User Supplied Arguments with Supported Options — match_output_arguments","text":"Match user supplied arguments supported options return logical list internal usage","code":""},{"path":"epiforecasts.io/EpiNow2/reference/match_output_arguments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match User Supplied Arguments with Supported Options — match_output_arguments","text":"","code":"match_output_arguments(   input_args = c(),   supported_args = c(),   logger = NULL,   level = \"info\" )"},{"path":"epiforecasts.io/EpiNow2/reference/match_output_arguments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match User Supplied Arguments with Supported Options — match_output_arguments","text":"input_args character vector input arguments (can partial). supported_args character vector supported output arguments. logger character vector indicating logger target messages . Defaults logging. level Character string defaulting \"info\". Logging level see documentation futile.logger details. Supported options \"info\" \"debug\"","code":""},{"path":"epiforecasts.io/EpiNow2/reference/match_output_arguments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match User Supplied Arguments with Supported Options — match_output_arguments","text":"logical vector named output arguments","code":""},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation Model Options — obs_opts","title":"Observation Model Options — obs_opts","text":"Defines list specifying structure observation model. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation Model Options — obs_opts","text":"","code":"obs_opts(   family = \"negbin\",   phi = c(0, 1),   weight = 1,   week_effect = TRUE,   week_length = 7,   scale = list(),   likelihood = TRUE,   return_likelihood = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation Model Options — obs_opts","text":"family Character string defining observation model. Options Negative binomial (\"negbin\"), default, Poisson. phi numeric vector length 2, defaults 0, 1. Indicates mean standard deviation normal prior used observation process. weight Numeric, defaults 1. Weight give observed data log density. week_effect Logical defaulting TRUE. day week effect used observation model. week_length Numeric assumed length week days, defaulting 7 days. can modified data aggregated period week data non-weekly periodicity. scale List, defaulting empty list. scaling factor applied map latent infections (convolved date report). none empty mean (mean) standard deviation (sd) needs supplied defining normally distributed scaling factor. likelihood Logical, defaults TRUE. likelihood included model return_likelihood Logical, defaults FALSE. likelihood returned model.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation Model Options — obs_opts","text":"list observation model settings.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/obs_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation Model Options — obs_opts","text":"","code":"# default settings obs_opts() #> $family #> [1] \"negbin\" #>  #> $phi #> [1] 0 1 #>  #> $weight #> [1] 1 #>  #> $week_effect #> [1] TRUE #>  #> $week_length #> [1] 7 #>  #> $scale #> list() #>  #> $likelihood #> [1] TRUE #>  #> $return_likelihood #> [1] FALSE #>   # Turn off day of the week effect obs_opts(week_effect = TRUE) #> $family #> [1] \"negbin\" #>  #> $phi #> [1] 0 1 #>  #> $weight #> [1] 1 #>  #> $week_effect #> [1] TRUE #>  #> $week_length #> [1] 7 #>  #> $scale #> list() #>  #> $likelihood #> [1] TRUE #>  #> $return_likelihood #> [1] FALSE #>   # Scale reported data obs_opts(scale = list(mean = 0.2, sd = 0.02)) #> $family #> [1] \"negbin\" #>  #> $phi #> [1] 0 1 #>  #> $weight #> [1] 1 #>  #> $week_effect #> [1] TRUE #>  #> $week_length #> [1] 7 #>  #> $scale #> $scale$mean #> [1] 0.2 #>  #> $scale$sd #> [1] 0.02 #>  #>  #> $likelihood #> [1] TRUE #>  #> $return_likelihood #> [1] FALSE #>"},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Return an _opts List per Region — opts_list","title":"Return an _opts List per Region — opts_list","text":"Define list _opts() pass regional_epinow _opts() accepting arguments. useful different settings needed regions within single regional_epinow call. Using opts_list defaults can applied regions present override passed regions necessary (either within opts_list externally).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return an _opts List per Region — opts_list","text":"","code":"opts_list(opts, reported_cases, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return an _opts List per Region — opts_list","text":"opts _opts() function call rt_opts() reported_cases data frame containing region variable indicating target regions ... Optional override region defaults. See examples use case.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return an _opts List per Region — opts_list","text":"named list options per region can passed _opt accepting arguments regional_epinow","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/opts_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return an _opts List per Region — opts_list","text":"","code":"# uses example case vector cases <- example_confirmed[1:40] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # default settings opts_list(rt_opts(), cases) #> $testland #> $testland$prior #> $testland$prior$mean #> [1] 1 #>  #> $testland$prior$sd #> [1] 1 #>  #>  #> $testland$use_rt #> [1] TRUE #>  #> $testland$rw #> [1] 0 #>  #> $testland$use_breakpoints #> [1] TRUE #>  #> $testland$future #> [1] \"latest\" #>  #> $testland$pop #> [1] 0 #>  #> $testland$gp_on #> [1] \"R_t-1\" #>  #>  #> $realland #> $realland$prior #> $realland$prior$mean #> [1] 1 #>  #> $realland$prior$sd #> [1] 1 #>  #>  #> $realland$use_rt #> [1] TRUE #>  #> $realland$rw #> [1] 0 #>  #> $realland$use_breakpoints #> [1] TRUE #>  #> $realland$future #> [1] \"latest\" #>  #> $realland$pop #> [1] 0 #>  #> $realland$gp_on #> [1] \"R_t-1\" #>  #>   # add a weekly random walk in realland opts_list(rt_opts(), cases, realland = rt_opts(rw = 7)) #> $testland #> $testland$prior #> $testland$prior$mean #> [1] 1 #>  #> $testland$prior$sd #> [1] 1 #>  #>  #> $testland$use_rt #> [1] TRUE #>  #> $testland$rw #> [1] 0 #>  #> $testland$use_breakpoints #> [1] TRUE #>  #> $testland$future #> [1] \"latest\" #>  #> $testland$pop #> [1] 0 #>  #> $testland$gp_on #> [1] \"R_t-1\" #>  #>  #> $realland #> $realland$prior #> $realland$prior$mean #> [1] 1 #>  #> $realland$prior$sd #> [1] 1 #>  #>  #> $realland$use_rt #> [1] TRUE #>  #> $realland$rw #> [1] 7 #>  #> $realland$use_breakpoints #> [1] TRUE #>  #> $realland$future #> [1] \"latest\" #>  #> $realland$pop #> [1] 0 #>  #> $realland$gp_on #> [1] \"R_t-1\" #>  #>   # add a weekly random walk externally rt <- opts_list(rt_opts(), cases) rt$realland$rw <- 7 rt #> $testland #> $testland$prior #> $testland$prior$mean #> [1] 1 #>  #> $testland$prior$sd #> [1] 1 #>  #>  #> $testland$use_rt #> [1] TRUE #>  #> $testland$rw #> [1] 0 #>  #> $testland$use_breakpoints #> [1] TRUE #>  #> $testland$future #> [1] \"latest\" #>  #> $testland$pop #> [1] 0 #>  #> $testland$gp_on #> [1] \"R_t-1\" #>  #>  #> $realland #> $realland$prior #> $realland$prior$mean #> [1] 1 #>  #> $realland$prior$sd #> [1] 1 #>  #>  #> $realland$use_rt #> [1] TRUE #>  #> $realland$rw #> [1] 7 #>  #> $realland$use_breakpoints #> [1] TRUE #>  #> $realland$future #> [1] \"latest\" #>  #> $realland$pop #> [1] 0 #>  #> $realland$gp_on #> [1] \"R_t-1\" #>  #>"},{"path":"epiforecasts.io/EpiNow2/reference/plot.epinow.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for epinow — plot.epinow","title":"Plot method for epinow — plot.epinow","text":"plot method class \"epinow\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.epinow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for epinow — plot.epinow","text":"","code":"# S3 method for epinow plot(x, type = \"summary\", ...)"},{"path":"epiforecasts.io/EpiNow2/reference/plot.epinow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for epinow — plot.epinow","text":"x list output produced epinow type character vector indicating name plots return. Defaults  \"summary\" supported options \"infections\", \"reports\", \"R\", \"growth_rate\", \"summary\", \"\". ... Pass additional arguments report_plots","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.epinow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for epinow — plot.epinow","text":"List plots produced report_plots","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for estimate_infections — plot.estimate_infections","title":"Plot method for estimate_infections — plot.estimate_infections","text":"plot method class \"estimate_infections\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for estimate_infections — plot.estimate_infections","text":"","code":"# S3 method for estimate_infections plot(x, type = \"summary\", ...)"},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for estimate_infections — plot.estimate_infections","text":"x list output produced estimate_infections type character vector indicating name plots return. Defaults  \"summary\" supported options \"infections\", \"reports\", \"R\", \"growth_rate\", \"summary\", \"\". ... Pass additional arguments report_plots","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for estimate_infections — plot.estimate_infections","text":"List plots produced report_plots","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for estimate_secondary — plot.estimate_secondary","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"plot method class \"estimate_secondary\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"","code":"# S3 method for estimate_secondary plot(x, primary = FALSE, from = NULL, to = NULL, new_obs = NULL, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"x list output produced estimate_secondary primary Logical, defaults FALSE. primary reports also plot? Date object indicating plot . Date object indicating plot . new_obs data.frame containing columns date secondary replace secondary observations stored estimate_secondary output. ... Pass additional arguments plot function. currently use.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_secondary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for estimate_secondary — plot.estimate_secondary","text":"ggplot2 object","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for estimate_truncation — plot.estimate_truncation","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"plot method class \"estimate_truncation\". Returns plot faceted dataset used fitting latest observations columns, data observed time (truncated) dots truncation adjusted estimates ribbon.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"","code":"# S3 method for estimate_truncation plot(x, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"x list output produced estimate_truncation ... Pass additional arguments plot function. currently use.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot.estimate_truncation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for estimate_truncation — plot.estimate_truncation","text":"ggplot2 object","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/plot_CrIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot EpiNow2 Credible Intervals — plot_CrIs","title":"Plot EpiNow2 Credible Intervals — plot_CrIs","text":"Adds lineranges user specified credible intervals","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_CrIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot EpiNow2 Credible Intervals — plot_CrIs","text":"","code":"plot_CrIs(plot, CrIs, alpha, size)"},{"path":"epiforecasts.io/EpiNow2/reference/plot_CrIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot EpiNow2 Credible Intervals — plot_CrIs","text":"plot ggplot2 plot CrIs Numeric list credible intervals present data. produced extract_CrIs alpha Numeric, overall alpha target line range size Numeric, size default line range.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_CrIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot EpiNow2 Credible Intervals — plot_CrIs","text":"ggplot2 plot.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Estimates — plot_estimates","title":"Plot Estimates — plot_estimates","text":"Allows users plot output estimate_infections easily. future releases may depreciated favour increasing functionality S3 plot methods.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Estimates — plot_estimates","text":"","code":"plot_estimates(   estimate,   reported,   ylab = \"Cases\",   hline,   obs_as_col = TRUE,   max_plot = 10,   estimate_type = NULL )"},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Estimates — plot_estimates","text":"estimate data.table estimates containing following variables: date, type (must contain \"estimate\", \"estimate based partial data\" optionally \"forecast\"), reported data.table reported cases following variables: date, confirm. ylab Character string, defaulting \"Cases\". Title plot y axis. hline Numeric, supplied gives horizontal intercept indicator line. obs_as_col Logical, defaults TRUE. observed data, supplied, plotted using columns points (linked using line). max_plot Numeric, defaults 10. multiplicative upper bound number cases shown plot. Based maximum number reported cases. estimate_type Character vector indicating type data plot. Default types supported options : \"Estimate\", \"Estimate based partial data\", \"Forecast\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Estimates — plot_estimates","text":"ggplot2 object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_estimates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Estimates — plot_estimates","text":"","code":"# \\donttest{ # define example cases cases <- example_confirmed[1:40]  # set up example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- estimate_delay(rlnorm(100, log(6), 1), max_value = 10)  # run model out <- estimate_infections(cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay) ) #> Warning: There were 10 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems # plot infections plot_estimates(   estimate = out$summarised[variable == \"infections\"],   reported = cases,   ylab = \"Cases\", max_plot = 2 ) + ggplot2::facet_wrap(~type, scales = \"free_y\")   # plot reported cases estimated via Rt plot_estimates(   estimate = out$summarised[variable == \"reported_cases\"],   reported = cases,   ylab = \"Cases\" )   # plot Rt estimates plot_estimates(   estimate = out$summarised[variable == \"R\"],   ylab = \"Effective Reproduction No.\",   hline = 1 )   #' # plot Rt estimates without forecasts plot_estimates(   estimate = out$summarised[variable == \"R\"],   ylab = \"Effective Reproduction No.\",   hline = 1, estimate_type = \"Estimate\" )  # }"},{"path":"epiforecasts.io/EpiNow2/reference/plot_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a Summary of the Latest Results — plot_summary","title":"Plot a Summary of the Latest Results — plot_summary","text":"Used return summary plot across regions (using results generated summarise_results). May depreciated later releases favour enhanced S3 methods.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a Summary of the Latest Results — plot_summary","text":"","code":"plot_summary(summary_results, x_lab = \"Region\", log_cases = FALSE, max_cases)"},{"path":"epiforecasts.io/EpiNow2/reference/plot_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a Summary of the Latest Results — plot_summary","text":"summary_results data.table returned summarise_results (data object). x_lab character string giving label x axis, defaults region. log_cases Logical, cases shown logged scale. Defaults FALSE max_cases Numeric, default. maximum number cases plot.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/plot_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a Summary of the Latest Results — plot_summary","text":"ggplot2 object","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Process regional estimate — process_region","title":"Process regional estimate — process_region","text":"Internal function removes output required, returns logging information.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process regional estimate — process_region","text":"","code":"process_region(   out,   target_region,   timing,   return_output = TRUE,   return_timing = TRUE,   complete_logger = \"EpiNow2.epinow\" )"},{"path":"epiforecasts.io/EpiNow2/reference/process_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process regional estimate — process_region","text":"List output returned epinow target_region Character string indicating region evaluated timing Output Sys.time return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. return_timing Logical, runtime returned complete_logger Character string indicating logger output completion estimation .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process regional estimate — process_region","text":"list processed output","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/process_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Process all Region Estimates — process_regions","title":"Process all Region Estimates — process_regions","text":"Internal function processes output multiple epinow runs, adds summary logging information.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process all Region Estimates — process_regions","text":"","code":"process_regions(regional_out, regions)"},{"path":"epiforecasts.io/EpiNow2/reference/process_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process all Region Estimates — process_regions","text":"regional_out list output multiple runs regional_epinow regions character vector identifying regions run","code":""},{"path":"epiforecasts.io/EpiNow2/reference/process_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process all Region Estimates — process_regions","text":"list regional estimates successful regional estimates","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":null,"dir":"Reference","previous_headings":"","what":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"Efficiently runs epinow() across multiple regions efficient manner conducts basic data checks cleaning removing regions fewer non_zero_points unlikely produce reasonable results whilst consuming significant resources. See documentation epinow information. default arguments supporting input _opts() functions shared across regions (including delays, truncation, Rt settings, stan settings, gaussian process settings). Region specific settings supported passing named list _opts() calls (entry per region) relevant argument. helper function (opts_list) available facilitate building list. Regions can estimated parallel using {future} package (see setup_future). progress producing estimates across multiple regions tracked using progressr package. Modify behaviour using progressr::handlers enable batch setting R_PROGRESSR_ENABLE=TRUE environment variable.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"","code":"regional_epinow(   reported_cases,   generation_time,   delays = delay_opts(),   truncation = trunc_opts(),   rt = rt_opts(),   backcalc = backcalc_opts(),   gp = gp_opts(),   obs = obs_opts(),   stan = stan_opts(),   horizon = 7,   CrIs = c(0.2, 0.5, 0.9),   target_folder = NULL,   target_date,   non_zero_points = 2,   output = c(\"regions\", \"summary\", \"samples\", \"plots\", \"latest\"),   return_output = FALSE,   summary_args = list(),   verbose = FALSE,   logs = tempdir(check = TRUE),   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"reported_cases data frame confirmed cases (confirm) date (date), region (region). generation_time list containing mean, standard deviation mean (mean_sd), standard deviation (sd), standard deviation standard deviation maximum allowed value generation time (assuming gamma distribution). delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. horizon Numeric, defaults 7. Number days future forecast. CrIs Numeric vector credible intervals calculate. target_folder Character string specifying save results (create present). target_date Date, defaults maximum found data specified. non_zero_points Numeric, minimum number time points non-zero cases region required region evaluated. Defaults 7. output character vector optional output return. Supported options individual regional estimates (\"regions\"),  samples (\"samples\"), plots (\"plots\"), copying individual region dated folder latest folder (target_folder null, set using \"latest\"), stan fit underlying model (\"fit\"), overall summary across regions (\"summary\"). default return samples plots alongside summarised estimates summary statistics. target_folder NULL default also copy results latest folder. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. summary_args list arguments passed regional_summary. See regional_summary documentation details. verbose Logical defaults FALSE. Outputs verbose progress messages console epinow. logs Character path indicating target folder store log information. Defaults temporary directory specified. Default logging can disabled logs set NULL. specifying custom logging setup code setup_default_logging setup_logging function sensible place start. ... Pass additional arguments epinow. See documentation epinow details.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"list output stratified top level regional output across region output summary output","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/regional_epinow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Real-time Rt Estimation, Forecasting and Reporting by Region — regional_epinow","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # construct example distributions generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1),   mean_sd = 0.1,   sd = convert_to_logsd(2, 1),   sd_sd = 0.1, max = 15 )  # uses example case vector cases <- example_confirmed[1:60] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # run epinow across multiple regions and generate summaries # samples and warmup have been reduced for this example def <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.2)),   stan = stan_opts(     samples = 100, warmup = 200,     control = list(adapt_delta = 0.95)   ),   verbose = interactive() ) #> INFO [2023-01-18 02:14:40] Producing following optional outputs: regions, summary, samples, plots, latest #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpjXBiR6/regional-epinow/2020-04-21.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpjXBiR6/epinow/2020-04-21.log #> INFO [2023-01-18 02:14:40] Reporting estimates using data up to: 2020-04-21 #> INFO [2023-01-18 02:14:40] No target directory specified so returning output #> INFO [2023-01-18 02:14:40] Producing estimates for: testland, realland #> INFO [2023-01-18 02:14:40] Regions excluded: none #> INFO [2023-01-18 02:17:42] Completed estimates for: testland #> INFO [2023-01-18 02:20:40] Completed estimates for: realland #> INFO [2023-01-18 02:20:40] Completed regional estimates #> INFO [2023-01-18 02:20:40] Regions with estimates: 2 #> INFO [2023-01-18 02:20:40] Regions with runtime errors: 0 #> INFO [2023-01-18 02:20:40] Producing summary #> INFO [2023-01-18 02:20:40] No summary directory specified so returning summary output #> INFO [2023-01-18 02:20:40] No target directory specified so returning timings  # apply a different rt method per region # (here a gaussian process and a weekly random walk) gp <- opts_list(gp_opts(), cases) gp <- update_list(gp, list(realland = NULL)) #> Warning: `update_list()` was deprecated in purrr 1.0.0. #> Error in update_list(gp, list(realland = NULL)): `...` arguments must be either all named or all unnamed. rt <- opts_list(rt_opts(), cases, realland = rt_opts(rw = 7)) region_rt <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt, gp = gp,   stan = stan_opts(     samples = 100, warmup = 200,     control = list(adapt_delta = 0.95)   ),   verbose = interactive() ) #> INFO [2023-01-18 02:20:40] Producing following optional outputs: regions, summary, samples, plots, latest #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpjXBiR6/regional-epinow/2020-04-21.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpjXBiR6/epinow/2020-04-21.log #> INFO [2023-01-18 02:20:40] Reporting estimates using data up to: 2020-04-21 #> INFO [2023-01-18 02:20:40] No target directory specified so returning output #> INFO [2023-01-18 02:20:40] Producing estimates for: testland, realland #> INFO [2023-01-18 02:20:40] Regions excluded: none #> INFO [2023-01-18 02:23:45] Completed estimates for: testland #> INFO [2023-01-18 02:27:02] Completed estimates for: realland #> INFO [2023-01-18 02:27:02] Completed regional estimates #> INFO [2023-01-18 02:27:02] Regions with estimates: 2 #> INFO [2023-01-18 02:27:02] Regions with runtime errors: 0 #> INFO [2023-01-18 02:27:02] Producing summary #> INFO [2023-01-18 02:27:02] No summary directory specified so returning summary output #> INFO [2023-01-18 02:27:02] No target directory specified so returning timings  options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise Regional Runtimes — regional_runtimes","title":"Summarise Regional Runtimes — regional_runtimes","text":"Used internally regional_epinow summarise region run times.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise Regional Runtimes — regional_runtimes","text":"","code":"regional_runtimes(   regional_output = NULL,   target_folder = NULL,   target_date = NULL,   return_output = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise Regional Runtimes — regional_runtimes","text":"regional_output list output produced regional_epinow stored regional list. target_folder Character string specifying save results (create present). target_date character string giving target date extract results (format \"yyyy-mm-dd\"). Defaults latest available estimates. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_runtimes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise Regional Runtimes — regional_runtimes","text":"data.table region run times","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Regional Summary Output — regional_summary","title":"Regional Summary Output — regional_summary","text":"Used produce summary output either internally regional_epinow externally.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regional Summary Output — regional_summary","text":"","code":"regional_summary(   regional_output = NULL,   reported_cases,   results_dir = NULL,   summary_dir = NULL,   target_date = NULL,   region_scale = \"Region\",   all_regions = TRUE,   return_output = FALSE,   plot = TRUE,   max_plot = 10,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regional Summary Output — regional_summary","text":"regional_output list output produced regional_epinow stored regional list. reported_cases data frame confirmed cases (confirm) date (date), region (region). results_dir optional character string indicating location results directory extract results . summary_dir character string giving directory store summary results. target_date character string giving target date extract results (format \"yyyy-mm-dd\"). Defaults latest available estimates. region_scale character string indicating name give regions summarised. all_regions Logical, defaults TRUE. summary plots regions returned rather just regions interest. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. plot Logical, defaults TRUE. regional summary plots produced. max_plot Numeric, defaults 10. multiplicative upper bound number cases shown plot. Based maximum number reported cases. ... Additional arguments passed report_plots.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regional Summary Output — regional_summary","text":"list summary measures plots","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/regional_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regional Summary Output — regional_summary","text":"","code":"# \\donttest{ # example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- estimate_delay(rlnorm(100, log(6), 1), max_value = 30)  # example case vector from EpiSoon cases <- example_confirmed[1:30] cases <- data.table::rbindlist(list(   data.table::copy(cases)[, region := \"testland\"],   cases[, region := \"realland\"] ))  # run basic nowcasting pipeline out <- regional_epinow(   reported_cases = cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   output = \"region\",   rt = NULL ) #> INFO [2023-01-18 02:27:08] Producing following optional outputs: regions #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpjXBiR6/regional-epinow/2020-03-22.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpjXBiR6/epinow/2020-03-22.log #> INFO [2023-01-18 02:27:08] Reporting estimates using data up to: 2020-03-22 #> INFO [2023-01-18 02:27:08] No target directory specified so returning output #> INFO [2023-01-18 02:27:08] Producing estimates for: testland, realland #> INFO [2023-01-18 02:27:08] Regions excluded: none #> INFO [2023-01-18 02:27:26] Completed estimates for: testland #> INFO [2023-01-18 02:27:44] Completed estimates for: realland #> INFO [2023-01-18 02:27:44] Completed regional estimates #> INFO [2023-01-18 02:27:44] Regions with estimates: 2 #> INFO [2023-01-18 02:27:44] Regions with runtime errors: 0 #> INFO [2023-01-18 02:27:44] No target directory specified so returning timings  regional_summary(   regional_output = out$regional,   reported_cases = cases ) #> INFO [2023-01-18 02:27:44] No summary directory specified so returning summary output #> $latest_date #> [1] \"2020-03-22\" #>  #> $results #> $results$estimates #> $results$estimates$summarised #>        region       date                 variable strat     type      median #>   1: testland 2020-02-22                        R  <NA> estimate    7.710321 #>   2: testland 2020-02-23                        R  <NA> estimate    7.261679 #>   3: testland 2020-02-24                        R  <NA> estimate    6.706708 #>   4: testland 2020-02-25                        R  <NA> estimate    6.243998 #>   5: testland 2020-02-26                        R  <NA> estimate    5.902075 #>  ---                                                                         #> 422: realland 2020-03-26           reported_cases  <NA> forecast  969.000000 #> 423: realland 2020-03-27           reported_cases  <NA> forecast 1248.500000 #> 424: realland 2020-03-28           reported_cases  <NA> forecast 1069.000000 #> 425: realland 2020-03-29           reported_cases  <NA> forecast 1144.000000 #> 426: realland       <NA> reporting_overdispersion  <NA>     <NA>    1.031314 #>             mean           sd   lower_90    lower_50    lower_20    upper_20 #>   1:    7.887310    1.1644395  6.3605600   7.0439820   7.4324310    8.006954 #>   2:    7.412752    1.0400874  6.0446622   6.6692286   7.0065626    7.515975 #>   3:    6.838764    0.9341425  5.6146241   6.1773548   6.4784805    6.924918 #>   4:    6.359433    0.8380311  5.2578175   5.7725308   6.0366016    6.439043 #>   5:    6.010574    0.7608953  5.0084988   5.4775959   5.7170878    6.082507 #>  ---                                                                         #> 422: 1641.535500 1973.2264356 61.9500000 375.0000000 715.0000000 1356.800000 #> 423: 1934.255500 2146.4664133 73.0000000 484.5000000 910.0000000 1658.200000 #> 424: 1624.390000 1733.7356853 71.8500000 419.2500000 790.0000000 1447.000000 #> 425: 1855.674000 2160.7235452 76.9500000 442.0000000 823.6000000 1549.400000 #> 426:    1.084347    0.4059163  0.5292589   0.7927049   0.9329526    1.130225 #>         upper_50    upper_90 #>   1:    8.516868   10.094970 #>   2:    7.971410    9.439445 #>   3:    7.327696    8.652007 #>   4:    6.789421    7.978989 #>   5:    6.402693    7.509611 #>  ---                         #> 422: 2128.000000 5536.400000 #> 423: 2530.000000 6284.150000 #> 424: 2198.250000 5079.450000 #> 425: 2446.500000 5895.000000 #> 426:    1.319677    1.839572 #>  #>  #>  #> $summarised_results #> $summarised_results$table #>      Region New confirmed cases by infection date #> 1: realland                    1018 (946 -- 1140) #> 2: testland                    1019 (948 -- 1135) #>    Expected change in daily cases Effective reproduction no. #> 1:                     Decreasing        0.49 (0.44 -- 0.53) #> 2:                     Decreasing        0.49 (0.44 -- 0.53) #>            Rate of growth Doubling/halving time (days) #> 1: -0.15 (-0.21 -- -0.11)          -4.6 (-6.3 -- -3.3) #> 2: -0.15 (-0.21 -- -0.11)          -4.6 (-6.1 -- -3.3) #>  #> $summarised_results$data #>      region            estimate  median    mean    sd lower_90 lower_50 #> 1: testland  1019 (948 -- 1135) 1019.00 1028.00 58.00   948.00  1004.00 #> 2: realland  1018 (946 -- 1140) 1018.00 1027.00 59.00   946.00  1002.00 #> 3: realland 0.49 (0.44 -- 0.53)    0.49    0.49  0.03     0.44     0.47 #> 4: testland 0.49 (0.44 -- 0.53)    0.49    0.49  0.03     0.44     0.47 #>    lower_20 upper_20 upper_50 upper_90                                metric #> 1:  1015.00  1027.00   1047.0  1135.00 New confirmed cases by infection date #> 2:  1014.00  1025.00   1046.0  1140.00 New confirmed cases by infection date #> 3:     0.48     0.49      0.5     0.53            Effective reproduction no. #> 4:     0.48     0.49      0.5     0.53            Effective reproduction no. #>    Expected change in daily cases prob_control #> 1:                     Decreasing            1 #> 2:                     Decreasing            1 #> 3:                     Decreasing            1 #> 4:                     Decreasing            1 #>  #> $summarised_results$regions_by_inc #> [1] \"testland\" \"realland\" #>  #>  #> $summary_plot  #>  #> $summarised_measures #> $summarised_measures$rt #>       region       date strat                           type    median #>  1: realland 2020-02-22  <NA>                       estimate 7.6468454 #>  2: realland 2020-02-23  <NA>                       estimate 7.1903312 #>  3: realland 2020-02-24  <NA>                       estimate 6.6397400 #>  4: realland 2020-02-25  <NA>                       estimate 6.1808548 #>  5: realland 2020-02-26  <NA>                       estimate 5.8537554 #>  6: realland 2020-02-27  <NA>                       estimate 5.5706459 #>  7: realland 2020-02-28  <NA>                       estimate 5.2712195 #>  8: realland 2020-02-29  <NA>                       estimate 4.3063342 #>  9: realland 2020-03-01  <NA>                       estimate 3.5281823 #> 10: realland 2020-03-02  <NA>                       estimate 2.9707857 #> 11: realland 2020-03-03  <NA>                       estimate 2.4476938 #> 12: realland 2020-03-04  <NA>                       estimate 1.9841112 #> 13: realland 2020-03-05  <NA>                       estimate 1.6256568 #> 14: realland 2020-03-06  <NA>                       estimate 1.3006363 #> 15: realland 2020-03-07  <NA> estimate based on partial data 1.2079841 #> 16: realland 2020-03-08  <NA> estimate based on partial data 1.0335720 #> 17: realland 2020-03-09  <NA> estimate based on partial data 0.8878174 #> 18: realland 2020-03-10  <NA> estimate based on partial data 0.7731896 #> 19: realland 2020-03-11  <NA> estimate based on partial data 0.6807953 #> 20: realland 2020-03-12  <NA> estimate based on partial data 0.6088027 #> 21: realland 2020-03-13  <NA> estimate based on partial data 0.5587969 #> 22: realland 2020-03-14  <NA> estimate based on partial data 0.5293982 #> 23: realland 2020-03-15  <NA> estimate based on partial data 0.5205437 #> 24: realland 2020-03-16  <NA> estimate based on partial data 0.5135677 #> 25: realland 2020-03-17  <NA> estimate based on partial data 0.5085372 #> 26: realland 2020-03-18  <NA> estimate based on partial data 0.5079809 #> 27: realland 2020-03-19  <NA> estimate based on partial data 0.5075721 #> 28: realland 2020-03-20  <NA> estimate based on partial data 0.5050368 #> 29: realland 2020-03-21  <NA> estimate based on partial data 0.5005035 #> 30: realland 2020-03-22  <NA> estimate based on partial data 0.4878888 #> 31: realland 2020-03-23  <NA>                       forecast 0.4872964 #> 32: realland 2020-03-24  <NA>                       forecast 0.4868168 #> 33: realland 2020-03-25  <NA>                       forecast 0.4869636 #> 34: realland 2020-03-26  <NA>                       forecast 0.4869422 #> 35: realland 2020-03-27  <NA>                       forecast 0.4867803 #> 36: realland 2020-03-28  <NA>                       forecast 0.4862729 #> 37: realland 2020-03-29  <NA>                       forecast 0.4862637 #> 38: testland 2020-02-22  <NA>                       estimate 7.7103213 #> 39: testland 2020-02-23  <NA>                       estimate 7.2616790 #> 40: testland 2020-02-24  <NA>                       estimate 6.7067084 #> 41: testland 2020-02-25  <NA>                       estimate 6.2439983 #> 42: testland 2020-02-26  <NA>                       estimate 5.9020750 #> 43: testland 2020-02-27  <NA>                       estimate 5.6069451 #> 44: testland 2020-02-28  <NA>                       estimate 5.2949589 #> 45: testland 2020-02-29  <NA>                       estimate 4.3284067 #> 46: testland 2020-03-01  <NA>                       estimate 3.5458727 #> 47: testland 2020-03-02  <NA>                       estimate 2.9846868 #> 48: testland 2020-03-03  <NA>                       estimate 2.4537080 #> 49: testland 2020-03-04  <NA>                       estimate 1.9885164 #> 50: testland 2020-03-05  <NA>                       estimate 1.6289155 #> 51: testland 2020-03-06  <NA>                       estimate 1.3029368 #> 52: testland 2020-03-07  <NA> estimate based on partial data 1.2099305 #> 53: testland 2020-03-08  <NA> estimate based on partial data 1.0352320 #> 54: testland 2020-03-09  <NA> estimate based on partial data 0.8897093 #> 55: testland 2020-03-10  <NA> estimate based on partial data 0.7747306 #> 56: testland 2020-03-11  <NA> estimate based on partial data 0.6823188 #> 57: testland 2020-03-12  <NA> estimate based on partial data 0.6098451 #> 58: testland 2020-03-13  <NA> estimate based on partial data 0.5591254 #> 59: testland 2020-03-14  <NA> estimate based on partial data 0.5292760 #> 60: testland 2020-03-15  <NA> estimate based on partial data 0.5200633 #> 61: testland 2020-03-16  <NA> estimate based on partial data 0.5134836 #> 62: testland 2020-03-17  <NA> estimate based on partial data 0.5082211 #> 63: testland 2020-03-18  <NA> estimate based on partial data 0.5080036 #> 64: testland 2020-03-19  <NA> estimate based on partial data 0.5079337 #> 65: testland 2020-03-20  <NA> estimate based on partial data 0.5050794 #> 66: testland 2020-03-21  <NA> estimate based on partial data 0.5004479 #> 67: testland 2020-03-22  <NA> estimate based on partial data 0.4881782 #> 68: testland 2020-03-23  <NA>                       forecast 0.4871235 #> 69: testland 2020-03-24  <NA>                       forecast 0.4864367 #> 70: testland 2020-03-25  <NA>                       forecast 0.4867995 #> 71: testland 2020-03-26  <NA>                       forecast 0.4863923 #> 72: testland 2020-03-27  <NA>                       forecast 0.4862546 #> 73: testland 2020-03-28  <NA>                       forecast 0.4861923 #> 74: testland 2020-03-29  <NA>                       forecast 0.4863945 #>       region       date strat                           type    median #>          mean         sd  lower_90  lower_50  lower_20  upper_20  upper_50 #>  1: 7.8485768 1.20237032 6.1936207 7.0151974 7.3820753 7.9467725 8.5348564 #>  2: 7.3798679 1.07700194 5.9014737 6.6309439 6.9629731 7.4604947 7.9942382 #>  3: 6.8085336 0.96572275 5.4700927 6.1479649 6.4381531 6.8738695 7.3706175 #>  4: 6.3317302 0.86560624 5.1295862 5.7379807 6.0046473 6.3883301 6.8335482 #>  5: 5.9851151 0.78591138 4.8996610 5.4435050 5.6944821 6.0328564 6.4297472 #>  6: 5.6872852 0.71654854 4.6917606 5.1920473 5.4317456 5.7362835 6.0838485 #>  7: 5.3694160 0.64985678 4.4744980 4.9234745 5.1397296 5.4124019 5.7177286 #>  8: 4.3797266 0.51071624 3.6946834 4.0277063 4.1994529 4.4161579 4.6432305 #>  9: 3.5847233 0.40525869 3.0530606 3.3090406 3.4380999 3.6100291 3.7894168 #> 10: 3.0200955 0.33107807 2.5847437 2.8028083 2.9013328 3.0398855 3.1769429 #> 11: 2.4862919 0.26273006 2.1488575 2.3186232 2.3919052 2.5029512 2.6068710 #> 12: 2.0162541 0.20237008 1.7637133 1.8899458 1.9421286 2.0303494 2.0984618 #> 13: 1.6520232 0.15832925 1.4588680 1.5555432 1.5946892 1.6586226 1.7158051 #> 14: 1.3223565 0.12143619 1.1755298 1.2500310 1.2796787 1.3252457 1.3704670 #> 15: 1.2272189 0.10794445 1.0995617 1.1642689 1.1912855 1.2273893 1.2677169 #> 16: 1.0487689 0.08903335 0.9430751 0.9987394 1.0216490 1.0484776 1.0791037 #> 17: 0.8999553 0.07329151 0.8131147 0.8595825 0.8778083 0.8988269 0.9230965 #> 18: 0.7830903 0.06156796 0.7111512 0.7513817 0.7646234 0.7826707 0.8017745 #> 19: 0.6888179 0.05204862 0.6280269 0.6625985 0.6739201 0.6879944 0.7041264 #> 20: 0.6157729 0.04447306 0.5636319 0.5930921 0.6034086 0.6152769 0.6286123 #> 21: 0.5645056 0.03917262 0.5172777 0.5449400 0.5538031 0.5642950 0.5756283 #> 22: 0.5339945 0.03621020 0.4877882 0.5153438 0.5238419 0.5344154 0.5462822 #> 23: 0.5240730 0.03451463 0.4788162 0.5062881 0.5148093 0.5255625 0.5368630 #> 24: 0.5165178 0.03320651 0.4698605 0.4994554 0.5082781 0.5190391 0.5292770 #> 25: 0.5107864 0.03224466 0.4634655 0.4945045 0.5031045 0.5143291 0.5240964 #> 26: 0.5094157 0.03134522 0.4620456 0.4941682 0.5027904 0.5137355 0.5234847 #> 27: 0.5084384 0.03049321 0.4611485 0.4939724 0.5026933 0.5131371 0.5220997 #> 28: 0.5050890 0.02986190 0.4574190 0.4910367 0.5001460 0.5102785 0.5188490 #> 29: 0.4998132 0.02967016 0.4531477 0.4858365 0.4954226 0.5056086 0.5136060 #> 30: 0.4874564 0.02960530 0.4404963 0.4736512 0.4831707 0.4933967 0.5018550 #> 31: 0.4865634 0.02967613 0.4379808 0.4731048 0.4825354 0.4924183 0.5014752 #> 32: 0.4857265 0.02980371 0.4352903 0.4723226 0.4817842 0.4921175 0.5008222 #> 33: 0.4855598 0.02998421 0.4347816 0.4725979 0.4818446 0.4918700 0.5008794 #> 34: 0.4850405 0.03011361 0.4340505 0.4718079 0.4817223 0.4917176 0.5006094 #> 35: 0.4848300 0.03020120 0.4307406 0.4719339 0.4821296 0.4917507 0.5000872 #> 36: 0.4843594 0.03020123 0.4312724 0.4715481 0.4818323 0.4913942 0.4996214 #> 37: 0.4844543 0.03016447 0.4317922 0.4714871 0.4817442 0.4914647 0.4997109 #> 38: 7.8873104 1.16443947 6.3605600 7.0439820 7.4324310 8.0069535 8.5168681 #> 39: 7.4127521 1.04008736 6.0446622 6.6692286 7.0065626 7.5159752 7.9714097 #> 40: 6.8387638 0.93414247 5.6146241 6.1773548 6.4784805 6.9249181 7.3276957 #> 41: 6.3594332 0.83803113 5.2578175 5.7725308 6.0366016 6.4390431 6.7894213 #> 42: 6.0105740 0.76089532 5.0084988 5.4775959 5.7170878 6.0825066 6.4026932 #> 43: 5.7112510 0.69419572 4.7937248 5.2321579 5.4482419 5.7797526 6.0646103 #> 44: 5.3926163 0.63104901 4.5470912 4.9612109 5.1484633 5.4544597 5.7215316 #> 45: 4.3981872 0.49618886 3.7317807 4.0576710 4.2076613 4.4494698 4.6582929 #> 46: 3.5988973 0.39409580 3.0802467 3.3292439 3.4469127 3.6383019 3.7978993 #> 47: 3.0317782 0.32380969 2.6105294 2.8142978 2.9101121 3.0596335 3.1874745 #> 48: 2.4964070 0.26010589 2.1625644 2.3227133 2.3999225 2.5119995 2.6137490 #> 49: 2.0240887 0.20190020 1.7675602 1.8936732 1.9520255 2.0319993 2.1152522 #> 50: 1.6581572 0.15915549 1.4596579 1.5579121 1.6016609 1.6619701 1.7258032 #> 51: 1.3269582 0.12270504 1.1743070 1.2518050 1.2837136 1.3277884 1.3769468 #> 52: 1.2310367 0.10907107 1.0980024 1.1669429 1.1928237 1.2308957 1.2732476 #> 53: 1.0517201 0.08971891 0.9399194 1.0001123 1.0216214 1.0513355 1.0855526 #> 54: 0.9020421 0.07322138 0.8093161 0.8621690 0.8780668 0.9023888 0.9267206 #> 55: 0.7845976 0.06078234 0.7057273 0.7524195 0.7665142 0.7842677 0.8054732 #> 56: 0.6898497 0.05051102 0.6249695 0.6629459 0.6753983 0.6896178 0.7064167 #> 57: 0.6163565 0.04241402 0.5639861 0.5941105 0.6041716 0.6154111 0.6304716 #> 58: 0.5645946 0.03718806 0.5168093 0.5451654 0.5536469 0.5643321 0.5769512 #> 59: 0.5336536 0.03477517 0.4887249 0.5160778 0.5241487 0.5340706 0.5461989 #> 60: 0.5236160 0.03371907 0.4780632 0.5065141 0.5153001 0.5253055 0.5366068 #> 61: 0.5159413 0.03305364 0.4683184 0.4993449 0.5081673 0.5187386 0.5298666 #> 62: 0.5100389 0.03267280 0.4621100 0.4941787 0.5029916 0.5135899 0.5248240 #> 63: 0.5085278 0.03217257 0.4588586 0.4930798 0.5025153 0.5127932 0.5229757 #> 64: 0.5074352 0.03152006 0.4569128 0.4932420 0.5024252 0.5126754 0.5213061 #> 65: 0.5040978 0.03086107 0.4552910 0.4906259 0.5001316 0.5097616 0.5178252 #> 66: 0.4988722 0.03045240 0.4503991 0.4853405 0.4950243 0.5053191 0.5137669 #> 67: 0.4863454 0.03033524 0.4363898 0.4721644 0.4829254 0.4933201 0.5015224 #> 68: 0.4854665 0.03029196 0.4363520 0.4717927 0.4824878 0.4923996 0.5006901 #> 69: 0.4846859 0.03033829 0.4340534 0.4710882 0.4818529 0.4916839 0.5001311 #> 70: 0.4846163 0.03048738 0.4342621 0.4700436 0.4815278 0.4916707 0.5001207 #> 71: 0.4842336 0.03063259 0.4335923 0.4698559 0.4810169 0.4915760 0.5000095 #> 72: 0.4841906 0.03076718 0.4310454 0.4694199 0.4808884 0.4914743 0.5000714 #> 73: 0.4839076 0.03081800 0.4309278 0.4693315 0.4807574 0.4911629 0.4993484 #> 74: 0.4841985 0.03080730 0.4317697 0.4699593 0.4806019 0.4912192 0.4996627 #>          mean         sd  lower_90  lower_50  lower_20  upper_20  upper_50 #>       upper_90 #>  1: 10.1518539 #>  2:  9.4615602 #>  3:  8.6618827 #>  4:  7.9717192 #>  5:  7.4529124 #>  6:  7.0198706 #>  7:  6.5859451 #>  8:  5.3121540 #>  9:  4.3180455 #> 10:  3.6222801 #> 11:  2.9611036 #> 12:  2.3830277 #> 13:  1.9350624 #> 14:  1.5440251 #> 15:  1.4229784 #> 16:  1.2069397 #> 17:  1.0256652 #> 18:  0.8855470 #> 19:  0.7774794 #> 20:  0.6911182 #> 21:  0.6307511 #> 22:  0.5984077 #> 23:  0.5836510 #> 24:  0.5748433 #> 25:  0.5662790 #> 26:  0.5622724 #> 27:  0.5588271 #> 28:  0.5536265 #> 29:  0.5466344 #> 30:  0.5319287 #> 31:  0.5307878 #> 32:  0.5298968 #> 33:  0.5309330 #> 34:  0.5295084 #> 35:  0.5287934 #> 36:  0.5282740 #> 37:  0.5274560 #> 38: 10.0949695 #> 39:  9.4394446 #> 40:  8.6520075 #> 41:  7.9789893 #> 42:  7.5096114 #> 43:  7.0411455 #> 44:  6.5912208 #> 45:  5.3235411 #> 46:  4.3330257 #> 47:  3.6354365 #> 48:  2.9889228 #> 49:  2.3892925 #> 50:  1.9400616 #> 51:  1.5469524 #> 52:  1.4215694 #> 53:  1.2095155 #> 54:  1.0284026 #> 55:  0.8917133 #> 56:  0.7839241 #> 57:  0.6965957 #> 58:  0.6318459 #> 59:  0.5958454 #> 60:  0.5830471 #> 61:  0.5687662 #> 62:  0.5629105 #> 63:  0.5603097 #> 64:  0.5566412 #> 65:  0.5519437 #> 66:  0.5457276 #> 67:  0.5324981 #> 68:  0.5322695 #> 69:  0.5299235 #> 70:  0.5296244 #> 71:  0.5297219 #> 72:  0.5296977 #> 73:  0.5300360 #> 74:  0.5314448 #>       upper_90 #>  #> $summarised_measures$growth_rate #>       region       date strat                           type       median #>  1: realland 2020-02-22  <NA>                       estimate  1.247517261 #>  2: realland 2020-02-23  <NA>                       estimate  1.178988484 #>  3: realland 2020-02-24  <NA>                       estimate  1.092206134 #>  4: realland 2020-02-25  <NA>                       estimate  1.022776339 #>  5: realland 2020-02-26  <NA>                       estimate  0.970814633 #>  6: realland 2020-02-27  <NA>                       estimate  0.924840347 #>  7: realland 2020-02-28  <NA>                       estimate  0.873268404 #>  8: realland 2020-02-29  <NA>                       estimate  0.704189140 #>  9: realland 2020-03-01  <NA>                       estimate  0.563210926 #> 10: realland 2020-03-02  <NA>                       estimate  0.455128499 #> 11: realland 2020-03-03  <NA>                       estimate  0.349768121 #> 12: realland 2020-03-04  <NA>                       estimate  0.250149180 #> 13: realland 2020-03-05  <NA>                       estimate  0.166647726 #> 14: realland 2020-03-06  <NA>                       estimate  0.083277601 #> 15: realland 2020-03-07  <NA> estimate based on partial data  0.058124142 #> 16: realland 2020-03-08  <NA> estimate based on partial data  0.009492359 #> 17: realland 2020-03-09  <NA> estimate based on partial data -0.032110014 #> 18: realland 2020-03-10  <NA> estimate based on partial data -0.063879660 #> 19: realland 2020-03-11  <NA> estimate based on partial data -0.090513059 #> 20: realland 2020-03-12  <NA> estimate based on partial data -0.111638090 #> 21: realland 2020-03-13  <NA> estimate based on partial data -0.126481452 #> 22: realland 2020-03-14  <NA> estimate based on partial data -0.135193960 #> 23: realland 2020-03-15  <NA> estimate based on partial data -0.137939498 #> 24: realland 2020-03-16  <NA> estimate based on partial data -0.140042305 #> 25: realland 2020-03-17  <NA> estimate based on partial data -0.141692145 #> 26: realland 2020-03-18  <NA> estimate based on partial data -0.142232159 #> 27: realland 2020-03-19  <NA> estimate based on partial data -0.142656599 #> 28: realland 2020-03-20  <NA> estimate based on partial data -0.143988895 #> 29: realland 2020-03-21  <NA> estimate based on partial data -0.145638008 #> 30: realland 2020-03-22  <NA> estimate based on partial data -0.149399950 #> 31: realland 2020-03-23  <NA>                       forecast -0.149508266 #> 32: realland 2020-03-24  <NA>                       forecast -0.150002710 #> 33: realland 2020-03-25  <NA>                       forecast -0.150167281 #> 34: realland 2020-03-26  <NA>                       forecast -0.150358902 #> 35: realland 2020-03-27  <NA>                       forecast -0.150419548 #> 36: realland 2020-03-28  <NA>                       forecast -0.150397957 #> 37: realland 2020-03-29  <NA>                       forecast -0.150437772 #> 38: testland 2020-02-22  <NA>                       estimate  1.311482530 #> 39: testland 2020-02-23  <NA>                       estimate  1.241828764 #> 40: testland 2020-02-24  <NA>                       estimate  1.148165436 #> 41: testland 2020-02-25  <NA>                       estimate  1.069943299 #> 42: testland 2020-02-26  <NA>                       estimate  1.013160876 #> 43: testland 2020-02-27  <NA>                       estimate  0.960036681 #> 44: testland 2020-02-28  <NA>                       estimate  0.905328344 #> 45: testland 2020-02-29  <NA>                       estimate  0.737503141 #> 46: testland 2020-03-01  <NA>                       estimate  0.585281036 #> 47: testland 2020-03-02  <NA>                       estimate  0.472476603 #> 48: testland 2020-03-03  <NA>                       estimate  0.360202545 #> 49: testland 2020-03-04  <NA>                       estimate  0.253230133 #> 50: testland 2020-03-05  <NA>                       estimate  0.166945628 #> 51: testland 2020-03-06  <NA>                       estimate  0.083597083 #> 52: testland 2020-03-07  <NA> estimate based on partial data  0.058453674 #> 53: testland 2020-03-08  <NA> estimate based on partial data  0.010104947 #> 54: testland 2020-03-09  <NA> estimate based on partial data -0.031695549 #> 55: testland 2020-03-10  <NA> estimate based on partial data -0.063737078 #> 56: testland 2020-03-11  <NA> estimate based on partial data -0.090384235 #> 57: testland 2020-03-12  <NA> estimate based on partial data -0.111707775 #> 58: testland 2020-03-13  <NA> estimate based on partial data -0.126976299 #> 59: testland 2020-03-14  <NA> estimate based on partial data -0.135793922 #> 60: testland 2020-03-15  <NA> estimate based on partial data -0.138724349 #> 61: testland 2020-03-16  <NA> estimate based on partial data -0.141001203 #> 62: testland 2020-03-17  <NA> estimate based on partial data -0.142854025 #> 63: testland 2020-03-18  <NA> estimate based on partial data -0.143152002 #> 64: testland 2020-03-19  <NA> estimate based on partial data -0.143306816 #> 65: testland 2020-03-20  <NA> estimate based on partial data -0.144883353 #> 66: testland 2020-03-21  <NA> estimate based on partial data -0.146453873 #> 67: testland 2020-03-22  <NA> estimate based on partial data -0.150018976 #> 68: testland 2020-03-23  <NA>                       forecast -0.150374446 #> 69: testland 2020-03-24  <NA>                       forecast -0.150594794 #> 70: testland 2020-03-25  <NA>                       forecast -0.150574692 #> 71: testland 2020-03-26  <NA>                       forecast -0.150928659 #> 72: testland 2020-03-27  <NA>                       forecast -0.150730894 #> 73: testland 2020-03-28  <NA>                       forecast -0.150973084 #> 74: testland 2020-03-29  <NA>                       forecast -0.150589684 #>       region       date strat                           type       median #>              mean           sd    lower_90      lower_50     lower_20 #>  1:  1.683851e+06 7.530356e+07  0.57416442  8.403992e-01  1.047915098 #>  2:  7.291255e+05 3.260707e+07  0.55570468  8.050730e-01  0.997168842 #>  3:  2.722465e+05 1.217492e+07  0.52277934  7.543143e-01  0.932723128 #>  4:  1.178251e+05 5.269045e+06  0.49458634  7.088423e-01  0.875133091 #>  5:  6.487578e+04 2.901111e+06  0.47373257  6.754598e-01  0.830921528 #>  6:  3.877015e+04 1.733656e+06  0.45486979  6.463974e-01  0.793495710 #>  7:  2.184099e+04 9.765835e+05  0.43642729  6.145276e-01  0.750316612 #>  8:  1.769702e+03 7.905382e+04  0.37039742  5.121172e-01  0.613879235 #>  9:  1.554393e+02 6.899914e+03  0.30702403  4.191751e-01  0.498320948 #> 10:  2.124180e+01 9.155072e+02  0.25355821  3.441958e-01  0.409257242 #> 11:  2.703657e+00 9.829930e+01  0.19534270  2.673393e-01  0.313942694 #> 12:  4.946707e-01 7.882626e+00  0.13759600  1.919585e-01  0.226429956 #> 13:  2.127324e-01 7.511158e-01  0.08784638  1.258828e-01  0.149143744 #> 14:  9.736227e-02 1.038614e-01  0.03579496  5.951272e-02  0.073944920 #> 15:  6.908917e-02 8.114498e-02  0.02083063  3.975103e-02  0.050954836 #> 16:  1.663871e-02 4.232285e-02 -0.01257150 -3.309048e-04  0.005872379 #> 17: -2.704108e-02 2.481974e-02 -0.04807477 -3.676463e-02 -0.033773947 #> 18: -6.172460e-02 1.923180e-02 -0.08341394 -7.184028e-02 -0.067032351 #> 19: -9.027904e-02 1.984237e-02 -0.12074498 -1.023744e-01 -0.094754216 #> 20: -1.128153e-01 2.311219e-02 -0.15283378 -1.265397e-01 -0.117051935 #> 21: -1.287904e-01 2.643434e-02 -0.17554591 -1.440100e-01 -0.132560288 #> 22: -1.382859e-01 2.857151e-02 -0.18870294 -1.542751e-01 -0.141678833 #> 23: -1.414294e-01 2.913395e-02 -0.19381130 -1.574029e-01 -0.144619709 #> 24: -1.438113e-01 2.957977e-02 -0.19686693 -1.597633e-01 -0.146864188 #> 25: -1.455598e-01 2.983917e-02 -0.19878667 -1.612969e-01 -0.148241398 #> 26: -1.459510e-01 2.962394e-02 -0.19847596 -1.615414e-01 -0.148490508 #> 27: -1.462625e-01 2.934398e-02 -0.19881052 -1.617640e-01 -0.148861473 #> 28: -1.474050e-01 2.940003e-02 -0.19992816 -1.629218e-01 -0.150447729 #> 29: -1.492236e-01 2.992486e-02 -0.20285470 -1.652360e-01 -0.152137381 #> 30: -1.530996e-01 3.104675e-02 -0.20843333 -1.701434e-01 -0.155804872 #> 31: -1.533867e-01 3.109742e-02 -0.20893855 -1.706623e-01 -0.156054776 #> 32: -1.536564e-01 3.115360e-02 -0.20896861 -1.711389e-01 -0.156445480 #> 33: -1.537090e-01 3.117410e-02 -0.20902626 -1.710105e-01 -0.156455463 #> 34: -1.538747e-01 3.121500e-02 -0.20861688 -1.709708e-01 -0.156536808 #> 35: -1.539389e-01 3.123158e-02 -0.20817055 -1.710110e-01 -0.156702143 #> 36: -1.540843e-01 3.125497e-02 -0.20800413 -1.714472e-01 -0.157018675 #> 37: -1.540451e-01 3.123344e-02 -0.20778548 -1.715002e-01 -0.156827696 #> 38:  2.254263e+06 1.008134e+08  0.56660118  8.854395e-01  1.122092879 #> 39:  1.074255e+06 4.804189e+07  0.54926382  8.484891e-01  1.060103935 #> 40:  4.336344e+05 1.939252e+07  0.51874831  7.933470e-01  0.984489149 #> 41:  1.911112e+05 8.546591e+06  0.49362863  7.465356e-01  0.922166235 #> 42:  1.010114e+05 4.517225e+06  0.47321296  7.110830e-01  0.877974827 #> 43:  5.520840e+04 2.468872e+06  0.45622927  6.802797e-01  0.837858959 #> 44:  2.746808e+04 1.228304e+06  0.43740713  6.471194e-01  0.792714009 #> 45:  2.030190e+03 9.072976e+04  0.37125636  5.360071e-01  0.643104168 #> 46:  1.593142e+02 7.083625e+03  0.30836225  4.349895e-01  0.517883161 #> 47:  1.914169e+01 8.264206e+02  0.25620819  3.561036e-01  0.421304172 #> 48:  2.238965e+00 7.944210e+01  0.19801449  2.755033e-01  0.323726740 #> 49:  4.365966e-01 5.866962e+00  0.14232354  1.979603e-01  0.230477143 #> 50:  2.048353e-01 5.129128e-01  0.09115761  1.311484e-01  0.151609607 #> 51:  9.735149e-02 6.667917e-02  0.03712914  6.272793e-02  0.074965262 #> 52:  6.924237e-02 4.966919e-02  0.02184517  4.184734e-02  0.051438762 #> 53:  1.717000e-02 3.177905e-02 -0.01389499  2.966246e-05  0.005895856 #> 54: -2.666652e-02 2.181695e-02 -0.04811251 -3.685792e-02 -0.033646145 #> 55: -6.159394e-02 1.795412e-02 -0.08389909 -7.117714e-02 -0.066650058 #> 56: -9.037847e-02 1.866077e-02 -0.12036168 -1.009333e-01 -0.093945716 #> 57: -1.131183e-01 2.181266e-02 -0.15169695 -1.249576e-01 -0.116313696 #> 58: -1.293074e-01 2.515765e-02 -0.17477707 -1.424165e-01 -0.132281901 #> 59: -1.389954e-01 2.744620e-02 -0.19013652 -1.529991e-01 -0.142122384 #> 60: -1.421948e-01 2.809803e-02 -0.19592241 -1.568498e-01 -0.144998540 #> 61: -1.446374e-01 2.866370e-02 -0.19935359 -1.593521e-01 -0.147509268 #> 62: -1.464746e-01 2.910449e-02 -0.20168507 -1.611513e-01 -0.149301134 #> 63: -1.469423e-01 2.906001e-02 -0.20266002 -1.614596e-01 -0.149902312 #> 64: -1.473202e-01 2.892276e-02 -0.20207036 -1.616344e-01 -0.150660811 #> 65: -1.484704e-01 2.902626e-02 -0.20354295 -1.632324e-01 -0.151802467 #> 66: -1.502757e-01 2.950609e-02 -0.20677870 -1.653237e-01 -0.153541922 #> 67: -1.542466e-01 3.073827e-02 -0.21221744 -1.700408e-01 -0.157573549 #> 68: -1.545503e-01 3.085905e-02 -0.21219037 -1.703263e-01 -0.157955243 #> 69: -1.548224e-01 3.097448e-02 -0.21261484 -1.701591e-01 -0.158418582 #> 70: -1.548634e-01 3.104892e-02 -0.21284916 -1.701294e-01 -0.158339700 #> 71: -1.550040e-01 3.113487e-02 -0.21326190 -1.701766e-01 -0.158040551 #> 72: -1.550320e-01 3.119075e-02 -0.21330271 -1.703822e-01 -0.158312928 #> 73: -1.551338e-01 3.124443e-02 -0.21260666 -1.707533e-01 -0.158442891 #> 74: -1.550463e-01 3.124343e-02 -0.21182131 -1.709531e-01 -0.158286359 #>              mean           sd    lower_90      lower_50     lower_20 #>        upper_20    upper_50     upper_90 #>  1:  1.50645798  2.29019686  9.449989798 #>  2:  1.41293713  2.12979336  8.338859953 #>  3:  1.30581765  1.94188567  7.276965955 #>  4:  1.20927779  1.79265942  6.368428612 #>  5:  1.14396353  1.68082695  5.824944065 #>  6:  1.08810811  1.57786709  5.342746480 #>  7:  1.02562875  1.47005329  4.751474284 #>  8:  0.82057726  1.11756476  3.254794760 #>  9:  0.64627651  0.84296886  2.177290873 #> 10:  0.52198866  0.65793723  1.526914603 #> 11:  0.39438102  0.48792182  0.994209076 #> 12:  0.27730281  0.33817279  0.612516019 #> 13:  0.18205371  0.22116450  0.370192882 #> 14:  0.09377157  0.11263980  0.187680888 #> 15:  0.06589678  0.08217060  0.143284495 #> 16:  0.01449587  0.02400846  0.067317246 #> 17: -0.02950850 -0.02271607  0.008732777 #> 18: -0.06092383 -0.05549159 -0.031917869 #> 19: -0.08653839 -0.07954362 -0.060440282 #> 20: -0.10600578 -0.09831405 -0.079763814 #> 21: -0.12009591 -0.11117417 -0.090633663 #> 22: -0.12861237 -0.11890998 -0.097977241 #> 23: -0.13137602 -0.12172022 -0.100624683 #> 24: -0.13397418 -0.12400818 -0.102832606 #> 25: -0.13561489 -0.12566425 -0.104687545 #> 26: -0.13630143 -0.12610491 -0.104913848 #> 27: -0.13660142 -0.12630160 -0.106078027 #> 28: -0.13753676 -0.12732374 -0.106966656 #> 29: -0.13906892 -0.12853999 -0.107486092 #> 30: -0.14274261 -0.13177272 -0.109983633 #> 31: -0.14315327 -0.13185991 -0.110682352 #> 32: -0.14339733 -0.13212112 -0.111067397 #> 33: -0.14309718 -0.13236452 -0.111044977 #> 34: -0.14292984 -0.13245784 -0.111428871 #> 35: -0.14310462 -0.13256586 -0.111586932 #> 36: -0.14325818 -0.13246853 -0.111694619 #> 37: -0.14337413 -0.13244797 -0.111417693 #> 38:  1.60040493  2.30411330  9.263264738 #> 39:  1.50125571  2.13469321  8.295530527 #> 40:  1.37892612  1.94119352  7.202458896 #> 41:  1.28014455  1.77509258  6.261141673 #> 42:  1.21483009  1.65694595  5.670733786 #> 43:  1.15114202  1.56232435  5.277606915 #> 44:  1.07897363  1.45267521  4.680365779 #> 45:  0.85917099  1.11796900  3.170821437 #> 46:  0.67006241  0.85592387  2.130832937 #> 47:  0.53481284  0.66814785  1.490112841 #> 48:  0.40130641  0.49765729  0.979231204 #> 49:  0.28126303  0.34256925  0.612722304 #> 50:  0.18462881  0.22335248  0.367724108 #> 51:  0.09436161  0.11617845  0.197154288 #> 52:  0.06694291  0.08447738  0.148617176 #> 53:  0.01513167  0.02620533  0.068396737 #> 54: -0.02879495 -0.02180771  0.008251830 #> 55: -0.06097468 -0.05562836 -0.031705922 #> 56: -0.08676042 -0.07999214 -0.061264230 #> 57: -0.10668377 -0.09904119 -0.081851498 #> 58: -0.12065529 -0.11242525 -0.094231184 #> 59: -0.12967774 -0.12035089 -0.101787906 #> 60: -0.13249698 -0.12298038 -0.104435177 #> 61: -0.13481384 -0.12486642 -0.106127978 #> 62: -0.13618027 -0.12625503 -0.107601054 #> 63: -0.13652554 -0.12687531 -0.108135371 #> 64: -0.13702121 -0.12704169 -0.108830931 #> 65: -0.13802260 -0.12826443 -0.109743694 #> 66: -0.13953156 -0.12948230 -0.110604813 #> 67: -0.14303953 -0.13280748 -0.113047079 #> 68: -0.14339492 -0.13298174 -0.113330401 #> 69: -0.14362094 -0.13343478 -0.113724646 #> 70: -0.14358420 -0.13352624 -0.113354440 #> 71: -0.14375046 -0.13350080 -0.113070836 #> 72: -0.14382581 -0.13343994 -0.112927580 #> 73: -0.14408388 -0.13364112 -0.113170159 #> 74: -0.14384262 -0.13353202 -0.113627830 #>        upper_20    upper_50     upper_90 #>  #> $summarised_measures$cases_by_infection #>       region       date strat                           type median   mean #>  1: realland 2020-02-22  <NA>                       estimate 1585.0 1567.6 #>  2: realland 2020-02-23  <NA>                       estimate 1845.4 1827.5 #>  3: realland 2020-02-24  <NA>                       estimate 2063.6 2046.3 #>  4: realland 2020-02-25  <NA>                       estimate 2324.5 2307.2 #>  5: realland 2020-02-26  <NA>                       estimate 2650.9 2635.2 #>  6: realland 2020-02-27  <NA>                       estimate 3024.8 3012.1 #>  7: realland 2020-02-28  <NA>                       estimate 3405.3 3398.2 #>  8: realland 2020-02-29  <NA>                       estimate 3301.0 3301.6 #>  9: realland 2020-03-01  <NA>                       estimate 3173.6 3181.2 #> 10: realland 2020-03-02  <NA>                       estimate 3106.1 3120.3 #> 11: realland 2020-03-03  <NA>                       estimate 2941.5 2960.8 #> 12: realland 2020-03-04  <NA>                       estimate 2754.5 2776.8 #> 13: realland 2020-03-05  <NA>                       estimate 2572.8 2598.3 #> 14: realland 2020-03-06  <NA>                       estimate 2323.6 2349.5 #> 15: realland 2020-03-07  <NA> estimate based on partial data 2415.3 2444.6 #> 16: realland 2020-03-08  <NA> estimate based on partial data 2282.1 2311.3 #> 17: realland 2020-03-09  <NA> estimate based on partial data 2155.1 2184.1 #> 18: realland 2020-03-10  <NA> estimate based on partial data 2033.8 2063.2 #> 19: realland 2020-03-11  <NA> estimate based on partial data 1920.1 1948.7 #> 20: realland 2020-03-12  <NA> estimate based on partial data 1812.9 1839.7 #> 21: realland 2020-03-13  <NA> estimate based on partial data 1712.7 1737.4 #> 22: realland 2020-03-14  <NA> estimate based on partial data 1616.8 1639.9 #> 23: realland 2020-03-15  <NA> estimate based on partial data 1525.7 1547.3 #> 24: realland 2020-03-16  <NA> estimate based on partial data 1439.7 1459.6 #> 25: realland 2020-03-17  <NA> estimate based on partial data 1359.2 1377.0 #> 26: realland 2020-03-18  <NA> estimate based on partial data 1282.6 1298.5 #> 27: realland 2020-03-19  <NA> estimate based on partial data 1211.2 1225.1 #> 28: realland 2020-03-20  <NA> estimate based on partial data 1142.6 1154.8 #> 29: realland 2020-03-21  <NA> estimate based on partial data 1078.8 1089.8 #> 30: realland 2020-03-22  <NA> estimate based on partial data 1018.5 1027.9 #> 31: realland 2020-03-23  <NA>                       forecast  961.3  969.2 #> 32: realland 2020-03-24  <NA>                       forecast  906.9  913.7 #> 33: realland 2020-03-25  <NA>                       forecast  856.8  862.3 #> 34: realland 2020-03-26  <NA>                       forecast  808.6  813.1 #> 35: realland 2020-03-27  <NA>                       forecast  763.4  767.1 #> 36: realland 2020-03-28  <NA>                       forecast  720.2  723.2 #> 37: realland 2020-03-29  <NA>                       forecast  680.1  682.5 #> 38: testland 2020-02-22  <NA>                       estimate 1586.3 1568.8 #> 39: testland 2020-02-23  <NA>                       estimate 1847.0 1829.1 #> 40: testland 2020-02-24  <NA>                       estimate 2065.5 2048.5 #> 41: testland 2020-02-25  <NA>                       estimate 2325.7 2309.9 #> 42: testland 2020-02-26  <NA>                       estimate 2651.8 2638.8 #> 43: testland 2020-02-27  <NA>                       estimate 3024.9 3016.5 #> 44: testland 2020-02-28  <NA>                       estimate 3405.6 3403.7 #> 45: testland 2020-02-29  <NA>                       estimate 3301.2 3307.3 #> 46: testland 2020-03-01  <NA>                       estimate 3174.3 3187.1 #> 47: testland 2020-03-02  <NA>                       estimate 3107.2 3126.5 #> 48: testland 2020-03-03  <NA>                       estimate 2943.3 2967.0 #> 49: testland 2020-03-04  <NA>                       estimate 2756.0 2782.8 #> 50: testland 2020-03-05  <NA>                       estimate 2575.4 2604.2 #> 51: testland 2020-03-06  <NA>                       estimate 2326.7 2354.9 #> 52: testland 2020-03-07  <NA> estimate based on partial data 2419.0 2450.2 #> 53: testland 2020-03-08  <NA> estimate based on partial data 2286.1 2316.5 #> 54: testland 2020-03-09  <NA> estimate based on partial data 2159.1 2188.9 #> 55: testland 2020-03-10  <NA> estimate based on partial data 2038.8 2067.6 #> 56: testland 2020-03-11  <NA> estimate based on partial data 1924.9 1952.6 #> 57: testland 2020-03-12  <NA> estimate based on partial data 1816.0 1843.2 #> 58: testland 2020-03-13  <NA> estimate based on partial data 1715.4 1740.4 #> 59: testland 2020-03-14  <NA> estimate based on partial data 1620.3 1642.5 #> 60: testland 2020-03-15  <NA> estimate based on partial data 1529.5 1549.4 #> 61: testland 2020-03-16  <NA> estimate based on partial data 1442.9 1461.4 #> 62: testland 2020-03-17  <NA> estimate based on partial data 1361.8 1378.5 #> 63: testland 2020-03-18  <NA> estimate based on partial data 1285.0 1299.7 #> 64: testland 2020-03-19  <NA> estimate based on partial data 1212.6 1226.1 #> 65: testland 2020-03-20  <NA> estimate based on partial data 1143.9 1155.7 #> 66: testland 2020-03-21  <NA> estimate based on partial data 1080.2 1090.5 #> 67: testland 2020-03-22  <NA> estimate based on partial data 1019.7 1028.6 #> 68: testland 2020-03-23  <NA>                       forecast  961.9  969.9 #> 69: testland 2020-03-24  <NA>                       forecast  907.2  914.5 #> 70: testland 2020-03-25  <NA>                       forecast  857.0  863.3 #> 71: testland 2020-03-26  <NA>                       forecast  808.6  814.2 #> 72: testland 2020-03-27  <NA>                       forecast  763.4  768.3 #> 73: testland 2020-03-28  <NA>                       forecast  720.4  724.6 #> 74: testland 2020-03-29  <NA>                       forecast  680.3  683.9 #>       region       date strat                           type median   mean #>        sd lower_90 lower_50 lower_20 upper_20 upper_50 upper_90 #>  1:  89.0   1405.0   1537.1   1571.9   1593.1   1609.1   1682.1 #>  2: 101.4   1642.9   1793.5   1830.3   1854.4   1874.4   1964.2 #>  3: 111.0   1844.1   2009.5   2048.9   2072.8   2096.3   2204.3 #>  4: 122.4   2084.6   2263.5   2307.9   2333.6   2361.6   2483.0 #>  5: 137.0   2397.0   2587.3   2634.3   2661.6   2692.8   2836.3 #>  6: 154.0   2747.2   2953.4   3007.2   3037.0   3076.5   3242.2 #>  7: 171.8   3113.9   3331.7   3386.3   3419.5   3465.5   3664.7 #>  8: 166.1   3033.5   3235.8   3286.4   3317.7   3365.6   3573.2 #>  9: 160.5   2931.5   3115.2   3160.8   3190.3   3244.3   3444.3 #> 10: 159.3   2884.0   3054.2   3094.1   3125.4   3178.0   3380.9 #> 11: 154.1   2741.2   2896.6   2930.7   2960.8   3014.3   3221.5 #> 12: 148.2   2571.9   2712.5   2743.1   2774.7   2824.2   3034.6 #> 13: 142.7   2402.1   2535.7   2562.6   2593.7   2640.9   2855.9 #> 14: 132.8   2172.4   2290.5   2314.0   2342.6   2387.5   2593.9 #> 15: 142.1   2260.9   2380.3   2405.0   2435.2   2486.1   2712.9 #> 16: 137.7   2141.3   2249.8   2271.2   2300.5   2349.3   2569.0 #> 17: 132.7   2014.8   2125.1   2144.5   2172.5   2221.5   2432.5 #> 18: 127.3   1899.9   2007.4   2024.6   2051.6   2100.4   2297.7 #> 19: 121.6   1792.9   1894.1   1911.9   1936.7   1986.6   2171.4 #> 20: 115.5   1693.3   1787.8   1804.6   1829.0   1871.1   2052.1 #> 21: 109.4   1599.9   1689.9   1704.5   1727.4   1767.6   1934.6 #> 22: 103.2   1511.7   1594.2   1609.5   1630.2   1667.6   1825.0 #> 23:  97.1   1427.8   1504.7   1519.3   1538.6   1574.4   1724.1 #> 24:  91.0   1347.4   1419.5   1433.9   1451.2   1484.0   1627.2 #> 25:  85.1   1270.7   1339.2   1353.8   1369.4   1401.1   1534.1 #> 26:  79.4   1197.1   1262.8   1277.9   1292.5   1323.1   1445.2 #> 27:  74.0   1131.2   1191.9   1206.6   1220.4   1247.4   1364.1 #> 28:  68.8   1065.0   1125.1   1138.2   1151.4   1177.3   1283.1 #> 29:  64.1   1003.4   1062.6   1074.6   1087.4   1110.5   1210.2 #> 30:  59.6    946.3   1002.0   1014.6   1025.9   1046.9   1140.7 #> 31:  55.4    890.2    945.2    957.3    968.3    988.4   1072.9 #> 32:  51.6    839.5    891.3    903.3    913.5    931.8   1008.8 #> 33:  48.0    790.2    841.8    853.3    862.5    879.2    950.2 #> 34:  44.7    745.4    794.0    805.5    814.0    829.1    894.2 #> 35:  41.6    702.6    749.2    760.6    768.1    781.8    841.3 #> 36:  38.8    664.3    706.3    717.2    724.4    736.8    793.7 #> 37:  36.2    627.2    667.1    677.1    683.7    695.7    748.5 #> 38:  92.2   1391.6   1535.3   1571.6   1593.5   1610.1   1691.7 #> 39: 106.0   1633.2   1791.3   1831.0   1854.9   1874.4   1971.6 #> 40: 116.7   1844.5   2007.6   2047.8   2073.9   2096.4   2211.4 #> 41: 129.4   2089.9   2265.7   2308.9   2334.1   2362.4   2492.2 #> 42: 145.5   2397.6   2585.6   2635.6   2660.7   2693.4   2853.7 #> 43: 164.1   2751.7   2953.7   3008.6   3036.2   3074.9   3264.2 #> 44: 183.4   3117.8   3334.5   3389.6   3418.6   3466.8   3692.0 #> 45: 177.5   3031.9   3236.9   3287.8   3317.7   3365.6   3600.0 #> 46: 171.4   2926.7   3118.3   3161.2   3192.0   3243.2   3481.5 #> 47: 169.6   2887.1   3055.8   3095.1   3126.7   3180.6   3425.6 #> 48: 163.1   2745.7   2897.0   2931.9   2963.5   3016.6   3255.8 #> 49: 155.4   2579.8   2715.3   2745.0   2776.1   2829.9   3055.4 #> 50: 147.9   2417.4   2538.7   2565.1   2597.5   2649.1   2867.5 #> 51: 135.6   2188.6   2294.8   2315.9   2346.7   2394.5   2595.9 #> 52: 142.6   2276.4   2386.6   2406.3   2441.3   2493.9   2703.6 #> 53: 135.6   2154.9   2255.0   2272.7   2307.9   2358.2   2554.4 #> 54: 128.4   2037.1   2129.5   2146.1   2178.7   2228.8   2421.8 #> 55: 121.1   1924.4   2011.5   2026.5   2058.2   2104.2   2293.0 #> 56: 114.0   1817.7   1899.3   1912.9   1942.1   1984.6   2172.7 #> 57: 107.2   1713.8   1793.5   1806.3   1833.6   1875.0   2044.9 #> 58: 101.0   1616.6   1692.4   1706.6   1733.1   1770.3   1925.3 #> 59:  95.1   1525.5   1598.4   1611.1   1636.0   1671.6   1816.3 #> 60:  89.6   1438.1   1508.7   1520.8   1543.2   1576.5   1711.4 #> 61:  84.4   1352.9   1423.5   1435.7   1456.1   1486.9   1612.6 #> 62:  79.5   1271.9   1343.2   1355.2   1373.9   1402.3   1521.0 #> 63:  74.7   1196.3   1266.5   1278.7   1295.5   1322.9   1430.3 #> 64:  70.2   1126.7   1194.8   1207.4   1222.8   1249.1   1348.5 #> 65:  65.9   1062.0   1126.8   1139.0   1153.0   1177.2   1275.5 #> 66:  62.0   1004.8   1064.1   1075.6   1088.5   1111.0   1204.0 #> 67:  58.4    948.5   1004.0   1015.5   1027.2   1047.5   1135.6 #> 68:  55.1    893.2    947.1    958.0    968.5    987.9   1071.7 #> 69:  52.0    839.7    892.8    903.9    913.6    931.0   1010.7 #> 70:  49.2    792.2    843.6    853.4    862.7    879.4    954.7 #> 71:  46.4    745.6    795.6    805.5    813.8    829.6    901.4 #> 72:  43.7    705.2    750.6    760.5    768.4    783.0    848.6 #> 73:  41.1    663.4    708.0    717.5    724.7    738.5    800.8 #> 74:  38.6    625.6    668.7    677.3    684.2    697.1    755.6 #>        sd lower_90 lower_50 lower_20 upper_20 upper_50 upper_90 #>  #> $summarised_measures$cases_by_report #>       region       date strat                           type median   mean #>  1: realland 2020-02-22  <NA>                       estimate  204.0  322.2 #>  2: realland 2020-02-23  <NA>                       estimate  311.0  497.9 #>  3: realland 2020-02-24  <NA>                       estimate  227.5  352.3 #>  4: realland 2020-02-25  <NA>                       estimate  308.0  509.3 #>  5: realland 2020-02-26  <NA>                       estimate  313.0  493.2 #>  6: realland 2020-02-27  <NA>                       estimate  478.5  734.0 #>  7: realland 2020-02-28  <NA>                       estimate  687.0 1057.1 #>  8: realland 2020-02-29  <NA>                       estimate  704.0 1095.4 #>  9: realland 2020-03-01  <NA>                       estimate  956.0 1458.1 #> 10: realland 2020-03-02  <NA>                       estimate  652.5 1073.1 #> 11: realland 2020-03-03  <NA>                       estimate  870.5 1427.5 #> 12: realland 2020-03-04  <NA>                       estimate  801.0 1337.0 #> 13: realland 2020-03-05  <NA>                       estimate 1282.0 2057.3 #> 14: realland 2020-03-06  <NA>                       estimate 1538.5 2358.3 #> 15: realland 2020-03-07  <NA> estimate based on partial data 1460.5 2269.4 #> 16: realland 2020-03-08  <NA> estimate based on partial data 1833.5 2927.3 #> 17: realland 2020-03-09  <NA> estimate based on partial data 1123.0 1830.9 #> 18: realland 2020-03-10  <NA> estimate based on partial data 1305.0 2186.7 #> 19: realland 2020-03-11  <NA> estimate based on partial data 1156.5 1882.2 #> 20: realland 2020-03-12  <NA> estimate based on partial data 1556.5 2419.8 #> 21: realland 2020-03-13  <NA> estimate based on partial data 1801.0 2749.8 #> 22: realland 2020-03-14  <NA> estimate based on partial data 1575.5 2522.0 #> 23: realland 2020-03-15  <NA> estimate based on partial data 1867.5 2966.0 #> 24: realland 2020-03-16  <NA> estimate based on partial data 1095.0 1755.5 #> 25: realland 2020-03-17  <NA> estimate based on partial data 1228.0 1993.1 #> 26: realland 2020-03-18  <NA> estimate based on partial data 1034.0 1714.1 #> 27: realland 2020-03-19  <NA> estimate based on partial data 1338.0 2226.8 #> 28: realland 2020-03-20  <NA> estimate based on partial data 1539.0 2530.5 #> 29: realland 2020-03-21  <NA> estimate based on partial data 1352.5 2176.8 #> 30: realland 2020-03-22  <NA> estimate based on partial data 1675.0 2449.2 #> 31: realland 2020-03-23  <NA>                       forecast  839.5 1418.6 #> 32: realland 2020-03-24  <NA>                       forecast  968.0 1633.7 #> 33: realland 2020-03-25  <NA>                       forecast  816.0 1329.9 #> 34: realland 2020-03-26  <NA>                       forecast  969.0 1641.5 #> 35: realland 2020-03-27  <NA>                       forecast 1248.5 1934.3 #> 36: realland 2020-03-28  <NA>                       forecast 1069.0 1624.4 #> 37: realland 2020-03-29  <NA>                       forecast 1144.0 1855.7 #> 38: testland 2020-02-22  <NA>                       estimate  213.0  342.9 #> 39: testland 2020-02-23  <NA>                       estimate  301.0  475.0 #> 40: testland 2020-02-24  <NA>                       estimate  203.0  346.4 #> 41: testland 2020-02-25  <NA>                       estimate  308.0  504.1 #> 42: testland 2020-02-26  <NA>                       estimate  321.5  495.8 #> 43: testland 2020-02-27  <NA>                       estimate  446.5  764.0 #> 44: testland 2020-02-28  <NA>                       estimate  696.5 1094.2 #> 45: testland 2020-02-29  <NA>                       estimate  718.5 1137.6 #> 46: testland 2020-03-01  <NA>                       estimate  921.0 1409.1 #> 47: testland 2020-03-02  <NA>                       estimate  635.0 1067.7 #> 48: testland 2020-03-03  <NA>                       estimate  815.5 1389.5 #> 49: testland 2020-03-04  <NA>                       estimate  753.0 1274.2 #> 50: testland 2020-03-05  <NA>                       estimate 1194.0 1856.9 #> 51: testland 2020-03-06  <NA>                       estimate 1589.5 2456.8 #> 52: testland 2020-03-07  <NA> estimate based on partial data 1526.0 2413.5 #> 53: testland 2020-03-08  <NA> estimate based on partial data 1751.0 2810.1 #> 54: testland 2020-03-09  <NA> estimate based on partial data 1121.0 1828.7 #> 55: testland 2020-03-10  <NA> estimate based on partial data 1323.0 2152.4 #> 56: testland 2020-03-11  <NA> estimate based on partial data 1115.5 1862.0 #> 57: testland 2020-03-12  <NA> estimate based on partial data 1567.0 2527.2 #> 58: testland 2020-03-13  <NA> estimate based on partial data 1936.5 3000.5 #> 59: testland 2020-03-14  <NA> estimate based on partial data 1585.0 2525.6 #> 60: testland 2020-03-15  <NA> estimate based on partial data 1912.5 3015.9 #> 61: testland 2020-03-16  <NA> estimate based on partial data 1097.0 1783.1 #> 62: testland 2020-03-17  <NA> estimate based on partial data 1302.0 2046.2 #> 63: testland 2020-03-18  <NA> estimate based on partial data 1036.0 1699.6 #> 64: testland 2020-03-19  <NA> estimate based on partial data 1373.0 2208.6 #> 65: testland 2020-03-20  <NA> estimate based on partial data 1522.0 2367.7 #> 66: testland 2020-03-21  <NA> estimate based on partial data 1419.5 2178.3 #> 67: testland 2020-03-22  <NA> estimate based on partial data 1539.5 2363.4 #> 68: testland 2020-03-23  <NA>                       forecast  848.0 1482.2 #> 69: testland 2020-03-24  <NA>                       forecast  981.5 1600.0 #> 70: testland 2020-03-25  <NA>                       forecast  836.0 1365.5 #> 71: testland 2020-03-26  <NA>                       forecast 1040.0 1694.6 #> 72: testland 2020-03-27  <NA>                       forecast 1192.5 1915.9 #> 73: testland 2020-03-28  <NA>                       forecast 1045.5 1654.0 #> 74: testland 2020-03-29  <NA>                       forecast 1159.5 1851.0 #>       region       date strat                           type median   mean #>         sd lower_90 lower_50 lower_20 upper_20 upper_50 upper_90 #>  1:  366.6     12.9     83.0    149.0    275.4    439.2   1043.2 #>  2:  559.3     19.0    129.0    224.0    430.0    666.5   1528.4 #>  3:  415.5     17.0     92.0    169.0    298.0    437.5   1106.1 #>  4:  603.4     22.0    118.0    222.0    416.4    686.2   1675.1 #>  5:  572.1     21.0    121.0    225.6    423.4    650.5   1605.0 #>  6:  801.0     27.0    185.8    346.0    641.8    991.0   2300.9 #>  7: 1173.4     46.9    277.8    489.6    908.2   1391.0   3294.6 #>  8: 1303.6     49.9    279.0    502.8    910.0   1446.2   3470.5 #>  9: 1692.5     58.9    386.0    683.0   1259.4   1893.8   4573.0 #> 10: 1304.1     40.0    262.8    465.6    891.4   1404.2   3512.1 #> 11: 1710.6     62.8    355.0    644.0   1198.8   1881.8   4656.4 #> 12: 1615.8     51.9    315.5    580.0   1098.0   1693.8   4536.8 #> 13: 2336.0     72.0    492.8    907.6   1728.8   2810.0   6450.5 #> 14: 2531.6     94.9    621.0   1114.8   2038.2   3129.5   7590.4 #> 15: 2580.1     98.9    607.8   1074.2   2000.4   3071.2   6776.0 #> 16: 3267.8    114.9    693.8   1308.6   2518.8   3931.5   9335.4 #> 17: 2169.0     71.9    441.8    801.6   1489.4   2330.8   6211.6 #> 18: 2657.5     86.0    510.0    931.6   1761.6   2768.2   7372.3 #> 19: 2119.6     79.0    468.0    831.6   1577.8   2540.8   6219.4 #> 20: 2810.5    111.9    575.0   1113.2   2064.4   3174.5   7750.8 #> 21: 3111.2    117.0    688.8   1296.6   2399.0   3595.2   8460.7 #> 22: 3014.5     91.0    605.8   1155.2   2100.2   3245.0   8312.8 #> 23: 3516.5    110.9    745.0   1388.0   2500.0   3938.2   9505.6 #> 24: 2134.0     68.9    399.8    767.8   1451.2   2351.0   5615.1 #> 25: 2492.6     78.0    497.0    896.8   1672.8   2583.0   6273.1 #> 26: 2078.0     70.9    420.0    739.6   1436.0   2198.0   5562.1 #> 27: 2749.4     86.9    527.8    980.8   1855.8   2901.8   7283.9 #> 28: 3011.1     82.0    612.0   1093.8   2064.6   3277.5   8339.6 #> 29: 2480.4     98.0    540.0    966.8   1850.8   2973.8   6830.6 #> 30: 2594.3     95.0    648.5   1176.2   2234.4   3379.0   7442.0 #> 31: 1664.0     58.9    325.2    616.2   1149.0   1862.5   4772.1 #> 32: 1884.0     68.9    369.8    694.4   1384.0   2233.0   5387.9 #> 33: 1563.6     51.0    317.0    590.6   1111.4   1731.0   4390.4 #> 34: 1973.2     61.9    375.0    715.0   1356.8   2128.0   5536.4 #> 35: 2146.5     73.0    484.5    910.0   1658.2   2530.0   6284.1 #> 36: 1733.7     71.8    419.2    790.0   1447.0   2198.2   5079.4 #> 37: 2160.7     76.9    442.0    823.6   1549.4   2446.5   5895.0 #> 38:  401.7     16.0     84.0    155.0    287.4    443.2   1068.1 #> 39:  529.4     20.0    112.0    214.6    414.8    647.2   1490.1 #> 40:  431.1     14.0     83.0    149.0    276.4    448.2   1202.0 #> 41:  643.0     20.0    124.0    220.6    408.4    654.2   1617.9 #> 42:  557.8     16.9    124.0    234.0    434.4    658.2   1577.1 #> 43:  930.8     27.0    174.0    323.6    627.8   1018.5   2510.1 #> 44: 1299.6     48.0    274.0    502.0    925.8   1426.2   3463.0 #> 45: 1413.3     48.0    278.0    511.6    958.0   1451.2   3703.2 #> 46: 1609.1     52.9    330.0    646.0   1211.4   1862.8   4447.6 #> 47: 1264.0     43.9    255.0    455.0    880.0   1366.2   3453.5 #> 48: 1619.7     50.0    330.0    590.2   1120.0   1824.2   4617.4 #> 49: 1518.5     55.0    322.0    548.0   1044.8   1599.2   4285.5 #> 50: 2114.6     61.9    443.8    856.0   1625.0   2462.2   5888.5 #> 51: 2711.8    103.9    641.8   1199.0   2181.4   3315.2   7699.9 #> 52: 2683.4    121.8    613.0   1146.6   2044.6   3301.0   7884.0 #> 53: 3385.6    114.0    679.8   1275.2   2413.0   3634.5   8937.7 #> 54: 2270.0     79.0    443.0    780.0   1526.4   2461.2   5707.8 #> 55: 2552.1     93.8    552.8    989.2   1800.4   2823.0   6692.2 #> 56: 2234.1     75.9    476.0    829.0   1550.0   2401.5   6222.1 #> 57: 3076.4     97.9    603.0   1100.2   2068.0   3227.2   8740.3 #> 58: 3373.1    120.8    761.2   1391.4   2562.4   3900.5   9865.8 #> 59: 2912.9     88.8    623.5   1136.2   2152.6   3395.2   7929.1 #> 60: 3407.2    128.0    770.8   1425.6   2578.2   3969.0   9778.0 #> 61: 2228.7     71.9    418.8    802.2   1449.0   2258.2   5743.6 #> 62: 2353.7     84.0    533.0    936.6   1734.4   2673.2   6715.2 #> 63: 2009.7     67.9    433.5    767.8   1388.0   2264.0   5526.4 #> 64: 2662.9     85.8    526.8    978.6   1867.0   2845.8   7172.3 #> 65: 2663.0     92.9    610.0   1100.0   2022.4   3193.0   7194.6 #> 66: 2454.3     96.0    593.8   1025.0   1870.8   2820.8   6820.3 #> 67: 2673.4     90.9    583.2   1094.6   2034.8   3144.5   7586.5 #> 68: 1850.1     56.9    344.0    609.6   1152.0   1905.0   5075.3 #> 69: 1842.0     50.0    398.8    730.6   1352.4   2162.5   5058.9 #> 70: 1640.2     50.9    348.8    608.2   1126.0   1763.0   4490.0 #> 71: 2047.4     67.9    403.5    748.2   1437.2   2161.5   5712.2 #> 72: 2197.0     87.9    510.8    898.2   1600.0   2523.8   6022.0 #> 73: 1930.6     72.9    412.0    739.0   1376.2   2190.8   5382.4 #> 74: 2111.6     74.9    486.8    844.2   1534.8   2506.2   5843.6 #>         sd lower_90 lower_50 lower_20 upper_20 upper_50 upper_90 #>  #>  #> $reported_cases #>           date confirm   region #>  1: 2020-02-22      14 testland #>  2: 2020-02-23      62 testland #>  3: 2020-02-24      53 testland #>  4: 2020-02-25      97 testland #>  5: 2020-02-26      93 testland #>  6: 2020-02-27      78 testland #>  7: 2020-02-28     250 testland #>  8: 2020-02-29     238 testland #>  9: 2020-03-01     240 testland #> 10: 2020-03-02     561 testland #> 11: 2020-03-03     347 testland #> 12: 2020-03-04     466 testland #> 13: 2020-03-05     587 testland #> 14: 2020-03-06     769 testland #> 15: 2020-03-07     778 testland #> 16: 2020-03-08    1247 testland #> 17: 2020-03-09    1492 testland #> 18: 2020-03-10    1797 testland #> 19: 2020-03-11     977 testland #> 20: 2020-03-12    2313 testland #> 21: 2020-03-13    2651 testland #> 22: 2020-03-14    2547 testland #> 23: 2020-03-15    3497 testland #> 24: 2020-03-16    2823 testland #> 25: 2020-03-17    4000 testland #> 26: 2020-03-18    3526 testland #> 27: 2020-03-19    4207 testland #> 28: 2020-03-20    5322 testland #> 29: 2020-03-21    5986 testland #> 30: 2020-03-22    6557 testland #> 31: 2020-02-22      14 realland #> 32: 2020-02-23      62 realland #> 33: 2020-02-24      53 realland #> 34: 2020-02-25      97 realland #> 35: 2020-02-26      93 realland #> 36: 2020-02-27      78 realland #> 37: 2020-02-28     250 realland #> 38: 2020-02-29     238 realland #> 39: 2020-03-01     240 realland #> 40: 2020-03-02     561 realland #> 41: 2020-03-03     347 realland #> 42: 2020-03-04     466 realland #> 43: 2020-03-05     587 realland #> 44: 2020-03-06     769 realland #> 45: 2020-03-07     778 realland #> 46: 2020-03-08    1247 realland #> 47: 2020-03-09    1492 realland #> 48: 2020-03-10    1797 realland #> 49: 2020-03-11     977 realland #> 50: 2020-03-12    2313 realland #> 51: 2020-03-13    2651 realland #> 52: 2020-03-14    2547 realland #> 53: 2020-03-15    3497 realland #> 54: 2020-03-16    2823 realland #> 55: 2020-03-17    4000 realland #> 56: 2020-03-18    3526 realland #> 57: 2020-03-19    4207 realland #> 58: 2020-03-20    5322 realland #> 59: 2020-03-21    5986 realland #> 60: 2020-03-22    6557 realland #>           date confirm   region #>  #> $high_plots #> $high_plots$infections  #>  #> $high_plots$reports  #>  #> $high_plots$R  #>  #> $high_plots$growth_rate  #>  #>  #> $plots #> $plots$infections  #>  #> $plots$reports  #>  #> $plots$R  #>  #> $plots$growth_rate  #>  #>  # }"},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Report case counts by date of report — report_cases","title":"Report case counts by date of report — report_cases","text":"Convolves latent infections reported cases via observation model. Likely removed/replaced later releases functionality drawing stan implementation.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report case counts by date of report — report_cases","text":"","code":"report_cases(   case_estimates,   case_forecast = NULL,   delays,   type = \"sample\",   reporting_effect,   CrIs = c(0.2, 0.5, 0.9) )"},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report case counts by date of report — report_cases","text":"case_estimates data.table case estimates following variables: date, sample, cases case_forecast data.table case forecasts following variables: date, sample, cases. supplied default incorporate forecasts. delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. type Character string indicating method use transform counts. Supports either \"sample\" approximates sampling \"median\" shift median distribution. reporting_effect data.table giving weekly reporting effect following variables: sample (must nowcast), effect (numeric scaling factor weekday),day (numeric 1 - 7 (1 = Monday 7 = Sunday)). supplied weekly reporting effect assumed. CrIs Numeric vector credible intervals calculate.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report case counts by date of report — report_cases","text":"list data.tables. first entry contains following variables sample, date cases second summarised across samples.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_cases.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report case counts by date of report — report_cases","text":"","code":"# \\donttest{ # define example cases cases <- example_confirmed[1:40]  # set up example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1), mean_sd = 0.1,   sd = convert_to_logsd(2, 1), sd_sd = 0.1, max = 10 )  # run model out <- estimate_infections(cases,   stan = stan_opts(samples = 100),   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = NULL ) #> Warning: The largest R-hat is 1.19, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess  reported_cases <- report_cases(   case_estimates =     out$samples[variable == \"infections\"][       ,       cases := as.integer(value)     ][, value := NULL],   delays = delay_opts(incubation_period, reporting_delay),   type = \"sample\" ) #> Error in purrr::map(delays, ~EpiNow2::lognorm_dist_def(mean = .$mean,     mean_sd = .$mean_sd, sd = .$sd, sd_sd = .$sd_sd, max_value = .$max,     samples = samples)): ℹ In index: 1. #> ℹ With name: delays. #> Caused by error in `.$mean`: #> ! $ operator is invalid for atomic vectors print(reported_cases) #> Error in print(reported_cases): object 'reported_cases' not found # }"},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":null,"dir":"Reference","previous_headings":"","what":"Report plots — report_plots","title":"Report plots — report_plots","text":"Returns key summary plots estimates. May depreciated later releases current S3 methods enhanced.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report plots — report_plots","text":"","code":"report_plots(summarised_estimates, reported, target_folder = NULL, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report plots — report_plots","text":"summarised_estimates data.table summarised estimates containing following variables: variable, median, bottom, top. also contain following estimates: R, infections, reported_cases_rt, r (rate growth). reported data.table reported cases following variables: date, confirm. target_folder Character string specifying save results (create present). ... Additional arguments passed plot_estimates().","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report plots — report_plots","text":"named list ggplot2 objects, list(infections, reports, R, growth_rate, summary), correspond summary combination (last item) leading items @seealso plot_estimates() summarised_estimates[variable == \"infections\"], summarised_estimates[variable == \"reported_cases\"], summarised_estimates[variable == \"R\"], summarised_estimates[variable == \"growth_rate\"], respectively.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_plots.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report plots — report_plots","text":"","code":"# \\donttest{ # define example cases cases <- example_confirmed[1:40]  # set up example delays generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- bootstrapped_dist_fit(rlnorm(100, log(6), 1), max_value = 30)  # run model out <- estimate_infections(cases,   samples = 100,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = NULL ) #> Error in estimate_infections(cases, samples = 100, generation_time = generation_time,     delays = delay_opts(incubation_period, reporting_delay),     rt = NULL): unused argument (samples = 100)  # plot infections plots <- report_plots(   summarised_estimates = out$summarised,   reported = cases ) #> Error in data.table::setDT(summarised_estimates): object 'out' not found plots #> Error in eval(expr, envir, enclos): object 'plots' not found # }"},{"path":"epiforecasts.io/EpiNow2/reference/report_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","title":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","text":"Creates snapshot summary estimates. May removed later releases S3 methods enhanced.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","text":"","code":"report_summary(   summarised_estimates,   rt_samples,   target_folder = NULL,   return_numeric = FALSE )"},{"path":"epiforecasts.io/EpiNow2/reference/report_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","text":"summarised_estimates data.table summarised estimates containing following variables: variable, median, bottom, top. contain following estimates: R, infections, r (rate growth). rt_samples data.table containing Rt samples following variables: sample value. target_folder Character string specifying save results (create present). return_numeric numeric summary information returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/report_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provide Summary Statistics for Estimated Infections and Rt — report_summary","text":"data.table containing formatted numeric summary measures","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Rstan Options — rstan_opts","title":"Rstan Options — rstan_opts","text":"Defines list specifying arguments passed underlying rstan functions via rstan_sampling_opts() rstan_vb_opts().Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rstan Options — rstan_opts","text":"","code":"rstan_opts(object = NULL, samples = 2000, method = \"sampling\", ...)"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rstan Options — rstan_opts","text":"object Stan model object. default uses compiled package default. samples Numeric, default 2000. Overall number posterior samples. using multiple chains iterations per chain samples / chains. method character string, defaulting sampling. Currently supports rstan::sampling (\"sampling\") rstan:vb (\"vb\"). ... Additional parameters pass  underlying option functions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rstan Options — rstan_opts","text":"list arguments pass appropriate rstan functions.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/rstan_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rstan Options — rstan_opts","text":"","code":"rstan_opts(samples = 1000) #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // discretised truncated gamma pmf #> vector discretised_gamma_pmf(real mu, real sigma, int max_val) { #>   int n = max_val; #>   vector[n+1] upper_cdf; #>   vector[n] pmf; #>   // calculate alpha and beta for gamma distribution #>   real small = 1e-5; #>   real large = 1e8; #>   real c_sigma = fmax(small, sigma); #>   real c_mu = fmax(small, mu); #>   real alpha = ((c_mu) / c_sigma)^2; #>   real beta = (c_mu) / (c_sigma^2); #>   // account for numerical issues #>   alpha = fmax(small, alpha); #>   alpha = fmin(large, alpha); #>   beta = fmax(small, beta); #>   beta = fmin(large, beta); #>   // calculate pmf #>   for (i in 1:(n+1)) { #>     upper_cdf[i] = gamma_cdf(i,  alpha, beta); #>   } #>   // discretise #>   for (i in 1:n) { #>     pmf[n+1-i] = upper_cdf[i+1] - upper_cdf[i]; #>   } #>   pmf = pmf / (upper_cdf[n+1] - upper_cdf[1]); #>   return(pmf); #> } #>  #> // discretised truncated lognormal pmf #> vector discretised_lognormal_pmf(real mu, real sigma, int max_val, int rev) { #>   int n = max_val; #>   vector[n] upper_cdf; #>   vector[n] pmf; #>   for (i in 1:n) { #>     upper_cdf[i] = lognormal_cdf(i,  mu, sigma); #>   } #>   // discretise #>   if (rev) { #>     pmf[n] = upper_cdf[1]; #>     for (i in 2:n) { #>       pmf[n+1-i] = upper_cdf[i] - upper_cdf[i-1]; #>     } #>   }else{ #>     pmf[1] = upper_cdf[1]; #>     pmf[2:n] = upper_cdf[2:n] - upper_cdf[1:(n-1)]; #>   } #>   // normalize #>   pmf = pmf / upper_cdf[n]; #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // discretised truncated gamma pmf #> vector discretised_delta_pmf(int n) { #>   vector[n] pmf = rep_vector(0, n); #>   pmf[n] = 1; #>   return(pmf); #> } #>  #> // convolve a pdf and case vector #> vector convolve(vector cases, vector rev_pmf) { #>     int t = num_elements(cases); #>     int max_pmf = num_elements(rev_pmf); #>     vector[t] conv_cases = rep_vector(1e-5, t); #>     for (s in 1:t) { #>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s], #>                                      tail(rev_pmf, min(max_pmf, s))); #>     } #>    return(conv_cases); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           real[] delay_mean, #>                           real[] delay_sd, #>                           int[] max_delay, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_mean); #>   if (delays) { #>     for (s in 1:delays) { #>       vector[max_delay[s]] pmf; #>       pmf = discretised_lognormal_pmf( #>         delay_mean[s], delay_sd[s], max_delay[s], 1 #>       ); #>       unobs_reports = convolve(unobs_reports, pmf); #>     } #>     reports = unobs_reports[(seeding_time + 1):t]; #>   }else{ #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){ #>     int delays = num_elements(delay_mean); #>     if (delays) { #>       for (s in 1:delays) { #>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_pmf, #>                            int seeding_time, int max_gt, int index){ #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - max_gt)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(max_gt, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed)); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, #>                            real gt_mean, real gt_sd, int max_gt, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // generation time pmf #>   vector[max_gt] gt_pmf; #>   if (gt_sd > 0) { #>     // SD > 0: use discretised gamma #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     // SD == 0: use discretised delta #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #> // Update the log density for the generation time distribution mean and sd #> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, #>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) { #>   if (gt_mean_sd > 0) { #>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight; #>   } #>   if (gt_sd_sd > 0) { #>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight; #>   } #> } #>  #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Calculate a truncation CMF #> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) { #>     int  trunc_indexes[trunc_max]; #>     vector[trunc_max] cmf; #>     cmf = discretised_lognormal_pmf(trunc_mean, trunc_sd, trunc_max, 0); #>     cmf[1] = cmf[1] + 1e-8; #>     cmf = cumulative_sum(cmf); #>     cmf = reverse_mf(cmf); #>     return(cmf); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, real truncation_mean, real truncation_sd, #>                 int truncation_max, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = truncation_max > t ? t : truncation_max; #>   vector[trunc_max] cmf; #>   int first_t = t - trunc_max + 1; #>   cmf = truncation_cmf(truncation_mean, truncation_sd, trunc_max); #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     real gt_mean, real gt_sd, int max_gt, #>                     int smooth) { #>   vector[max_gt] gt_pmf; #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate PMF of the generation time #>   if (gt_sd > 0) { #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   gt_pmf = reverse_mf(gt_pmf); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_pmf, seeding_time, max_gt, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int max_delay[delays];       // maximum incubation period #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd;                   // prior sd of mean generation time #>   real gt_mean_mean;                 // prior mean of mean generation time #>   real gt_sd_mean;                   // prior mean of sd of generation time #>   real gt_sd_sd;                     // prior sd of sd of generation time #>   int max_gt;                        // maximum generation time #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int max_truncation[truncation];    // maximum truncation supported #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<lower = 0, upper = max_gt> gt_mean[estimate_r && gt_mean_sd > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[delays];                 // mean of delays #>   real<lower = 0> delay_sd[delays];        // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real truncation_mean[truncation];        // mean of truncation #>   real<lower = 0> truncation_sd[truncation]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     R = update_Rt(ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary); #>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt, #>                                      initial_infections, initial_growth, #>                                      pop, future_time); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior); #>   } #>   // convolve from latent infections to mean of observations #>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time); #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    obs_reports = truncate( #>     reports[1:ot], truncation_mean[1], truncation_sd[1], max_truncation[1], 0 #>   ); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, #>     delay_sd_sd, t #>   ); #>   // priors for truncation #>   truncation_lp( #>     truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd,  #>     trunc_sd_mean, trunc_sd_sd #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     generation_time_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   }else{ #>     // sample generation time #>     real gt_mean_sample = (gt_mean_sd > 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean); #>     real gt_sd_sample = (gt_sd_sd > 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean); #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_mean_sample, gt_sd_sample, max_gt, #>       rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"sampling\" #>  #> $cores #> [1] 1 #>  #> $warmup #> [1] 250 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 22195982 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 500 #>   # using vb rstan_opts(method = \"vb\") #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // discretised truncated gamma pmf #> vector discretised_gamma_pmf(real mu, real sigma, int max_val) { #>   int n = max_val; #>   vector[n+1] upper_cdf; #>   vector[n] pmf; #>   // calculate alpha and beta for gamma distribution #>   real small = 1e-5; #>   real large = 1e8; #>   real c_sigma = fmax(small, sigma); #>   real c_mu = fmax(small, mu); #>   real alpha = ((c_mu) / c_sigma)^2; #>   real beta = (c_mu) / (c_sigma^2); #>   // account for numerical issues #>   alpha = fmax(small, alpha); #>   alpha = fmin(large, alpha); #>   beta = fmax(small, beta); #>   beta = fmin(large, beta); #>   // calculate pmf #>   for (i in 1:(n+1)) { #>     upper_cdf[i] = gamma_cdf(i,  alpha, beta); #>   } #>   // discretise #>   for (i in 1:n) { #>     pmf[n+1-i] = upper_cdf[i+1] - upper_cdf[i]; #>   } #>   pmf = pmf / (upper_cdf[n+1] - upper_cdf[1]); #>   return(pmf); #> } #>  #> // discretised truncated lognormal pmf #> vector discretised_lognormal_pmf(real mu, real sigma, int max_val, int rev) { #>   int n = max_val; #>   vector[n] upper_cdf; #>   vector[n] pmf; #>   for (i in 1:n) { #>     upper_cdf[i] = lognormal_cdf(i,  mu, sigma); #>   } #>   // discretise #>   if (rev) { #>     pmf[n] = upper_cdf[1]; #>     for (i in 2:n) { #>       pmf[n+1-i] = upper_cdf[i] - upper_cdf[i-1]; #>     } #>   }else{ #>     pmf[1] = upper_cdf[1]; #>     pmf[2:n] = upper_cdf[2:n] - upper_cdf[1:(n-1)]; #>   } #>   // normalize #>   pmf = pmf / upper_cdf[n]; #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // discretised truncated gamma pmf #> vector discretised_delta_pmf(int n) { #>   vector[n] pmf = rep_vector(0, n); #>   pmf[n] = 1; #>   return(pmf); #> } #>  #> // convolve a pdf and case vector #> vector convolve(vector cases, vector rev_pmf) { #>     int t = num_elements(cases); #>     int max_pmf = num_elements(rev_pmf); #>     vector[t] conv_cases = rep_vector(1e-5, t); #>     for (s in 1:t) { #>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s], #>                                      tail(rev_pmf, min(max_pmf, s))); #>     } #>    return(conv_cases); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           real[] delay_mean, #>                           real[] delay_sd, #>                           int[] max_delay, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_mean); #>   if (delays) { #>     for (s in 1:delays) { #>       vector[max_delay[s]] pmf; #>       pmf = discretised_lognormal_pmf( #>         delay_mean[s], delay_sd[s], max_delay[s], 1 #>       ); #>       unobs_reports = convolve(unobs_reports, pmf); #>     } #>     reports = unobs_reports[(seeding_time + 1):t]; #>   }else{ #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){ #>     int delays = num_elements(delay_mean); #>     if (delays) { #>       for (s in 1:delays) { #>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_pmf, #>                            int seeding_time, int max_gt, int index){ #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - max_gt)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(max_gt, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed)); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, #>                            real gt_mean, real gt_sd, int max_gt, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // generation time pmf #>   vector[max_gt] gt_pmf; #>   if (gt_sd > 0) { #>     // SD > 0: use discretised gamma #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     // SD == 0: use discretised delta #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #> // Update the log density for the generation time distribution mean and sd #> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, #>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) { #>   if (gt_mean_sd > 0) { #>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight; #>   } #>   if (gt_sd_sd > 0) { #>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight; #>   } #> } #>  #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Calculate a truncation CMF #> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) { #>     int  trunc_indexes[trunc_max]; #>     vector[trunc_max] cmf; #>     cmf = discretised_lognormal_pmf(trunc_mean, trunc_sd, trunc_max, 0); #>     cmf[1] = cmf[1] + 1e-8; #>     cmf = cumulative_sum(cmf); #>     cmf = reverse_mf(cmf); #>     return(cmf); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, real truncation_mean, real truncation_sd, #>                 int truncation_max, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = truncation_max > t ? t : truncation_max; #>   vector[trunc_max] cmf; #>   int first_t = t - trunc_max + 1; #>   cmf = truncation_cmf(truncation_mean, truncation_sd, trunc_max); #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     real gt_mean, real gt_sd, int max_gt, #>                     int smooth) { #>   vector[max_gt] gt_pmf; #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate PMF of the generation time #>   if (gt_sd > 0) { #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   gt_pmf = reverse_mf(gt_pmf); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_pmf, seeding_time, max_gt, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int max_delay[delays];       // maximum incubation period #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd;                   // prior sd of mean generation time #>   real gt_mean_mean;                 // prior mean of mean generation time #>   real gt_sd_mean;                   // prior mean of sd of generation time #>   real gt_sd_sd;                     // prior sd of sd of generation time #>   int max_gt;                        // maximum generation time #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int max_truncation[truncation];    // maximum truncation supported #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<lower = 0, upper = max_gt> gt_mean[estimate_r && gt_mean_sd > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[delays];                 // mean of delays #>   real<lower = 0> delay_sd[delays];        // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real truncation_mean[truncation];        // mean of truncation #>   real<lower = 0> truncation_sd[truncation]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     R = update_Rt(ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary); #>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt, #>                                      initial_infections, initial_growth, #>                                      pop, future_time); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior); #>   } #>   // convolve from latent infections to mean of observations #>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time); #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    obs_reports = truncate( #>     reports[1:ot], truncation_mean[1], truncation_sd[1], max_truncation[1], 0 #>   ); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, #>     delay_sd_sd, t #>   ); #>   // priors for truncation #>   truncation_lp( #>     truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd,  #>     trunc_sd_mean, trunc_sd_sd #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     generation_time_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   }else{ #>     // sample generation time #>     real gt_mean_sample = (gt_mean_sd > 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean); #>     real gt_sd_sample = (gt_sd_sd > 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean); #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_mean_sample, gt_sd_sample, max_gt, #>       rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"vb\" #>  #> $trials #> [1] 10 #>  #> $iter #> [1] 10000 #>  #> $output_samples #> [1] 2000 #>"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Rstan Sampling Options — rstan_sampling_opts","title":"Rstan Sampling Options — rstan_sampling_opts","text":"Defines list specifying arguments passed rstan::sampling. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rstan Sampling Options — rstan_sampling_opts","text":"","code":"rstan_sampling_opts(   cores = getOption(\"mc.cores\", 1L),   warmup = 250,   samples = 2000,   chains = 4,   control = list(),   save_warmup = FALSE,   seed = as.integer(runif(1, 1, 1e+08)),   future = FALSE,   max_execution_time = Inf,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rstan Sampling Options — rstan_sampling_opts","text":"cores Number cores use executing chains parallel, defaults 1 recommended set mc.cores option many processors hardware RAM allow (number chains). warmup Numeric, defaults 250. Number warmup samples per chain. samples Numeric, default 2000. Overall number posterior samples. using multiple chains iterations per chain samples / chains. chains Numeric, defaults 4. Number MCMC chains use. control List, defaults empty. control parameters pass underlying rstan function. default adapt_delta = 0.95 max_treedepth = 15 though settings can overwritten. save_warmup Logical, defaults FALSE. warmup progress saved. seed Numeric, defaults uniform random number 1 1e8. Seed sampling process. future Logical, defaults FALSE. stan chains run parallel using future. allows users chains fail gracefully (.e combined max_execution_time). combined call future::plan max_execution_time Numeric, defaults Inf (seconds). set kill processing chain finished within specified timeout. 2 chains finish successfully estimates still returned. less 2 chains return within allowed time estimation fail informative error. ... Additional parameters pass rstan::sampling.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rstan Sampling Options — rstan_sampling_opts","text":"list arguments pass rstan::sampling","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_sampling_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rstan Sampling Options — rstan_sampling_opts","text":"","code":"rstan_sampling_opts(samples = 2000) #> $cores #> [1] 1 #>  #> $warmup #> [1] 250 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 41590286 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 750 #>"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Rstan Variational Bayes Options — rstan_vb_opts","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"Defines list specifying arguments passed rstan::vb. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"","code":"rstan_vb_opts(samples = 2000, trials = 10, iter = 10000, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"samples Numeric, default 2000. Overall number approximate posterior samples. trials Numeric, defaults 10. Number attempts use rstan::vb failing. iter Numeric, defaulting 10000. Number iterations use rtan::vb. ... Additional parameters pass rstan::vb.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"list arguments pass rstan::vb","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rstan_vb_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rstan Variational Bayes Options — rstan_vb_opts","text":"","code":"rstan_vb_opts(samples = 1000) #> $trials #> [1] 10 #>  #> $iter #> [1] 10000 #>  #> $output_samples #> [1] 1000 #>"},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-Varying Reproduction Number Options — rt_opts","title":"Time-Varying Reproduction Number Options — rt_opts","text":"Defines list specifying optional arguments time-varying reproduction number. Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-Varying Reproduction Number Options — rt_opts","text":"","code":"rt_opts(   prior = list(mean = 1, sd = 1),   use_rt = TRUE,   rw = 0,   use_breakpoints = TRUE,   future = \"latest\",   gp_on = \"R_t-1\",   pop = 0 )"},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-Varying Reproduction Number Options — rt_opts","text":"prior List containing named numeric elements \"mean\" \"sd\". mean standard deviation log normal Rt prior. Defaults mean 1 standard deviation 1. use_rt Logical, defaults TRUE. Rt used generate infections hence reported cases. rw Numeric step size random walk, defaults 0. specify weekly random walk set rw = 7. custom break point settings consider passing breakpoints variable outlined next section. use_breakpoints Logical, defaults TRUE. break points used present breakpoint variable input data. Break points defined 1 present otherwise 0. default breakpoints fit jointly global non-parametric effect represent conservative estimate break point changes (alter setting gp = NULL). future character string integer. argument indicates set future Rt values. Supported options project using Rt model (\"project\"), use latest estimate based partial data (\"latest\"), use latest estimate based data 50% complete (\"estimate\"). integer supplied Rt estimate many days future (past negative) past used forwards time. gp_on Character string, defaulting  \"R_t-1\". Indicates Gaussian process, use, applied Rt.  Currently supported options applying Gaussian process last estimated Rt (.e Rt = Rt-1 * GP), applying Gaussian process global mean (.e Rt = R0 * GP). produced comparable results data sparse method relying global mean revert real time estimates, may desirable. pop Integer, defaults 0. Susceptible population initially present. Used adjust Rt estimates otherwise fixed based proportion population susceptible. set 0 population adjustment done.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time-Varying Reproduction Number Options — rt_opts","text":"list settings defining time-varying reproduction number","code":""},{"path":"epiforecasts.io/EpiNow2/reference/rt_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-Varying Reproduction Number Options — rt_opts","text":"","code":"# default settings rt_opts() #> $prior #> $prior$mean #> [1] 1 #>  #> $prior$sd #> [1] 1 #>  #>  #> $use_rt #> [1] TRUE #>  #> $rw #> [1] 0 #>  #> $use_breakpoints #> [1] TRUE #>  #> $future #> [1] \"latest\" #>  #> $pop #> [1] 0 #>  #> $gp_on #> [1] \"R_t-1\" #>   # add a custom length scale rt_opts(prior = list(mean = 2, sd = 1)) #> $prior #> $prior$mean #> [1] 2 #>  #> $prior$sd #> [1] 1 #>  #>  #> $use_rt #> [1] TRUE #>  #> $rw #> [1] 0 #>  #> $use_breakpoints #> [1] TRUE #>  #> $future #> [1] \"latest\" #>  #> $pop #> [1] 0 #>  #> $gp_on #> [1] \"R_t-1\" #>   # add a weekly random walk rt_opts(rw = 7) #> $prior #> $prior$mean #> [1] 1 #>  #> $prior$sd #> [1] 1 #>  #>  #> $use_rt #> [1] TRUE #>  #> $rw #> [1] 7 #>  #> $use_breakpoints #> [1] TRUE #>  #> $future #> [1] \"latest\" #>  #> $pop #> [1] 0 #>  #> $gp_on #> [1] \"R_t-1\" #>"},{"path":"epiforecasts.io/EpiNow2/reference/run_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Run epinow with Regional Processing Code — run_region","title":"Run epinow with Regional Processing Code — run_region","text":"Internal function handles calling epinow. Future work extend function better handle stan logs allow user modify settings regions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/run_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run epinow with Regional Processing Code — run_region","text":"","code":"run_region(   target_region,   generation_time,   delays,   truncation,   rt,   backcalc,   gp,   obs,   stan,   horizon,   CrIs,   reported_cases,   target_folder,   target_date,   return_output,   output,   complete_logger,   verbose,   progress_fn,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/run_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run epinow with Regional Processing Code — run_region","text":"target_region Character string indicating region evaluated generation_time list containing mean, standard deviation mean (mean_sd), standard deviation (sd), standard deviation standard deviation maximum allowed value generation time (assuming gamma distribution). delays call delay_opts() defining delay distributions options. See documentation delay_opts() examples details. truncation list options generated trunc_opts() defining truncation observed data. Defaults trunc_opts(). See estimate_truncation() approach estimating truncation data. rt list options generated rt_opts() defining Rt estimation. Defaults rt_opts(). Set NULL switch using  back calculation rather generating infections using Rt. backcalc list options generated backcalc_opts() define back calculation. Defaults backcalc_opts(). gp list options generated gp_opts() define Gaussian process. Defaults gp_opts().Set NULL disable Gaussian process. obs list options generated obs_opts() defining observation model. Defaults obs_opts(). stan list stan options generated stan_opts(). Defaults stan_opts(). Can used override data, init, verbose settings desired. horizon Numeric, defaults 7. Number days future forecast. CrIs Numeric vector credible intervals calculate. reported_cases data frame confirmed cases (confirm) date (date), region (region). target_folder Character string specifying save results (create present). target_date Date, defaults maximum found data specified. return_output Logical, defaults FALSE. output returned, automatically updates TRUE directory saving specified. output character vector optional output return. Supported options individual regional estimates (\"regions\"),  samples (\"samples\"), plots (\"plots\"), copying individual region dated folder latest folder (target_folder null, set using \"latest\"), stan fit underlying model (\"fit\"), overall summary across regions (\"summary\"). default return samples plots alongside summarised estimates summary statistics. target_folder NULL default also copy results latest folder. complete_logger Character string indicating logger output completion estimation . verbose Logical defaults FALSE. Outputs verbose progress messages console epinow. progress_fn Function returned progressr::progressor. Allows use progress bar. ... Pass additional arguments epinow. See documentation epinow details.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/run_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run epinow with Regional Processing Code — run_region","text":"list processed output produced process_region","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate Sampling a Distribution using Counts — sample_approx_dist","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"Convolves cases PMF function. function soon removed replaced robust stan implementation.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"","code":"sample_approx_dist(   cases = NULL,   dist_fn = NULL,   max_value = 120,   earliest_allowed_mapped = NULL,   direction = \"backwards\",   type = \"sample\",   truncate_future = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"cases dataframe cases (date order) following variables: date cases. dist_fn Function takes two arguments first numeric second logical (defined dist). return probability density sample defined distribution. See examples . max_value Numeric, maximum value allow. Defaults 120 days earliest_allowed_mapped character string representing date (\"2020-01-01\"). Indicates earliest allowed mapped value. direction Character string, defato \"backwards\". Direction map cases. Supports either \"backwards\" \"forwards\". type Character string indicating method use transform counts. Supports either \"sample\" approximates sampling \"median\" shift median distribution. truncate_future Logical, cases truncated occur first date reported data. Defaults TRUE.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"data.table cases date onset","code":""},{"path":"epiforecasts.io/EpiNow2/reference/sample_approx_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate Sampling a Distribution using Counts — sample_approx_dist","text":"","code":"# \\donttest{ cases <- example_confirmed cases <- cases[, cases := as.integer(confirm)] print(cases) #>            date confirm cases #>   1: 2020-02-22      14    14 #>   2: 2020-02-23      62    62 #>   3: 2020-02-24      53    53 #>   4: 2020-02-25      97    97 #>   5: 2020-02-26      93    93 #>  ---                          #> 126: 2020-06-26     296   296 #> 127: 2020-06-27     255   255 #> 128: 2020-06-28     175   175 #> 129: 2020-06-29     174   174 #> 130: 2020-06-30     126   126  # total cases sum(cases$cases) #> [1] 240581  delay_fn <- function(n, dist, cum) {   if (dist) {     pgamma(n + 0.9999, 2, 1) - pgamma(n - 1e-5, 2, 1)   } else {     as.integer(rgamma(n, 2, 1))   } }  onsets <- sample_approx_dist(   cases = cases,   dist_fn = delay_fn )  # estimated onset distribution print(onsets) #>            date cases #>   1: 2020-02-16     1 #>   2: 2020-02-17     1 #>   3: 2020-02-18     3 #>   4: 2020-02-19     5 #>   5: 2020-02-20    15 #>  ---                  #> 132: 2020-06-26   218 #> 133: 2020-06-27   162 #> 134: 2020-06-28   134 #> 135: 2020-06-29    98 #> 136: 2020-06-30    35  # check that sum is equal to reported cases total_onsets <- median(   purrr::map_dbl(     1:10,     ~ sum(sample_approx_dist(       cases = cases,       dist_fn = delay_fn     )$cases)   ) ) total_onsets #> [1] 240315   # map from onset cases to reported reports <- sample_approx_dist(   cases = cases,   dist_fn = delay_fn,   direction = \"forwards\" )   # map from onset cases to reported using a mean shift reports <- sample_approx_dist(   cases = cases,   dist_fn = delay_fn,   direction = \"forwards\",   type = \"median\" ) # }"},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Save Estimated Infections — save_estimate_infections","title":"Save Estimated Infections — save_estimate_infections","text":"Saves output estimate_infections target directory.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save Estimated Infections — save_estimate_infections","text":"","code":"save_estimate_infections(   estimates,   target_folder = NULL,   samples = TRUE,   return_fit = TRUE )"},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save Estimated Infections — save_estimate_infections","text":"estimates List data frames output estimate_infections target_folder Character string specifying save results (create present). samples Logical, defaults TRUE. samples saved return_fit Logical, defaults TRUE. fit stan object returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_estimate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save Estimated Infections — save_estimate_infections","text":"return value, called side effects","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Save Observed Data — save_input","title":"Save Observed Data — save_input","text":"Saves observed data target location given.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save Observed Data — save_input","text":"","code":"save_input(reported_cases, target_folder)"},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save Observed Data — save_input","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format. target_folder Character string specifying save results (create present).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/save_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save Observed Data — save_input","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Secondary Reports Options — secondary_opts","title":"Secondary Reports Options — secondary_opts","text":"Returns list options defining secondary model used estimate_secondary(). model combination convolution previously observed primary reports combined current primary reports (either additive subtractive). model can optionally cumulative. See documentation type sensible options cover use cases returned values secondary_opts() currently supported options.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Secondary Reports Options — secondary_opts","text":"","code":"secondary_opts(type = \"incidence\", ...)"},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Secondary Reports Options — secondary_opts","text":"type character string indicating type observation secondary reports . Options include: \"incidence\": Assumes secondary reports equal convolution previously observed primary reported cases. example application deaths infectious disease predicted reported cases disease (estimated infections). \"prevalence\": Assumes secondary reports cumulative defined currently observed primary reports minus convolution secondary reports. example application hospital bed usage predicted hospital admissions. ... Overwrite options defined type. See returned values options can passed.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Secondary Reports Options — secondary_opts","text":"list binary options summarising secondary model used estimate_secondary(). Options returned cumulative (secondary report cumulative), historic (convolution primary reported cases used predict secondary reported cases), primary_hist_additive (historic convolution primary reported cases additive subtractive), current (currently observed primary reported cases contribute current secondary reported cases), primary_current_additive (current primary reported cases additive subtractive).","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/secondary_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Secondary Reports Options — secondary_opts","text":"","code":"# incidence model secondary_opts(\"incidence\") #> $cumulative #> [1] 0 #>  #> $historic #> [1] 1 #>  #> $primary_hist_additive #> [1] 1 #>  #> $current #> [1] 0 #>  #> $primary_current_additive #> [1] 0 #>   # prevalence model secondary_opts(\"prevalence\") #> $cumulative #> [1] 1 #>  #> $historic #> [1] 1 #>  #> $primary_hist_additive #> [1] 0 #>  #> $current #> [1] 1 #>  #> $primary_current_additive #> [1] 1 #>"},{"path":"epiforecasts.io/EpiNow2/reference/set_dt_single_thread.html","id":null,"dir":"Reference","previous_headings":"","what":"Set to Single Threading — set_dt_single_thread","title":"Set to Single Threading — set_dt_single_thread","text":"function sets threads used data.table 1 parent function restores initial data.table threads function exits. primarily used internal function inside functions generally used .","code":""},{"path":"epiforecasts.io/EpiNow2/reference/set_dt_single_thread.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set to Single Threading — set_dt_single_thread","text":"","code":"set_dt_single_thread()"},{"path":"epiforecasts.io/EpiNow2/reference/set_dt_single_thread.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set to Single Threading — set_dt_single_thread","text":"environment parent frame named \"dt_settings\"","code":""},{"path":"epiforecasts.io/EpiNow2/reference/set_dt_single_thread.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set to Single Threading — set_dt_single_thread","text":"","code":"# \\donttest{ data.table::setDTthreads(2) test_function <- function() {   set_dt_single_thread()    print(data.table::getDTthreads()) } test_function() #> [1] 1 data.table::getDTthreads() #> [1] 2 # }"},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup Default Logging — setup_default_logging","title":"Setup Default Logging — setup_default_logging","text":"Sets default logging. Usage logging currently explored current setup log stan errors progress.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup Default Logging — setup_default_logging","text":"","code":"setup_default_logging(   logs = tempdir(check = TRUE),   mirror_epinow = FALSE,   target_date = NULL )"},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup Default Logging — setup_default_logging","text":"logs Character path indicating target folder store log information. Defaults temporary directory specified. Default logging can disabled logs set NULL. specifying custom logging setup code setup_default_logging setup_logging function sensible place start. mirror_epinow Logical, defaults FALSE. internal logging returned epinow console. target_date Date, defaults maximum found data specified.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup Default Logging — setup_default_logging","text":"return value, called side effects","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_default_logging.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Setup Default Logging — setup_default_logging","text":"","code":"setup_default_logging() #> Logging threshold set at INFO for the EpiNow2 logger #> Writing EpiNow2 logs to the console and: /tmp/RtmpjXBiR6/regional-epinow/latest.log #> Logging threshold set at INFO for the EpiNow2.epinow logger #> Writing EpiNow2.epinow logs to: /tmp/RtmpjXBiR6/epinow/latest.log"},{"path":"epiforecasts.io/EpiNow2/reference/setup_dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to Data Table — setup_dt","title":"Convert to Data Table — setup_dt","text":"Convenience function sets number data.table cores 1 maps input data.table","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to Data Table — setup_dt","text":"","code":"setup_dt(reported_cases)"},{"path":"epiforecasts.io/EpiNow2/reference/setup_dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to Data Table — setup_dt","text":"reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to Data Table — setup_dt","text":"data table","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_future.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up Future Backend — setup_future","title":"Set up Future Backend — setup_future","text":"utility function aims streamline set required future backend sensible defaults users regional_epinow. advanced users recommended setup future backend based available resources.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_future.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up Future Backend — setup_future","text":"","code":"setup_future(   reported_cases,   strategies = c(\"multisession\", \"multisession\"),   min_cores_per_worker = 4 )"},{"path":"epiforecasts.io/EpiNow2/reference/setup_future.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up Future Backend — setup_future","text":"reported_cases data frame confirmed cases (confirm) date (date), region (region). strategies vector length 1 2 strategies pass future::plan. Nesting parallelisation top level . default set nesting parallelisation using future::multisession (future::multicore likely faster option supported platforms). single level parallelisation use single strategy future::plan directly. See ?future::plan options. min_cores_per_worker Numeric, minimum number cores per worker. Defaults 4 assumes 4 MCMC chains use per region.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_future.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up Future Backend — setup_future","text":"Numeric number cores use per worker. greater 1 pass stan_args = list(cores = \"output setup future\") use future = TRUE. single strategy used nothing returned.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_logging.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup Logging — setup_logging","title":"Setup Logging — setup_logging","text":"Sets futile.logger logging, integrated EpiNow2. See documentation futile.logger full details. default EpiNow2 prints logs \"INFO\" level returns console. Usage logging currently explored current setup log stan errors progress.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_logging.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup Logging — setup_logging","text":"","code":"setup_logging(   threshold = \"INFO\",   file = NULL,   mirror_to_console = FALSE,   name = \"EpiNow2\" )"},{"path":"epiforecasts.io/EpiNow2/reference/setup_logging.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup Logging — setup_logging","text":"threshold Character string indicating logging level see (?futile.logger details available options). Defaults \"INFO\". file Character string indicating path save logs . default logs written console. mirror_to_console Logical, defaults FALSE. saving logs file also duplicated console. name Character string defaulting EpiNow2. indicates name logger setup. default logger EpiNow2 called EpiNow2. Nested options include: Epinow2.epinow controls logging epinow nested functions, EpiNow2.epinow.estimate_infections (logging estimate_infections), EpiNow2.epinow.estimate_infections.fit (logging fitting functions).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_logging.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup Logging — setup_logging","text":"Nothing","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_target_folder.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup Target Folder for Saving — setup_target_folder","title":"Setup Target Folder for Saving — setup_target_folder","text":"Sets folders saving results","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_target_folder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup Target Folder for Saving — setup_target_folder","text":"","code":"setup_target_folder(target_folder = NULL, target_date)"},{"path":"epiforecasts.io/EpiNow2/reference/setup_target_folder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup Target Folder for Saving — setup_target_folder","text":"target_folder Character string specifying save results (create present). target_date Date, defaults maximum found data specified.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/setup_target_folder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup Target Folder for Saving — setup_target_folder","text":"list containing path dated folder latest folder","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"function simulates infections using existing fit observed cases modified time-varying reproduction number. can used explore forecast models past counterfactuals. Simulations can run parallel using future::plan.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"","code":"simulate_infections(   estimates,   R = NULL,   model = NULL,   samples = NULL,   batch_size = 10,   verbose = interactive() )"},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"estimates estimates element epinow run done output = \"fit\", result estimate_infections return_fit set TRUE. R numeric vector reproduction numbers; overwrite reproduction numbers contained estimates, except elements set NA. longer time series reproduction numbers contained estimates, values going beyond length estimated reproduction numbers taken forecast. Alternatively accepts data.frame containing least date value (integer) variables optionally sample. model compiled stan model returned rstan::stan_model. samples Numeric, number posterior samples simulate . default use samples estimates input. batch_size Numeric, defaults 10. Size batches simulate. May decrease run times due reduced IO costs still evaluated. set NULL simulations done . verbose Logical defaults interactive(). progress bar (progressr) shown.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"list output returned estimate_infections() based results specified scenario rather fitting.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/simulate_infections.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate infections using a given trajectory of the time-varying reproduction number — simulate_infections","text":"","code":"# \\donttest{ # set number of cores to use old_opts <- options() options(mc.cores = ifelse(interactive(), 4, 1))  # get example case counts reported_cases <- example_confirmed[1:50]  # set up example generation time generation_time <- get_generation_time(disease = \"SARS-CoV-2\", source = \"ganyani\") # set delays between infection and case report incubation_period <- get_incubation_period(disease = \"SARS-CoV-2\", source = \"lauer\") reporting_delay <- list(   mean = convert_to_logmean(2, 1), mean_sd = 0.1,   sd = convert_to_logsd(2, 1), sd_sd = 0.1, max = 15 )  # fit model to data to recover Rt estimates est <- estimate_infections(reported_cases,   generation_time = generation_time,   delays = delay_opts(incubation_period, reporting_delay),   rt = rt_opts(prior = list(mean = 2, sd = 0.1)),   gp = gp_opts(     ls_min = 10, boundary_scale = 1.5, ,     basis_prop = 0.1   ),   obs = obs_opts(scale = list(mean = 0.1, sd = 0.01)) ) #> Warning: There were 1 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems  # update Rt trajectory and simulate new infections using it R <- c(rep(NA_real_, 40), rep(0.5, 10), rep(0.8, 7)) sims <- simulate_infections(est, R) plot(sims)   # with a data.frame input of samples R_dt <- data.frame(   date = summary(est, type = \"parameters\", param = \"R\")$date,   value = R ) #> Error in data.frame(date = summary(est, type = \"parameters\", param = \"R\")$date,     value = R): arguments imply differing number of rows: 49, 57 sims <- simulate_infections(est, R_dt) #> Error in simulate_infections(est, R_dt): object 'R_dt' not found plot(sims)   #' # with a data.frame input of samples R_samples <- summary(est, type = \"samples\", param = \"R\") R_samples <- R_samples[, .(date, sample, value)][sample <= 1000][date <= \"2020-04-10\"] R_samples <- R_samples[date >= \"2020-04-01\", value := 1.1] sims <- simulate_infections(est, R_samples) plot(sims)   options(old_opts) # }"},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Stan Options — stan_opts","title":"Stan Options — stan_opts","text":"Defines list specifying arguments passed underlying stan backend functions via rstan_sampling_opts() rstan_vb_opts(). Custom settings can supplied override defaults.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stan Options — stan_opts","text":"","code":"stan_opts(   samples = 2000,   backend = \"rstan\",   init_fit = NULL,   return_fit = TRUE,   ... )"},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stan Options — stan_opts","text":"samples Numeric, default 2000. Overall number posterior samples. using multiple chains iterations per chain samples / chains. backend Character string indicating backend use fitting stan models. Currently \"rstan\" supported. init_fit Character string stanfit object, defaults NULL. initial fit used initialise full fit. example scenario using national level fit parametrise regional level fits. Optionally character string can passed currently supported option \"cumulative\". fits model cumulative cases may useful certain data sets sampler gets stuck struggles initialise. See init_cumulative_fit() details. implementation based approach taken epidemia authored James Scott. return_fit Logical, defaults TRUE. fit stan model returned. ... Additional parameters pass  underlying option functions.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stan Options — stan_opts","text":"list arguments pass appropriate rstan functions.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/stan_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stan Options — stan_opts","text":"","code":"# using default of rstan::sampling stan_opts(samples = 1000) #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // discretised truncated gamma pmf #> vector discretised_gamma_pmf(real mu, real sigma, int max_val) { #>   int n = max_val; #>   vector[n+1] upper_cdf; #>   vector[n] pmf; #>   // calculate alpha and beta for gamma distribution #>   real small = 1e-5; #>   real large = 1e8; #>   real c_sigma = fmax(small, sigma); #>   real c_mu = fmax(small, mu); #>   real alpha = ((c_mu) / c_sigma)^2; #>   real beta = (c_mu) / (c_sigma^2); #>   // account for numerical issues #>   alpha = fmax(small, alpha); #>   alpha = fmin(large, alpha); #>   beta = fmax(small, beta); #>   beta = fmin(large, beta); #>   // calculate pmf #>   for (i in 1:(n+1)) { #>     upper_cdf[i] = gamma_cdf(i,  alpha, beta); #>   } #>   // discretise #>   for (i in 1:n) { #>     pmf[n+1-i] = upper_cdf[i+1] - upper_cdf[i]; #>   } #>   pmf = pmf / (upper_cdf[n+1] - upper_cdf[1]); #>   return(pmf); #> } #>  #> // discretised truncated lognormal pmf #> vector discretised_lognormal_pmf(real mu, real sigma, int max_val, int rev) { #>   int n = max_val; #>   vector[n] upper_cdf; #>   vector[n] pmf; #>   for (i in 1:n) { #>     upper_cdf[i] = lognormal_cdf(i,  mu, sigma); #>   } #>   // discretise #>   if (rev) { #>     pmf[n] = upper_cdf[1]; #>     for (i in 2:n) { #>       pmf[n+1-i] = upper_cdf[i] - upper_cdf[i-1]; #>     } #>   }else{ #>     pmf[1] = upper_cdf[1]; #>     pmf[2:n] = upper_cdf[2:n] - upper_cdf[1:(n-1)]; #>   } #>   // normalize #>   pmf = pmf / upper_cdf[n]; #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // discretised truncated gamma pmf #> vector discretised_delta_pmf(int n) { #>   vector[n] pmf = rep_vector(0, n); #>   pmf[n] = 1; #>   return(pmf); #> } #>  #> // convolve a pdf and case vector #> vector convolve(vector cases, vector rev_pmf) { #>     int t = num_elements(cases); #>     int max_pmf = num_elements(rev_pmf); #>     vector[t] conv_cases = rep_vector(1e-5, t); #>     for (s in 1:t) { #>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s], #>                                      tail(rev_pmf, min(max_pmf, s))); #>     } #>    return(conv_cases); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           real[] delay_mean, #>                           real[] delay_sd, #>                           int[] max_delay, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_mean); #>   if (delays) { #>     for (s in 1:delays) { #>       vector[max_delay[s]] pmf; #>       pmf = discretised_lognormal_pmf( #>         delay_mean[s], delay_sd[s], max_delay[s], 1 #>       ); #>       unobs_reports = convolve(unobs_reports, pmf); #>     } #>     reports = unobs_reports[(seeding_time + 1):t]; #>   }else{ #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){ #>     int delays = num_elements(delay_mean); #>     if (delays) { #>       for (s in 1:delays) { #>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_pmf, #>                            int seeding_time, int max_gt, int index){ #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - max_gt)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(max_gt, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed)); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, #>                            real gt_mean, real gt_sd, int max_gt, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // generation time pmf #>   vector[max_gt] gt_pmf; #>   if (gt_sd > 0) { #>     // SD > 0: use discretised gamma #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     // SD == 0: use discretised delta #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #> // Update the log density for the generation time distribution mean and sd #> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, #>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) { #>   if (gt_mean_sd > 0) { #>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight; #>   } #>   if (gt_sd_sd > 0) { #>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight; #>   } #> } #>  #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Calculate a truncation CMF #> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) { #>     int  trunc_indexes[trunc_max]; #>     vector[trunc_max] cmf; #>     cmf = discretised_lognormal_pmf(trunc_mean, trunc_sd, trunc_max, 0); #>     cmf[1] = cmf[1] + 1e-8; #>     cmf = cumulative_sum(cmf); #>     cmf = reverse_mf(cmf); #>     return(cmf); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, real truncation_mean, real truncation_sd, #>                 int truncation_max, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = truncation_max > t ? t : truncation_max; #>   vector[trunc_max] cmf; #>   int first_t = t - trunc_max + 1; #>   cmf = truncation_cmf(truncation_mean, truncation_sd, trunc_max); #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     real gt_mean, real gt_sd, int max_gt, #>                     int smooth) { #>   vector[max_gt] gt_pmf; #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate PMF of the generation time #>   if (gt_sd > 0) { #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   gt_pmf = reverse_mf(gt_pmf); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_pmf, seeding_time, max_gt, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int max_delay[delays];       // maximum incubation period #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd;                   // prior sd of mean generation time #>   real gt_mean_mean;                 // prior mean of mean generation time #>   real gt_sd_mean;                   // prior mean of sd of generation time #>   real gt_sd_sd;                     // prior sd of sd of generation time #>   int max_gt;                        // maximum generation time #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int max_truncation[truncation];    // maximum truncation supported #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<lower = 0, upper = max_gt> gt_mean[estimate_r && gt_mean_sd > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[delays];                 // mean of delays #>   real<lower = 0> delay_sd[delays];        // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real truncation_mean[truncation];        // mean of truncation #>   real<lower = 0> truncation_sd[truncation]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     R = update_Rt(ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary); #>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt, #>                                      initial_infections, initial_growth, #>                                      pop, future_time); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior); #>   } #>   // convolve from latent infections to mean of observations #>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time); #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    obs_reports = truncate( #>     reports[1:ot], truncation_mean[1], truncation_sd[1], max_truncation[1], 0 #>   ); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, #>     delay_sd_sd, t #>   ); #>   // priors for truncation #>   truncation_lp( #>     truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd,  #>     trunc_sd_mean, trunc_sd_sd #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     generation_time_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   }else{ #>     // sample generation time #>     real gt_mean_sample = (gt_mean_sd > 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean); #>     real gt_sd_sample = (gt_sd_sd > 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean); #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_mean_sample, gt_sd_sample, max_gt, #>       rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"sampling\" #>  #> $cores #> [1] 1 #>  #> $warmup #> [1] 250 #>  #> $chains #> [1] 4 #>  #> $save_warmup #> [1] FALSE #>  #> $seed #> [1] 58321445 #>  #> $future #> [1] FALSE #>  #> $max_execution_time #> [1] Inf #>  #> $control #> $control$adapt_delta #> [1] 0.95 #>  #> $control$max_treedepth #> [1] 15 #>  #>  #> $iter #> [1] 500 #>  #> $return_fit #> [1] TRUE #>   # using vb stan_opts(method = \"vb\") #> $object #> S4 class stanmodel 'estimate_infections' coded as follows: #> functions { #>  #> // discretised truncated gamma pmf #> vector discretised_gamma_pmf(real mu, real sigma, int max_val) { #>   int n = max_val; #>   vector[n+1] upper_cdf; #>   vector[n] pmf; #>   // calculate alpha and beta for gamma distribution #>   real small = 1e-5; #>   real large = 1e8; #>   real c_sigma = fmax(small, sigma); #>   real c_mu = fmax(small, mu); #>   real alpha = ((c_mu) / c_sigma)^2; #>   real beta = (c_mu) / (c_sigma^2); #>   // account for numerical issues #>   alpha = fmax(small, alpha); #>   alpha = fmin(large, alpha); #>   beta = fmax(small, beta); #>   beta = fmin(large, beta); #>   // calculate pmf #>   for (i in 1:(n+1)) { #>     upper_cdf[i] = gamma_cdf(i,  alpha, beta); #>   } #>   // discretise #>   for (i in 1:n) { #>     pmf[n+1-i] = upper_cdf[i+1] - upper_cdf[i]; #>   } #>   pmf = pmf / (upper_cdf[n+1] - upper_cdf[1]); #>   return(pmf); #> } #>  #> // discretised truncated lognormal pmf #> vector discretised_lognormal_pmf(real mu, real sigma, int max_val, int rev) { #>   int n = max_val; #>   vector[n] upper_cdf; #>   vector[n] pmf; #>   for (i in 1:n) { #>     upper_cdf[i] = lognormal_cdf(i,  mu, sigma); #>   } #>   // discretise #>   if (rev) { #>     pmf[n] = upper_cdf[1]; #>     for (i in 2:n) { #>       pmf[n+1-i] = upper_cdf[i] - upper_cdf[i-1]; #>     } #>   }else{ #>     pmf[1] = upper_cdf[1]; #>     pmf[2:n] = upper_cdf[2:n] - upper_cdf[1:(n-1)]; #>   } #>   // normalize #>   pmf = pmf / upper_cdf[n]; #>   return(pmf); #> } #>  #> // reverse a mf #> vector reverse_mf(vector pmf) { #>   int max_pmf = num_elements(pmf); #>   vector[max_pmf] rev_pmf; #>   for (d in 1:max_pmf) { #>     rev_pmf[d] = pmf[max_pmf - d + 1]; #>   } #>   return rev_pmf; #> } #>  #> // discretised truncated gamma pmf #> vector discretised_delta_pmf(int n) { #>   vector[n] pmf = rep_vector(0, n); #>   pmf[n] = 1; #>   return(pmf); #> } #>  #> // convolve a pdf and case vector #> vector convolve(vector cases, vector rev_pmf) { #>     int t = num_elements(cases); #>     int max_pmf = num_elements(rev_pmf); #>     vector[t] conv_cases = rep_vector(1e-5, t); #>     for (s in 1:t) { #>         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s], #>                                      tail(rev_pmf, min(max_pmf, s))); #>     } #>    return(conv_cases); #>   } #>  #>  #> // convolve latent infections to reported (but still unobserved) cases #> vector convolve_to_report(vector infections, #>                           real[] delay_mean, #>                           real[] delay_sd, #>                           int[] max_delay, #>                           int seeding_time) { #>   int t = num_elements(infections); #>   vector[t - seeding_time] reports; #>   vector[t] unobs_reports = infections; #>   int delays = num_elements(delay_mean); #>   if (delays) { #>     for (s in 1:delays) { #>       vector[max_delay[s]] pmf; #>       pmf = discretised_lognormal_pmf( #>         delay_mean[s], delay_sd[s], max_delay[s], 1 #>       ); #>       unobs_reports = convolve(unobs_reports, pmf); #>     } #>     reports = unobs_reports[(seeding_time + 1):t]; #>   }else{ #>     reports = infections[(seeding_time + 1):t]; #>   } #>   return(reports); #> } #>  #> void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, #>                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){ #>     int delays = num_elements(delay_mean); #>     if (delays) { #>       for (s in 1:delays) { #>        target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight; #>        target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight; #>      } #>   } #> } #>  #> // eigenvalues for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> real lambda(real L, int m) { #>   real lam; #>   lam = ((m*pi())/(2*L))^2; #>   return lam; #> } #> // eigenfunction for approximate hilbert space gp #> // see here for details: https://arxiv.org/pdf/2004.11408.pdf #> vector phi(real L, int m, vector x) { #>   vector[rows(x)] fi; #>   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L)); #>   return fi; #> } #> // spectral density of the exponential quadratic kernal #> real spd_se(real alpha, real rho, real w) { #>   real S; #>   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2)); #>   return S; #> } #> // spectral density of the Matern 3/2 kernel #> real spd_matern(real alpha, real rho, real w) { #>   real S; #>   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2; #>   return S; #> } #> // setup gaussian process noise dimensions #> int setup_noise(int ot_h, int t, int horizon, int estimate_r, #>                 int stationary, int future_fixed, int fixed_from) { #>   int noise_time = estimate_r > 0 ? (stationary > 0 ? ot_h : ot_h - 1) : t; #>   int noise_terms =  future_fixed > 0 ? (noise_time - horizon + fixed_from) : noise_time; #>   return(noise_terms); #> } #> // setup approximate gaussian process #> matrix setup_gp(int M, real L, int dimension) { #>   vector[dimension] time; #>   matrix[dimension, M] PHI; #>   real half_dim = dimension / 2.0; #>   for (s in 1:dimension) { #>     time[s] = (s - half_dim) / half_dim; #>   } #>   for (m in 1:M){ #>     PHI[,m] = phi(L, m, time); #>   } #>   return(PHI); #> } #> // update gaussian process using spectral densities #> vector update_gp(matrix PHI, int M, real L, real alpha, #>                  real rho, vector eta, int type) { #>   vector[M] diagSPD;    // spectral density #>   vector[M] SPD_eta;    // spectral density * noise #>   int noise_terms = rows(PHI); #>   vector[noise_terms] noise = rep_vector(1e-6, noise_terms); #>   real unit_rho = rho / noise_terms; #>   // GP in noise - spectral densities #>   if (type == 0) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   }else if (type == 1) { #>     for(m in 1:M){ #>       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); #>     } #>   } #>   SPD_eta = diagSPD .* eta; #>   noise = noise + PHI[,] * SPD_eta; #>   return(noise); #> } #> // priors for gaussian process #> void gaussian_process_lp(real rho, real alpha, vector eta, #>                          real ls_meanlog, real ls_sdlog, #>                          real ls_min, real ls_max, real alpha_sd) { #>   if (ls_sdlog > 0) { #>     rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max]; #>   } else { #>     rho ~ inv_gamma(1.499007, 0.057277 * ls_max) T[ls_min, ls_max]; #>   } #>   alpha ~ normal(0, alpha_sd); #>   eta ~ std_normal(); #> } #>  #> // update a vector of Rts #> vector update_Rt(int t, real log_R, vector noise, int[] bps, #>                  real[] bp_effects, int stationary) { #>   // define control parameters #>   int bp_n = num_elements(bp_effects); #>   int bp_c = 0; #>   int gp_n = num_elements(noise); #>   // define result vectors #>   vector[t] bp = rep_vector(0, t); #>   vector[t] gp = rep_vector(0, t); #>   vector[t] R; #>   // initialise breakpoints #>   if (bp_n) { #>     for (s in 1:t) { #>       if (bps[s]) { #>         bp_c += bps[s]; #>         bp[s] = bp_effects[bp_c]; #>       } #>     } #>     bp = cumulative_sum(bp); #>   } #>   //initialise gaussian process #>   if (gp_n) { #>     if (stationary) { #>       gp[1:gp_n] = noise; #>       // fix future gp based on last estimated #>       if (t > gp_n) { #>         gp[(gp_n + 1):t] = rep_vector(noise[gp_n], t - gp_n); #>       } #>     }else{ #>       gp[2:(gp_n + 1)] = noise; #>       gp = cumulative_sum(gp); #>     } #>   } #>   // Calculate Rt #>   R = rep_vector(log_R, t) + bp + gp; #>   R = exp(R); #>   return(R); #> } #> // Rt priors #> void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth, #>            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time, #>            real r_logmean, real r_logsd, real prior_infections, #>            real prior_growth) { #>   // prior on R #>   log_R ~ normal(r_logmean, r_logsd); #>   //breakpoint effects on Rt #>   if (bp_n > 0) { #>     bp_sd[1] ~ normal(0, 0.1) T[0,]; #>     bp_effects ~ normal(0, bp_sd[1]); #>   } #>   // initial infections #>   initial_infections ~ normal(prior_infections, 0.2); #>   if (seeding_time > 1) { #>     initial_growth ~ normal(prior_growth, 0.2); #>   } #> } #>  #> // calculate infectiousness (weighted sum of the generation time and infections) #> // for a single time point #> real update_infectiousness(vector infections, vector gt_pmf, #>                            int seeding_time, int max_gt, int index){ #>   // work out where to start the convolution of past infections with the #>   // generation time distribution: (current_time - maximal generation time) if #>   // that is >= 1, otherwise 1 #>   int inf_start = max(1, (index + seeding_time - max_gt)); #>   // work out where to end the convolution: (current_time - 1) #>   int inf_end = (index + seeding_time - 1); #>   // number of indices of the generation time to sum over (inf_end - inf_start + 1) #>   int pmf_accessed = min(max_gt, index + seeding_time - 1); #>   // calculate the elements of the convolution #>   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed)); #>   return(new_inf); #> } #> // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections) #> vector generate_infections(vector oR, int uot, #>                            real gt_mean, real gt_sd, int max_gt, #>                            real[] initial_infections, real[] initial_growth, #>                            int pop, int ht) { #>   // time indices and storage #>   int ot = num_elements(oR); #>   int nht = ot - ht; #>   int t = ot + uot; #>   vector[ot] R = oR; #>   real exp_adj_Rt; #>   vector[t] infections = rep_vector(1e-5, t); #>   vector[ot] cum_infections = rep_vector(0, ot); #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // generation time pmf #>   vector[max_gt] gt_pmf; #>   if (gt_sd > 0) { #>     // SD > 0: use discretised gamma #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     // SD == 0: use discretised delta #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   // Initialise infections using daily growth #>   infections[1] = exp(initial_infections[1]); #>   if (uot > 1) { #>     for (s in 2:uot) { #>       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1)); #>     } #>   } #>   // calculate cumulative infections #>   if (pop) { #>     cum_infections[1] = sum(infections[1:uot]); #>   } #>   // iteratively update infections #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s); #>     if (pop && s > nht) { #>       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht])); #>       exp_adj_Rt = exp_adj_Rt > 1 ? 1 : exp_adj_Rt; #>       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt); #>     }else{ #>       infections[s + uot] += R[s] * infectiousness[s]; #>     } #>     if (pop && s < ot) { #>       cum_infections[s + 1] = cum_infections[s] + infections[s + uot]; #>     } #>   } #>   return(infections); #> } #> // backcalculate infections using mean shifted cases and non-parametric noise #> vector deconvolve_infections(vector shifted_cases, vector noise, int fixed, #>                              int prior) { #>   int t = num_elements(shifted_cases); #>   vector[t] infections = rep_vector(1e-5, t); #>   if(!fixed) { #>     vector[t] exp_noise = exp(noise); #>     if (prior == 1) { #>       infections = infections + shifted_cases .* exp_noise; #>     }else if (prior == 0) { #>      infections = infections + exp_noise; #>     }else if (prior == 2) { #>       infections[1] = infections[1] + shifted_cases[1] * exp_noise[1]; #>       for (i in 2:t) { #>         infections[i] = infections[i - 1] * exp_noise[i]; #>       } #>     } #>   }else{ #>     infections = infections + shifted_cases; #>   } #>   return(infections); #> } #> // Update the log density for the generation time distribution mean and sd #> void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, #>                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) { #>   if (gt_mean_sd > 0) { #>     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight; #>   } #>   if (gt_sd_sd > 0) { #>     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight; #>   } #> } #>  #>  #> // apply day of the week effect #> vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) { #>   int t = num_elements(reports); #>   int wl = num_elements(effect); #>   // scale day of week effect #>   vector[wl] scaled_effect = wl * effect; #>   vector[t] scaled_reports; #>   for (s in 1:t) { #>     // add reporting effects (adjust for simplex scale) #>     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]]; #>    } #>   return(scaled_reports); #> } #> // Scale observations by fraction reported and update log density of #> // fraction reported #> vector scale_obs(vector reports, real frac_obs) { #>   int t = num_elements(reports); #>   vector[t] scaled_reports; #>   scaled_reports = reports * frac_obs; #>   return(scaled_reports); #> } #> // Calculate a truncation CMF #> vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) { #>     int  trunc_indexes[trunc_max]; #>     vector[trunc_max] cmf; #>     cmf = discretised_lognormal_pmf(trunc_mean, trunc_sd, trunc_max, 0); #>     cmf[1] = cmf[1] + 1e-8; #>     cmf = cumulative_sum(cmf); #>     cmf = reverse_mf(cmf); #>     return(cmf); #> } #> // Truncate observed data by some truncation distribution #> vector truncate(vector reports, real truncation_mean, real truncation_sd, #>                 int truncation_max, int reconstruct) { #>   int t = num_elements(reports); #>   vector[t] trunc_reports = reports; #>   // Calculate cmf of truncation delay #>   int trunc_max = truncation_max > t ? t : truncation_max; #>   vector[trunc_max] cmf; #>   int first_t = t - trunc_max + 1; #>   cmf = truncation_cmf(truncation_mean, truncation_sd, trunc_max); #>   // Apply cdf of truncation delay to truncation max last entries in reports #>   if (reconstruct) { #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf; #>   }else{ #>     trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf; #>   } #>   return(trunc_reports); #> } #> // Truncation distribution priors #> void truncation_lp(real[] truncation_mean, real[] truncation_sd, #>                    real[] trunc_mean_mean, real[] trunc_mean_sd, #>                    real[] trunc_sd_mean, real[] trunc_sd_sd) { #>   int truncation = num_elements(truncation_mean); #>   if (truncation) { #>     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd); #>     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd); #>   } #> } #> // update log density for reported cases #> void report_lp(int[] cases, vector reports, #>                real[] rep_phi, real phi_mean, real phi_sd, #>                int model_type, real weight) { #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     // the reciprocal overdispersion parameter (phi) #>     rep_phi[model_type] ~ normal(phi_mean, phi_sd) T[0,]; #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>     // defer to poisson if phi is large, to avoid overflow or #>     // if poisson specified #>   } #>   if (sqrt_phi > 1e4) { #>     if (weight == 1) { #>       cases ~ poisson(reports); #>     }else{ #>       target += poisson_lpmf(cases | reports) * weight; #>     } #>   } else { #>     if (weight == 1) { #>       cases ~ neg_binomial_2(reports, sqrt_phi); #>     }else{ #>       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi); #>     } #>   } #>    #> } #> // update log likelihood (as above but not vectorised and returning log likelihood) #> vector report_log_lik(int[] cases, vector reports, #>                       real[] rep_phi, int model_type, real weight) { #>   int t = num_elements(reports); #>   vector[t] log_lik; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>   // the reciprocal overdispersion parameter (phi) #>   sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>  #>   // defer to poisson if phi is large, to avoid overflow #>   if (sqrt_phi > 1e4) { #>     for (i in 1:t) { #>       log_lik[i] = poisson_lpmf(cases[i] | reports[i]) * weight; #>     } #>   } else { #>     for (i in 1:t) { #>       log_lik[i] = neg_binomial_2_lpmf(cases[i] | reports[i], sqrt_phi) * weight; #>     } #>     } #>   return(log_lik); #> } #> // sample reported cases from the observation model #> int[] report_rng(vector reports, real[] rep_phi, int model_type) { #>   int t = num_elements(reports); #>   int sampled_reports[t]; #>   real sqrt_phi = 1e5; #>   if (model_type) { #>     sqrt_phi = 1 / sqrt(rep_phi[model_type]); #>   } #>      #>   for (s in 1:t) { #>     // defer to poisson if phi is large, to avoid overflow #>     if (sqrt_phi > 1e4) { #>       sampled_reports[s] = poisson_rng(reports[s] > 1e8 ? 1e8 : reports[s]); #>     } else { #>       sampled_reports[s] = neg_binomial_2_rng(reports[s] > 1e8 ? 1e8 : reports[s], sqrt_phi); #>     } #>   } #>   return(sampled_reports); #> } #>  #> // calculate Rt directly from inferred infections #> vector calculate_Rt(vector infections, int seeding_time, #>                     real gt_mean, real gt_sd, int max_gt, #>                     int smooth) { #>   vector[max_gt] gt_pmf; #>   int t = num_elements(infections); #>   int ot = t - seeding_time; #>   vector[ot] R; #>   vector[ot] sR; #>   vector[ot] infectiousness = rep_vector(1e-5, ot); #>   // calculate PMF of the generation time #>   if (gt_sd > 0) { #>     gt_pmf = discretised_gamma_pmf(gt_mean, gt_sd, max_gt) + 1e-5; #>   } else { #>     gt_pmf = discretised_delta_pmf(max_gt); #>   } #>   gt_pmf = reverse_mf(gt_pmf); #>   // calculate Rt using Cori et al. approach #>   for (s in 1:ot) { #>     infectiousness[s] += update_infectiousness( #>       infections, gt_pmf, seeding_time, max_gt, s #>     ); #>     R[s] = infections[s + seeding_time] / infectiousness[s]; #>   } #>   if (smooth) { #>     for (s in 1:ot) { #>       real window = 0; #>       sR[s] = 0; #>       for (i in max(1, s - smooth):min(ot, s + smooth)) { #>         sR[s] += R[i]; #>         window += 1; #>       } #>       sR[s] = sR[s] / window; #>     } #>   }else{ #>     sR = R; #>   } #>   return(sR); #> } #> // Convert an estimate of Rt to growth #> real[] R_to_growth(vector R, real gt_mean, real gt_sd) { #>   int t = num_elements(R); #>   real r[t]; #>   if (gt_sd > 0) { #>     real k = pow(gt_sd / gt_mean, 2); #>     for (s in 1:t) { #>       r[s] = (pow(R[s], k) - 1) / (k * gt_mean); #>     } #>   } else { #>     // limit as gt_sd -> 0 #>     for (s in 1:t) { #>       r[s] = log(R[s]) / gt_mean; #>     } #>   } #>   return(r); #> } #> } #>  #>  #> data { #>  #>   int t;                                            // unobserved time #>   int seeding_time;                                 // time period used for seeding and not observed #>   int horizon;                                      // forecast horizon #>   int future_time;                                  // time in future for Rt #>   int<lower = 0> cases[t - horizon - seeding_time]; // observed cases #>   vector<lower = 0>[t] shifted_cases;               // prior infections (for backcalculation) #>  #>   int delays;                  // no. of delay distributions #>   real delay_mean_sd[delays];  // prior sd of mean incubation period #>   real delay_mean_mean[delays];// prior mean of mean incubation period #>   real delay_sd_mean[delays];  // prior sd of sd of incubation period #>   real delay_sd_sd[delays];    // prior sd of sd of incubation period #>   int max_delay[delays];       // maximum incubation period #>  #>   real L;\t\t\t\t                     // boundary value for infections gp #>   int<lower=1> M;\t\t\t               // basis functions for infections gp #>   real ls_meanlog;                   // meanlog for gp lengthscale prior #>   real ls_sdlog;                     // sdlog for gp lengthscale prior #>   real<lower=0> ls_min;              // Lower bound for the lengthscale #>   real<lower=0> ls_max;              // Upper bound for the lengthscale #>   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter #>   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern #>   int stationary;                    // is underlying gaussian process first or second order #>   int fixed;                         //  should a gaussian process be used #>  #>   real gt_mean_sd;                   // prior sd of mean generation time #>   real gt_mean_mean;                 // prior mean of mean generation time #>   real gt_sd_mean;                   // prior mean of sd of generation time #>   real gt_sd_sd;                     // prior sd of sd of generation time #>   int max_gt;                        // maximum generation time #>  #>   int estimate_r;                    // should the reproduction no be estimated (1 = yes) #>   real prior_infections;             // prior for initial infections #>   real prior_growth;                 // prior on initial growth rate #>   real <lower = 0> r_mean;           // prior mean of reproduction number #>   real <lower = 0> r_sd;             // prior standard deviation of reproduction number #>   int bp_n;                          // no of breakpoints (0 = no breakpoints) #>   int breakpoints[t - seeding_time]; // when do breakpoints occur #>   int future_fixed;                  // is underlying future Rt assumed to be fixed #>   int fixed_from;                    // Reference date for when Rt estimation should be fixed #>   int pop;                           // Initial susceptible population #>  #>   int backcalc_prior;                // Prior type to use for backcalculation #>   int rt_half_window;                // Half the moving average window used when calculating Rt #>  #>   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7) #>   int model_type;                    // type of model: 0 = poisson otherwise negative binomial #>   real phi_mean;                      // Mean and sd of the normal prior for the #>   real phi_sd;                        // reporting process #>   int week_effect;                   // length of week effect #>   int truncation;                    // 1/0 indicating if truncation should be adjusted for #>   real trunc_mean_mean[truncation];  // truncation mean of mean #>   real trunc_mean_sd[truncation];    // truncation sd of mean #>   real trunc_sd_mean[truncation];    // truncation mean of sd #>   real trunc_sd_sd[truncation];      // truncation sd of sd #>   int max_truncation[truncation];    // maximum truncation supported #>   int obs_scale;                     // logical controlling scaling of observations #>   real obs_scale_mean;               // mean scaling factor for observations #>   real obs_scale_sd;                 // standard deviation of observation scaling #>   real obs_weight;                   // weight given to observation in log density #>   int likelihood;                    // Should the likelihood be included in the model #>   int return_likelihood; // Should the likehood be returned by the model #> } #>  #> transformed data{ #>   // observations #>   int ot = t - seeding_time - horizon;  // observed time #>   int ot_h = ot + horizon;  // observed time + forecast horizon #>   // gaussian process #>   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from); #>   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function #>   // Rt #>   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); #>   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); #> } #>  #> parameters{ #>   // gaussian process #>   real<lower = ls_min,upper=ls_max> rho[fixed ? 0 : 1];  // length scale of noise GP #>   real<lower = 0> alpha[fixed ? 0 : 1];    // scale of of noise GP #>   vector[fixed ? 0 : M] eta;               // unconstrained noise #>   // Rt #>   vector[estimate_r] log_R;                // baseline reproduction number estimate (log) #>   real initial_infections[estimate_r] ;    // seed infections #>   real initial_growth[estimate_r && seeding_time > 1 ? 1 : 0]; // seed growth rate #>   real<lower = 0, upper = max_gt> gt_mean[estimate_r && gt_mean_sd > 0]; // mean of generation time (if uncertain) #>   real<lower = 0> gt_sd[estimate_r && gt_sd_sd > 0];       // sd of generation time (if uncertain) #>   real<lower = 0> bp_sd[bp_n > 0 ? 1 : 0]; // standard deviation of breakpoint effect #>   real bp_effects[bp_n];                   // Rt breakpoint effects #>   // observation model #>   real delay_mean[delays];                 // mean of delays #>   real<lower = 0> delay_sd[delays];        // sd of delays #>   simplex[week_effect] day_of_week_simplex;// day of week reporting effect #>   real<lower = 0> frac_obs[obs_scale];     // fraction of cases that are ultimately observed #>   real truncation_mean[truncation];        // mean of truncation #>   real<lower = 0> truncation_sd[truncation]; // sd of truncation #>   real<lower = 0> rep_phi[model_type];     // overdispersion of the reporting process #> } #>  #> transformed parameters { #>   vector[fixed ? 0 : noise_terms] noise;                    // noise  generated by the gaussian process #>   vector<lower = 0, upper = 10 * r_mean>[estimate_r > 0 ? ot_h : 0] R; // reproduction number #>   vector[t] infections;                                     // latent infections #>   vector[ot_h] reports;                                     // estimated reported cases #>   vector[ot] obs_reports;                                   // observed estimated reported cases #>   // GP in noise - spectral densities #>   if (!fixed) { #>     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type); #>   } #>   // Estimate latent infections #>   if (estimate_r) { #>     // via Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     R = update_Rt(ot_h, log_R[estimate_r], noise, breakpoints, bp_effects, stationary); #>     infections = generate_infections(R, seeding_time, set_gt_mean, set_gt_sd, max_gt, #>                                      initial_infections, initial_growth, #>                                      pop, future_time); #>   } else { #>     // via deconvolution #>     infections = deconvolve_infections(shifted_cases, noise, fixed, backcalc_prior); #>   } #>   // convolve from latent infections to mean of observations #>   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time); #>  // weekly reporting effect #>  if (week_effect > 1) { #>    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex); #>   } #>   // scaling of reported cases by fraction observed #>  if (obs_scale) { #>    reports = scale_obs(reports, frac_obs[1]); #>  } #>  // truncate near time cases to observed reports #>  if (truncation) { #>    obs_reports = truncate( #>     reports[1:ot], truncation_mean[1], truncation_sd[1], max_truncation[1], 0 #>   ); #>  } else { #>    obs_reports = reports[1:ot]; #>  } #> } #>  #> model { #>   // priors for noise GP #>   if (!fixed) { #>     gaussian_process_lp( #>       rho[1], alpha[1], eta, ls_meanlog, ls_sdlog, ls_min, ls_max, alpha_sd #>     ); #>   } #>   // penalised priors for delay distributions #>   delays_lp( #>     delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, #>     delay_sd_sd, t #>   ); #>   // priors for truncation #>   truncation_lp( #>     truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd,  #>     trunc_sd_mean, trunc_sd_sd #>   ); #>   if (estimate_r) { #>     // priors on Rt #>     rt_lp( #>       log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, #>       seeding_time, r_logmean, r_logsd, prior_infections, prior_growth #>     ); #>     // penalised_prior on generation interval #>     generation_time_lp( #>       gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot #>     ); #>   } #>   // prior observation scaling #>   if (obs_scale) { #>     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,]; #>   } #>   // observed reports from mean of reports (update likelihood) #>   if (likelihood) { #>     report_lp( #>       cases, obs_reports, rep_phi, phi_mean, phi_sd, model_type, obs_weight #>     ); #>   } #> } #>  #> generated quantities { #>   int imputed_reports[ot_h]; #>   vector[estimate_r > 0 ? 0: ot_h] gen_R; #>   real r[ot_h]; #>   vector[return_likelihood ? ot : 0] log_lik; #>   if (estimate_r){ #>     // estimate growth from estimated Rt #>     real set_gt_mean = (gt_mean_sd > 0 ? gt_mean[1] : gt_mean_mean); #>     real set_gt_sd = (gt_sd_sd > 0 ? gt_sd[1] : gt_sd_mean); #>     r = R_to_growth(R, set_gt_mean, set_gt_sd); #>   }else{ #>     // sample generation time #>     real gt_mean_sample = (gt_mean_sd > 0 ? normal_rng(gt_mean_mean, gt_mean_sd) : gt_mean_mean); #>     real gt_sd_sample = (gt_sd_sd > 0 ? normal_rng(gt_sd_mean, gt_sd_sd) : gt_sd_mean); #>     // calculate Rt using infections and generation time #>     gen_R = calculate_Rt( #>       infections, seeding_time, gt_mean_sample, gt_sd_sample, max_gt, #>       rt_half_window #>     ); #>     // estimate growth from calculated Rt #>     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample); #>   } #>   // simulate reported cases #>   imputed_reports = report_rng(reports, rep_phi, model_type); #>   // log likelihood of model #>   if (return_likelihood) { #>     log_lik = report_log_lik( #>       cases, obs_reports, rep_phi, model_type, obs_weight #>     ); #>   } #> }  #>  #> $method #> [1] \"vb\" #>  #> $trials #> [1] 10 #>  #> $iter #> [1] 10000 #>  #> $output_samples #> [1] 2000 #>  #> $return_fit #> [1] TRUE #>"},{"path":"epiforecasts.io/EpiNow2/reference/summarise_key_measures.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise rt and cases — summarise_key_measures","title":"Summarise rt and cases — summarise_key_measures","text":"Produces summarised data frames output across regions. Used internally regional_summary.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summarise_key_measures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise rt and cases — summarise_key_measures","text":"","code":"summarise_key_measures(   regional_results = NULL,   results_dir = NULL,   summary_dir = NULL,   type = \"region\",   date = \"latest\" )"},{"path":"epiforecasts.io/EpiNow2/reference/summarise_key_measures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise rt and cases — summarise_key_measures","text":"regional_results list dataframes produced get_regional_results results_dir Character string indicating directory extract results. summary_dir Character string directory save results csv. type Character string, region identifier apply (defaults region). date Character string (format \"yyyy-mm-dd\") indicating date extract data . Defaults \"latest\" finds latest results available.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summarise_key_measures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise rt and cases — summarise_key_measures","text":"list summarised Rt, cases date infection cases date report","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/summarise_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise Real-time Results — summarise_results","title":"Summarise Real-time Results — summarise_results","text":"Used internally regional_summary produce summary table results. May streamlined later releases.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summarise_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise Real-time Results — summarise_results","text":"","code":"summarise_results(   regions,   summaries = NULL,   results_dir = NULL,   target_date = NULL,   region_scale = \"Region\" )"},{"path":"epiforecasts.io/EpiNow2/reference/summarise_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise Real-time Results — summarise_results","text":"regions character string containing list regions extract results (must results target date). summaries list summary data frames output epinow results_dir optional character string indicating location results directory extract results . target_date character string indicating target date extract results . regions must results date. region_scale character string indicating name give regions summarised.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summarise_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise Real-time Results — summarise_results","text":"list summary data","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.epinow.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary output from epinow — summary.epinow","title":"Summary output from epinow — summary.epinow","text":"summary method class \"epinow\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.epinow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary output from epinow — summary.epinow","text":"","code":"# S3 method for epinow summary(object, output = \"estimates\", date = NULL, params = NULL, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/summary.epinow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary output from epinow — summary.epinow","text":"object list output produced \"epinow\". output character string output summarise. Defaults \"estimates\" also supports \"forecast\", \"estimated_reported_cases\". date date form \"yyyy-mm-dd\" inspect estimates . params character vector parameters filter . ... Pass additional summary arguments lower level methods","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.epinow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary output from epinow — summary.epinow","text":"Returns data frame summary output","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/summary.estimate_infections.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary output from estimate_infections — summary.estimate_infections","title":"Summary output from estimate_infections — summary.estimate_infections","text":"summary method class \"estimate_infections\".","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.estimate_infections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary output from estimate_infections — summary.estimate_infections","text":"","code":"# S3 method for estimate_infections summary(object, type = \"snapshot\", date = NULL, params = NULL, ...)"},{"path":"epiforecasts.io/EpiNow2/reference/summary.estimate_infections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary output from estimate_infections — summary.estimate_infections","text":"object list output produced \"estimate_infections\". type character vector data types return. Defaults \"snapshot\" also supports \"parameters\", \"samples\". \"snapshot\" returns summary given date (default latest date informed data). \"parameters\" returns summarised parameter estimates can filtered using params show just parameters interest date. \"samples\" similarly returns posterior samples. date date form \"yyyy-mm-dd\" inspect estimates . params character vector parameters filter . ... Pass additional arguments report_summary","code":""},{"path":"epiforecasts.io/EpiNow2/reference/summary.estimate_infections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary output from estimate_infections — summary.estimate_infections","text":"Returns data frame summary output","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Truncation Distribution Options — trunc_opts","title":"Truncation Distribution Options — trunc_opts","text":"Returns truncation distribution formatted usage downstream functions. See estimate_truncation approach estimate distribution.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Truncation Distribution Options — trunc_opts","text":"","code":"trunc_opts(dist = NULL)"},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Truncation Distribution Options — trunc_opts","text":"dist list defining truncation distribution, defaults NULL case truncation used. Must following elements defined: \"mean\", \"mean_sd\", \"sd_mean\", \"sd_sd\", \"max\" defining truncated log normal (parameters except max defined logged form).","code":""},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Truncation Distribution Options — trunc_opts","text":"list summarising input truncation distribution.","code":""},{"path":[]},{"path":"epiforecasts.io/EpiNow2/reference/trunc_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Truncation Distribution Options — trunc_opts","text":"","code":"# no truncation trunc_opts() #> $truncation #> [1] 0 #>  #> $trunc_mean_mean #> numeric(0) #>  #> $trunc_mean_sd #> numeric(0) #>  #> $trunc_sd_mean #> numeric(0) #>  #> $trunc_sd_sd #> numeric(0) #>  #> $max_truncation #> numeric(0) #>"},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"Allows inverse gamma distribution . tuned less 0.01 probability mass function falls outside specified bounds. required using inverse gamma prior, example Gaussian process. inverse gamma priors currently use function stability issues may deprecated later date.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"","code":"tune_inv_gamma(lower = 2, upper = 21)"},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"lower Numeric, defaults 2. Lower truncation bound. upper Numeric, defaults 21. Upper truncation bound.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"list alpha beta values describe inverse gamma distribution achieves target truncation.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/tune_inv_gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tune an Inverse Gamma to Achieve the Target Truncation — tune_inv_gamma","text":"","code":"tune_inv_gamma(lower = 2, upper = 21) #> $alpha #> [1] 4.5 #>  #> $beta #> [1] 21.5 #>"},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":null,"dir":"Reference","previous_headings":"","what":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"Makes sure forecast returned user specified time period beyond target date.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"","code":"update_horizon(horizon, target_date, reported_cases)"},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"horizon Numeric, defaults 7. Number days future forecast. target_date Date, defaults maximum found data specified. reported_cases data frame confirmed cases (confirm) date (date). confirm must integer date must date format.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_horizon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updates Forecast Horizon Based on Input Data and Target — update_horizon","text":"Numeric forecast horizon adjusted users intention","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Update a List — update_list","title":"Update a List — update_list","text":"Used handle updating settings list. example making changes opts_list output.","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update a List — update_list","text":"","code":"update_list(defaults = list(), optional = list())"},{"path":"epiforecasts.io/EpiNow2/reference/update_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update a List — update_list","text":"defaults list default settings optional list optional settings override defaults","code":""},{"path":"epiforecasts.io/EpiNow2/reference/update_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update a List — update_list","text":"list","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-134","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.3.4","title":"EpiNow2 1.3.4","text":"maintenance release focussing bug fixes package infrastructure updates.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"package-1-3-4","dir":"Changelog","previous_headings":"","what":"Package","title":"EpiNow2 1.3.4","text":"Update GitHub Action files new versions. Switched using seq_along() rather 1:length(). Fixed broken example documentation regional_runtimes(). Add compatibility changes latest version rstan rstantools. Remove legacy use pkgnet package dependency visualisation. Slight edits model outline estimate_infections(). Restyled code using styler. Dropped dependency RcppParallel.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-133","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.3.3","title":"EpiNow2 1.3.3","text":"release adds range new minor features, squashes bugs, enhances documentation, expands unit testing, implements minor run-time optimisations, removes obsolete features. Thanks @Bisaloo, @hsbadr, @LloydChapman, @medewitt, @sbfnk contributing release. Thanks @sbfnk, @pearsonca, @nicholasdavies regression testing release 1.3.2.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"new-features-1-3-3","dir":"Changelog","previous_headings":"","what":"New features","title":"EpiNow2 1.3.3","text":"Added supported simulate_infections data.frame R samples can passed instead vector R values. @seabbs. Added extraction posterior samples summary method estimate_infections. @seabbs. Exposed zero_threshold users allowing control zeros NAs count data treated true zeros versus reporting errors require smoothing. @seabbs. Added support varying length day week effect (see obs_opts()). allows, example, fitting data cases reported every 3 days. @seabbs. Adds option plot_estimates() higher level functions choose estimate type plot. @seabbs. Adds support fixed generation times (either mean fixed gamma distributed). @sbfnk. Adds support optionally using inverse gamma prior lengthscale gaussian process. scaled prior tested short long simulations default prior may make model unstable. new prior stable long simulations adaptively change distribution based simulation length (total number days) without relying user inputs fixed defaults. can tested setting ls_sd = 0 gp_opts(). @hsbadr. Updated prior magnitude gaussian process 0.05 vs 0.1 leading slightly stable estimates. @hsbadr. Added argument (plot) regional_summary allow plotting optional. Closes #250. @seabbs #317","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"model-changes-1-3-3","dir":"Changelog","previous_headings":"","what":"Model changes","title":"EpiNow2 1.3.3","text":"Added support varying length day week effect (see obs_opts()). allows, example, fitting data cases reported every 3 days. Minor optimisations observation model using target likelihood definition approach required use fmax fmin using statements. @seabbs. Added support users setting overdispersion (parameterised one square root phi) reporting process. accessible via phi argument obs_opts default normal distribution mean 0 standard deviation 1 truncated 0 remaining unchanged. @seabbs. Added additive noise term estimate_truncation model deal zeroes. @sbfnk. Switched using optimised versions discretised distributions supported reporting delay generation time. based implementation epinowcast Adrian Lison Sam Abbott. @seabbs #320.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"documentation-1-3-3","dir":"Changelog","previous_headings":"","what":"Documentation","title":"EpiNow2 1.3.3","text":"Updates synthetic delays reduce runtime examples. @seabbs. Additional statements make clear users examples used real world analysis. @seabbs. Additional context README package functionality. @seabbs. Added work progress model definitions resource list case studies using package. @seabbs.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"package-changes-1-3-3","dir":"Changelog","previous_headings":"","what":"Package changes","title":"EpiNow2 1.3.3","text":"Added contributing.md guide contributors added pre-commit support check new contributions styling. @seabbs. Better test skipping thanks @Bisaloo. Switched cowplot::theme_cowplot() ggplot2::theme_bw(). allows removal cowplot dependency well making plots visible users saving pngs using dark theme. @seabbs. default epinow downstream functions remove leading zeros. Now optional new filter_leading_zeros option. Thanks @LloydChapman #285. Basic tests added cover estimate_secondary(), forecast_secondary(), estimate_truncation(). @seabbs #315. Add basic snapshot tests adjust_infection_to_report. @seabbs #316. Update use rstantools manage compiler flags. Update Dockerfile work better vscode.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"other-changes-1-3-3","dir":"Changelog","previous_headings":"","what":"Other changes","title":"EpiNow2 1.3.3","text":"Updated classification growth use stable rather unsure Rt approximately 1. @seabbs. default parallisation changed future::multisession() future::multiprocess() latter depreciated future package. @seabbs @sbfnk. Ensure seeding time least maximum generation time (@sbfnk).","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"deprecated-features-1-3-3","dir":"Changelog","previous_headings":"","what":"Deprecated features","title":"EpiNow2 1.3.3","text":"simulate_cases() forecast_infections() deprecated removed. functions depend EpiSoon archived near equivalent functionality available within EpiNow2 packages (@seabbs). Functions supporting secondary forecasting using forecast_infections() (.e `epinow()) removed along arguments supported (@seabbs). global_map(), country_map(), theme_map() deprecated removed. functions used support reporting reproduction number estimates considered scope EpiNow2. finding useful contacting EpiNow2 developers (@seabbs).","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"bug-fixes-1-3-3","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"EpiNow2 1.3.3","text":"Fixed bug deconvolution Rt estimation method mean generation time used standard deviation. default package generation time close impact limited cases standard deviation << mean result accurate Rt estimates. @seabbs. Fixed bug number threads used data.table package set one global environment. Now number threads used data.table set whatever used specified exit. @medewitt. Fixed bug simulate_infections forecast_secondary meant Poisson observation model used estimation lead error. @seabbs. Fixed bug use_rt = FALSE properly cancel user settings. @sbfnk. Fixed bug estimate_truncation phi initialised. @sbfnk. Fixed bug zero_threshold ignored post-processing happening. maintain backwards compatibility default changed Inf (.e. zero threshold). @LloydChapman #285. Fixed bug setting obs_opts(return_likelihood = TRUE) fails. @sbfnk #333.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-132","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.3.2","title":"EpiNow2 1.3.2","text":"CRAN release: 2020-12-14 release model run times reduced using combination code optimisation testing reduce likelihood long running edge cases. Model flexibility also increased, particularly back calculation approach now supports increased range prior choices. significant development release edition experimental estimate_secondary model (supporting forecast plot functions). allows downstream target forecast observation. Example use cases include forecasting deaths test positive cases hospital bed usage hospital admissions. approach intended provide alternative models multiple targets estimated jointly.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"new-features-1-3-2","dir":"Changelog","previous_headings":"","what":"New features","title":"EpiNow2 1.3.2","text":"Added new argument, prior, backcalc_opts(). allows use different priors underlying latent infections estimating using deconvolution/back-calculation rather package default using generated Rt model (enable option setting rt = NULL). default prior remains smoothed mean delay shifted reported cases optionally prior can now also used (scenarios data untrustworthy likely perform extremely poorly real time).addition, previously estimated infections can used (.e infections[t] = infections[t-1] * exp(GP)) approximate version generative Rt model weight previous infections using generation time. Updates smoothing applied mean shifted reported cases used prior back calculation prior = \"reports\" partial centred moving average rather right aligned moving average. choice means increasing prior window alter location epidemic peaks using right alighted moving average. Updates default smoothing applied mean shifted reported cases 14 days rather 7 usage indicates provided much weight small scale changes. remains user set able. Adds new argument init_fit stan_opts() enables user pass stanfit use initialise model fit estimate_infections(). Optionally init_fit = \"cumulative\" can also passed first fits cumulative data uses result initialise full fit incidence data. approach based approach used epidemia authored James Scott. Currently stan warnings initial fit broadcast user may cause concern short run time approximate settings often lead poor convergence. Adds estimate_secondary forecast_secondary along plot method new option function (secondary_opts()). functions implement generic model forecasting secondary observation (hospital bed usage, deaths hospital) entirely depends primary observation (hospital admissions) via combination convolving delay adding/subtracting current observations. share observation model optional features used estimate_infections support data truncation, scaling (primary secondary observations), multiple log normal delays, day week effect, various error models. stationary_opts() allows easy specification common use cases (incidence prevalence variables). See documentation examples model details.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"other-changes-1-3-2","dir":"Changelog","previous_headings":"","what":"Other changes","title":"EpiNow2 1.3.2","text":"Updates discretised_gamma_pmf (discretised truncated Gamma PMF) discretised_lognormal_pmf (discretised truncated lognormal PMF) limit/clip values parameters prespecified lower upper bounds. Tightens initialisation fitting estimate_infections reducing standard deviations used scaling factor 0.1 create_initial_conditions. Adds boundary checking gt_mean (mean generation time) reject samples mean greater gt_max (maximum allowed generation time). Adds boundary checking reject standard deviations negative. Adds boundary check R values reject 10 times greater mean initial prior. scenarios require users supply prior completely misspecified (.e prior mean 1 posterior mean 50). Refactor update_rt (internal stan function found inst/stan/functions/rt.stan) vectorised. change reduces run times approximately 1- ~ 20% (though tested small subset examples) opens way future model extensions (additive rather multiplicative random walks, introducing covariates). Switched reporting two significant figures summary tables Reduced minimum default Gaussian process length scale 3 days 7 based experience running model scale.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-131","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.3.1","title":"EpiNow2 1.3.1","text":"CRAN release: 2020-11-22 release focusses model stability, functional rewrite model implementation, finalising interface across package, introducing additional tooling. additional tooling includes: support adjusting estimating data truncation, multiple approaches estimating Rt (including default generative Rt approach, de-convolution coupled Rt calculation, EpiEstim like estimation observed cases robust observation model), optional scaling observed data, optional adjustment future forecasts based population susceptibility. examples also expanded links Covid-19 specific work flows may interest users. implementation model options now considered maturing next release planned contain documentation underlying approach, case studies, validation, evaluation various supported options, tools dealing secondary reports dependent primary report (.e hospital admissions hospital bed usage). interested contributing features please contact package authors submit PR. User contributions warmly welcomed.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"new-features-1-3-1","dir":"Changelog","previous_headings":"","what":"New features","title":"EpiNow2 1.3.1","text":"Rewritten interface estimate_infections divided calls _opts() functions. Options now divided type delays (delay_opts()), Rt (rt_opts()), backcalculation (backcalc_opts()), Gaussian process (gp_opts()), stan arguments (stan_opts()). resulted larger number arguments estimate_infections folded related _opts() function. Please see function documentation examples details. Added support region specific settings arguments take _opts() function regional_epinow using helper functions opts_list update_list alternatively constructing named list entry region estimated. Extended functionality back calculation model Rt can produced via calculation. estimates potentially less reliable produced using generative model model can estimated fraction time. essence similar using back projection method estimating Rt using EpiEstim (default window 1 can updated using backcalc_opts(rt_window)) approaches incorporates uncertainty inputs single estimate. Reduced default maximum generation time incubation period allowed truncated distribution (30 days 15). decreases model run time substantially marginal accuracy cost. new default suitable longer generation times modified user used. Adds basic S3 plot summary measures epinow estimate_infections. Updates initialisation generative Rt model (default) initial infections occur unobserved time (.e first reported case) generated using exponential growth model priors based fitting model first week data. replaces previous approach use delay shifted reported cases multiplied independent noise terms. reduces degrees freedom fitting time cost model flexibility. Alternatives using generative Rt model considered ultimately approaches used introduced spurious variation gaussian process result unreliable Rt estimates due lack historic infections. New simulate_infections function @sbfnk allows simulation different Rt traces combined estimates produced estimate_infections. function likely form basis moving forecasting estimate_infections may improve model stability. Updates implementation Gaussian process support Matern 3/2 Kernel (set default) addition squared exponential kernel. Updates handling Gaussian process arguments overridden settings need passed user making changes. Settings now defined, documented, gp_opts(). length scale now defined using log normal truncated prior mean 21 days standard deviation 7 days truncated 3 days length data default. prior area active research may change future releases. Updates dispersion prior 1 / sqrt(half_normal(0, rho_prior)) based advice dispersion measured reports infections hence priori strong evidence dispersion (may case infections) previous prior overly weighted towards . Updates interface observation model arguments now passed using obs_opts(). removes week_effect family main argument list allow future extensions. Also adds new argument scale controls uncertain fraction cases eventually observed (defined normally distributed). Setting parameter impact Rt estimates. Updates interface Rt settings arguments passed via rt, using rt_opts(), includes initial prior,use_breakpoints, future. Adds new helper argument rw enables easy parameterisation fixed length random walk. changes also help make clear arguments impact Rt generative model back calculation model. Adds adjustment population susceptibility based used {epidemia} Rt fixed future (set passing population rt_opts(pop = initial susceptible population). Note impacts case forecasts output Rt estimates impacts estimates beyond forecast horizon based data already account population susceptibility definition. impact assumption can explored using simulate_infections (updating est$arg$pop example). Adds truncation new argument estimate_infections higher level functions. takes output trunc_opts() allows internally adjusting observed cases truncation. new method estimate_truncation also added support estimating log normal truncation distribution archived versions data set though method currently experimental. Adds estimate_delay user friendly wrapper around bootstrapped_dist_fit.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"other-changes-1-3-1","dir":"Changelog","previous_headings":"","what":"Other changes","title":"EpiNow2 1.3.1","text":"Recoded core stan model functional aim making code modular extendable. Added unit tests internal stan update_rt function. Reworked package logging system improve reporting issues epinow regional_epinow large batch runs. Fix @hsbadr prevent overflow overdispersion larger (switching Poisson approximation). Hitting issue may indicate bug model code need work explore. Moved default verbosity functions (excepting regional_epinow) based whether usage interactive. Removed burn_in argument estimate_infections updates model initialisation mean feature likely longer needed. Please contact developers feel use case argument. Adds utility functions map mean standard deviation log mean log standard deviation log normal distribution (convert_to_logmean convert_to_logsd). Optimised discrete probability mass functions vectorised possible. Updated Gaussian process internally unit scale. Added new function, expose_stan_fns exposes internal stan functions R. enables unit testing, exploration stan functionality potentially within R use cases functions. Updates default warmup 250 samples default adapt_delta 0.98. Adds pooling parameter standard deviation breakpoint effects. Updated documentation added lifecycle badges functions indicate development stage.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-121","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.2.1","title":"EpiNow2 1.2.1","text":"CRAN release: 2020-10-20 release introduces multiple breaking interface changes. Please see README examples new interface. adds range quality life improvements including updating stan interface support fitting chain independently offering variational inference alternative, experimental, fitting option. Notably also adds support nesting logging parallel enabled progress bar via progressr package. Minor bugs fixed core model implementation focussing stability several already implemented features extended. Major model developments planned next release EpiNow2.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"new-features-1-2-1","dir":"Changelog","previous_headings":"","what":"New features","title":"EpiNow2 1.2.1","text":"Added support either NUTs sampling (method = \"exact\") Variational inference (method = \"approximate\"). Update prior initial Rt estimate lognormal rather gamma distributed. users interface remains unchanged parameterisation numerically stable. Added get_dist, get_generation_time, get_incubation_period based ideas @pearsonca. (leads breaking changes removal covid_generation_times covid_incubation_periods). Added setup_logging enable users specify level location logging (wrapping functionality futile.logger). Also added setup_default_logging give users sensible defaults embedded function regional_epinow epinow. Added setup_future making using nested futures easier (required using future = TRUE). Implemented progress bar support using progressr. Added timeout timing option regional_epinow Improved logging warnings regional_epinow Enabled user specify credible intervals desired 20%, 50% 90% calculated default. Also switched high density regions quantiles. Custom credible intervals now supported reporting plotting functions. Added mean sd reporting summaries. Added summary growth rate doubling time. Added new function regional_runtimes summarises run time across regions. Updated estimate_infections interface expanded range options future_rt argument. Users can now choose set Rt time point referenced forecast date.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"bug-fixes-1-2-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"EpiNow2 1.2.1","text":"Fixed y axis max plot_summary. Fix normalisation delay generation time distributions @sbfnk. impact nowcast infections reproduction number estimate. Updated discretised_gamma_pmf (discretised truncated Gamma PMF) constrain gamma shape (inverse) scale parameters positive finite (alpha > 0 beta > 0). Fixed readLines incomplete final line warnings. Fix @medewitt internal fit_chain function interaction rstan timing may introduced exception caused whole regions fail. show current unit tests exploration using examples indicating gap testing.","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"other-changes-1-2-1","dir":"Changelog","previous_headings":"","what":"Other changes","title":"EpiNow2 1.2.1","text":"Updates interface specifying output returned. Moved inherited stan arguments create_stan_args option override using stan_args. leads breaking changes - see examples details new interface. Updated example documentation reflect new interface. Added samples argument get_regional_results make loading samples optional. also allows samples dropped using regional_epinow reduces RAM usage. Cleaned wrapper functions move individual jobs functions. Adds testing high level functions low level unit testing. Adds csv download button interactive table regional summary table. Makevars updated remove dependency GNU Make @hsbadr","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-110","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.1.0","title":"EpiNow2 1.1.0","text":"CRAN release: 2020-09-01 Implemented reporting templates Bug fix estimate reporting Added additional reporting runtime errors Examples global_map country_map expanded @ellisp Improved ISO code matching global_map @ellisp Improvements data frames tibbles supported inputs. Updated reporting templates Updated reporting estimates clearly summarise cases infection report date. Made region summary plots optional. Made reporting decimal places standardised across metrics. README updated @kathsherratt Logging added @joeHickson Updated plotting limited scaling reported data (prevents upper CIs skewing plot). Added uncertainty plot bounds control y axis plots clarity purposes. regional_summary now saves input reported cases data reported_cases.csv. Added optional delay model Rt estimated directly data. option supported using backcalculation .","code":""},{"path":"epiforecasts.io/EpiNow2/news/index.html","id":"epinow2-100","dir":"Changelog","previous_headings":"","what":"EpiNow2 1.0.0","title":"EpiNow2 1.0.0","text":"Rebased package EpiNow Implemented backcalculation, estimation, forecasting, bootstrapped distribution fitting. Added options estimate time-varying reproduction number using Gaussian process (stationary non-stationary), combined optional user supplied breakpoints. Alternatively static reproduction number can assumed combined breakpoints becomes piecewise linear.","code":""}]
